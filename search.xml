<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>软件工程考试要点</title>
      <link href="/posts/28593.html"/>
      <url>/posts/28593.html</url>
      
        <content type="html"><![CDATA[<h1 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h1><h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><h2 id="Ⅰ-考试形式和试卷结构"><a href="#Ⅰ-考试形式和试卷结构" class="headerlink" title="Ⅰ 考试形式和试卷结构"></a>Ⅰ 考试形式和试卷结构</h2><ol><li><p>试卷满分及考试时间<br>本试卷满分为150分，考试时间为180分钟</p></li><li><p>答題方式<br>答题方式为闭卷，笔试。</p></li><li><p>试卷内容结构</p><p>| 内容                       | 占比  |<br>| ————————————— | ——- |<br>| 软件工程基本概念与过程模型 | 约5%  |<br>| 可行性研究与项目计划       | 约5%  |<br>| 软件分析与设计             | 约55% |<br>| 软件验证                   | 约23% |<br>| 软件维护                   | 约2%  |<br>| 软件质量保证               | 约10% |</p></li><li><p>试题结构</p></li></ol><div class="table-container"><table><thead><tr><th>题型</th><th>分值</th></tr></thead><tbody><tr><td>填空题</td><td>30分（一空一分）</td></tr><tr><td>选择题</td><td>20分（每题2分）</td></tr><tr><td>简答题</td><td>30分（6题，每题5分）</td></tr><tr><td>分析设计题</td><td>50分（2题，每题25分）</td></tr><tr><td>综合题</td><td>20分（2题，每题10分）</td></tr></tbody></table></div><h2 id="Ⅱ-考察内容"><a href="#Ⅱ-考察内容" class="headerlink" title="Ⅱ 考察内容"></a>Ⅱ 考察内容</h2><ol><li>软件工程基本概念与过程模型<ol><li>软件工程的产生</li><li>软件工程的研究对象与基本原理</li><li>软件开发方法</li><li>软件工程工具和环境</li><li>软件生存期过程</li><li>软件工程常用生存周期模型</li><li>软件文档</li><li>敏捷软件开发</li></ol></li><li>可行性研究与项目计划<ol><li>系统分析</li><li>成本估计</li><li>效益分析</li><li>风险分析</li><li>进度安排</li><li>项目组织与计划</li></ol></li><li>需求分析<ol><li>需求分析的目标</li><li>需求收集</li><li>需求规格说明</li><li>数据流建模</li><li>实体一关系建模</li><li>用例建模</li><li>对象建模</li><li>统一建模语言UML</li></ol></li><li>软件设计<ol><li>软件设计的任务和过程</li><li>软件设计基本原则</li><li>面向对象设计原则</li><li>面向数据流图的设计方法</li><li>面向对象的设计方法</li><li>面向对象软件设计模式</li><li>模型一视图一控制器框架</li><li>软件体系结构</li><li>软件详细设计</li></ol></li><li>软件验证技术<ol><li>软件测试基础</li><li>代码复审</li><li>白盒测试</li><li>黑盒测试</li><li>单元测试</li><li>集成测试</li><li>确认测试</li><li>系统测试</li><li>调试</li></ol></li><li>软件维护技术<ol><li>软件维护的基本概念</li><li>软件维护过程</li><li>软件可维护性</li><li>软件再工程技术</li></ol></li><li>软件质量保证与分析<ol><li>软件质量</li><li>软件复杂性分析</li><li>IS0软件质量体系</li><li>软件配置管理</li><li>软件过程能力成熟度模型</li><li>参考教材：陈松乔，任胜兵，王国军。现代软件工程。北京：清华大学出版社，2013</li></ol></li></ol><h1 id="第一章-软件工程基本概念与过程模型"><a href="#第一章-软件工程基本概念与过程模型" class="headerlink" title="第一章  软件工程基本概念与过程模型"></a>第一章  软件工程基本概念与过程模型</h1><h2 id="1-1-软件工程的产生"><a href="#1-1-软件工程的产生" class="headerlink" title="1.1 软件工程的产生"></a>1.1 软件工程的产生</h2><p>软件=程序+数据结构+文档</p><p>三个特点：</p><ol><li><p>软件是“开发”出来的，不是“制造”出来的</p></li><li><p>软件可能会被“废弃”，但不会被“用坏”</p></li><li><p>过去的软件大多是“定制”的，而不是“装配”的</p></li></ol><p>为了摆脱软件危机所造成的困境，北大西洋公约组织（NATO）的科学委员会在1968年首次提出“软件工程”的概念。</p><h2 id="1-2-软件工程的研究对象与基本原理"><a href="#1-2-软件工程的研究对象与基本原理" class="headerlink" title="1.2 软件工程的研究对象与基本原理"></a>1.2 软件工程的研究对象与基本原理</h2><p>软件工程是什么：</p><ul><li>性质（能力）：<strong>指导软件开发和维护</strong>的工程性学科；</li><li>理论基础：计算机科学、管理科学和数学等 ；</li><li>手段：采用<strong>工程化</strong>的概念、原理、技术和方法进行软件的开发和维护，把经过时间证明正确的<strong>管理</strong>措施和当前能够得到的最好的<strong>技术、方法</strong>相结合 ；</li><li>目的：以期用<strong>较少的</strong>代价获取<strong>高质量的</strong>软件。</li></ul><p>软件工程的研究对象：标准和规范、过程和模型、方法和技术、工具和环境</p><p>软件工程的四个研究对象构成了以软件质量为核心的层次结构。</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/202111121653970.png" alt="image-20211112165341928" style="zoom: 50%;"></p><p>标准和规范是保证软件质量的关键。过程和模型为方法和技术提供了活动框架，而方法和技术、工具和环境则为实现过程和模型提供了具体方式。</p><p>软件工程的基本原理（1分技术+6分管理）：</p><ol><li>用分阶段的生存周期<strong>计划</strong>严格管理</li><li>坚持进行阶段<strong>评审</strong></li><li>实施严格的产品<strong>控制</strong></li><li>采用现代程序设计<strong>技术</strong></li><li><strong>结果</strong>应能清楚地审查</li><li>开发<strong>小组</strong>的成员应该少而精</li><li>承认不断<strong>改进</strong>软件工程时间的必要性</li></ol><p><strong><em>Boehm认为这7条原理是确保软件产品质量和开发效率的原理的最小集合</em></strong></p><h2 id="1-3-软件开发方法"><a href="#1-3-软件开发方法" class="headerlink" title="1.3 软件开发方法"></a>1.3 软件开发方法</h2><ul><li>软件开发方法是使用定义好的技术（集）及表示符号来组织软件生产过程的方法。</li><li>一般说来，软件开发方法必须在开发步骤、软件文档格式、开发方案评审标准做出规定。</li><li>主要软件开发方法：结构化方法、面向对象方法、形式化方法。</li></ul><p><img src="https://gitee.com/sehowyoung/images/raw/master/202111121713375.png" alt="image-20211112171335317" style="zoom:150%;"></p><p>开发方法的结合研究：</p><ul><li>利用各种方法的长处，从而实现优势互补</li><li>在<strong>需求分析和规格说明阶段</strong>采用结构化方法，在<strong>设计和实现阶段</strong>采用面向对象方法，在软件开发全过程中一些<strong>对软件质量有重要影响的部分</strong>采用形式化方法。 </li></ul><h2 id="1-4-软件工程工具和环境"><a href="#1-4-软件工程工具和环境" class="headerlink" title="1.4 软件工程工具和环境"></a>1.4 软件工程工具和环境</h2><h3 id="1-4-1-软件工程工具"><a href="#1-4-1-软件工程工具" class="headerlink" title="1.4.1 软件工程工具"></a>1.4.1 软件工程工具</h3><ul><li>软件工具：为支持计算机软件的开发、维护及有关工作而研制的程序系统。 </li><li>使用软件工具的<strong>目的</strong>：降低软件开发和维护的成本，提高软件产品的生产效率和质量。</li><li>软件开发工具：用于软件开发过程的各种开发活动<ul><li>分析、设计工具：Visio、Rational Rose</li><li>编码工具：Eclipse</li><li>软件维护工具：辅助维护人员对代码及其有关文档进行各种维护活动</li><li>再工程工具—-软件重构工具</li><li>软件管理和支持工具：辅助软件项目管理人员和支持人员的各种管理和支持活动 </li></ul></li><li>特点：一般情况下一种软件工具只支持一种活动。</li><li>不足：工具界面不统一，工具内部无联系，工具切换由人工操作。</li></ul><h3 id="1-4-2-集成型软件开发环境"><a href="#1-4-2-集成型软件开发环境" class="headerlink" title="1.4.2 集成型软件开发环境"></a>1.4.2 集成型软件开发环境</h3><ul><li>由软件工具集和环境集成机制构成</li><li>软件工具集用以支持软件开发的相关过程、活动和任务（支持某种开发方法）</li><li>环境集成机制为工具集成和软件开发、维护和管理提供统一的支持</li></ul><h2 id="1-5-软件生存期过程"><a href="#1-5-软件生存期过程" class="headerlink" title="1.5 软件生存期过程"></a>1.5 软件生存期过程</h2><ul><li>软件生存期过程规定了获取、供应、开发、操作和维护软件时，要实施的<strong>过程、活动和任务</strong>。其目的是为各种人员提供一个公共的框架，以便可以使用“<strong>相同的语言</strong>”在自己的环境中创作和管理软件。 </li><li>软件生存期过程没有规定一个特定的生存周期模型，各软件开发机构可视其项目的需要选择一种软件生存周期模型，并将软件生存期过程所含过程、活动和任务映射到选定的软件生存周期模型中。</li></ul><h2 id="1-6-常用软甲生存期模型"><a href="#1-6-常用软甲生存期模型" class="headerlink" title="1.6 常用软甲生存期模型"></a>1.6 常用软甲生存期模型</h2><ul><li>软件生存期模型描述了软件项目从需求定义开始，到开发成功后投入使用，在使用的过程中不断增补修订，直到最后停止使用这一期间所进行的各种活动如何执行的模型。</li></ul><p><img src="https://gitee.com/sehowyoung/images/raw/master/202111121727874.png" alt="瀑布模型" style="zoom:50%;"></p><ul><li>采用原型模型开发系统，用户和开发者必须达成一致：原型被建造仅仅是用来定义需求，之后便部分或全部抛弃，最终的软件要在充分考虑了质量和可维护性等方面之后才被开发。 </li></ul><p><img src="https://gitee.com/sehowyoung/images/raw/master/202111121743302.png" alt="原型模式" style="zoom:50%;"></p><p><img src="https://gitee.com/sehowyoung/images/raw/master/202111121744302.png" alt="RAD模型" style="zoom:50%;"></p><p><strong>一次性地将整个系统交给用户</strong>：<br>瀑布模型是假设当线性阶段完成之后就能交付一个完善的系统。原型模型主要用来帮助开发者获取用户需求，待需求稳定后再开发最终系统提供给用户。RAD模型则先将系统主要功能分给若干RAD小组开发，然后集成起来形成最终系统提交给用户。</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/202111121751134.png" alt="增量模型" style="zoom:50%;"></p><p><img src="https://gitee.com/sehowyoung/images/raw/master/202111121753869.png" alt="螺旋模型" style="zoom: 67%;"></p><p><img src="https://gitee.com/sehowyoung/images/raw/master/202111121756942.png" alt="RUP模型" style="zoom:50%;"></p><p><img src="https://gitee.com/sehowyoung/images/raw/master/202111121806565.png" alt="image-20211112180600496" style="zoom:150%;"></p><p>其他模型：</p><ul><li>极限编程模型（强调对变化的适应）</li><li>构件组装模型(基于构件组装)</li><li>簇模型（强调并行开发）</li><li>喷泉模型（适合面向对象软件开发）</li><li>智能模型（将瀑布模型与专家系统结合）</li></ul><h2 id="1-7-软件文档"><a href="#1-7-软件文档" class="headerlink" title="1.7 软件文档"></a>1.7 软件文档</h2><ul><li>软件文档为提高软件工程项目的开发和管理能力提供了重要的基础。 </li><li>在软件生存周期中，软件文档种类多、编制工作量大、技术性强。 </li><li>一方面要对软件文档的地位和作用应有充分的认识，另一方面要提高文档的质量。</li><li>文档是指某种数据媒体和其中所记录的数据。 </li><li>作用：<ul><li>提高了软件开发过程的可视性；</li><li>有利于及时纠正错误，减少返工，提高软件开发效率；</li><li>为开发人员、管理人员以及用户等之间的协作和交流提供了基础。 </li></ul></li><li>要求：及时性；完整性 ；实用性；规范性。</li><li>分类：按照文档产生和使用的范围不同，软件文档可以分成三类，即：技术文档、管理文档和用户文档。其中，技术文档和管理文档又统称为系统文档。<ul><li>技术文档是指在软件开发过程中作为开发人员前一阶段工作成果和后一阶段工作依据的文档。 </li><li>管理文档是指在软件开发过程中由开发人员等制定并提交给管理人员的工作计划或报告，使管理人员能够通过这些文档了解软件项目的安排、进度、资源使用及成果等。 </li><li>用户文档是软件开发人员为用户准备的有关该软件使用、操作、维护的资料</li></ul></li><li>编写步骤：<ul><li>准备工作；</li><li>确定写作内容；</li><li>编写定稿；</li><li>更新完善</li></ul></li></ul><h2 id="1-8-敏捷软件开发"><a href="#1-8-敏捷软件开发" class="headerlink" title="1.8 敏捷软件开发"></a>1.8 敏捷软件开发</h2><ul><li>敏捷开发的四个价值：<ul><li>个体和交互胜过过程和工具</li><li>可工作的软件胜过难以理解的文档</li><li>客户协作重于合同谈判</li><li>响应变化胜过遵循计划</li></ul></li><li>敏捷过程：<ul><li>对变化进行快速地响应</li><li>有效地进行交流</li><li>将客户拉入团队</li><li>组建团队，控制完成所需要的工作</li></ul></li><li>特点：<ul><li>需求驱动</li><li>短期计划</li><li>迭代开发</li><li>提供多个软件增量</li><li>随着变化调整</li></ul></li><li>敏捷原则<ul><li>最优先要做的是通过<strong>尽早地、持续地交付有价值的软件</strong>来使客户满意。</li><li>即使在开发后期，也<strong>欢迎需求改变</strong>。敏捷过程利用变化来为客户创造竞争优势。</li><li>经常性地<strong>交付可以工作的软件</strong>，交付的间隔可以从几个星期到几个月，交付的时间间隔越短越好。 </li><li>在整个项目开发期间，<strong>业务人员和开发人员必须天天在一起工作</strong>。 </li><li><strong>围绕有积极性的个人构建项目团队</strong>。为他们提供所需的环境和支持，并信任他们能够完成工作。 </li><li>在团队内部，最有效果并富有效率的信息传递方法是<strong>面对面的交流</strong>。 </li><li>可运行的软件是首要的<strong>进度度量标准</strong>。 </li><li>敏捷过程<strong>提倡可持续的开发速度</strong>。责任人、开发者和用户应该能够保持一个长期的、稳定的开发速度。 </li><li>持续<strong>关注优秀的技能和好的设计</strong>，增强敏捷能力。 </li><li><strong>简单</strong>（是不必做的工作最大化的艺术）是必要的。 </li><li>最好的架构、需求和设计出自于<strong>自组织的团队</strong>。 </li><li>每隔一段时间，<strong>团队应反省</strong>如何才能有效地工作，并相应地调整自身的行为。</li></ul></li></ul><p><img src="https://gitee.com/sehowyoung/images/raw/master/202111172313411.png" alt="image-20211117231301108" style="zoom: 67%;"></p><h1 id="第二章-可行性研究与项目计划"><a href="#第二章-可行性研究与项目计划" class="headerlink" title="第二章 可行性研究与项目计划"></a>第二章 可行性研究与项目计划</h1><ul><li>软件工程项目可行性研究<strong>实质</strong>是一次大大压缩和简化了的分析和设计过程，主要在<strong>较高层次</strong>上以较抽象的方式进行，其<strong>目的</strong>是在尽可能短的时间内以最小的代价确定该项目<strong>是否能够开发，是否值得开发</strong>。 </li><li>内容：<ul><li>技术可行性（相关技术、风险、资源）</li><li>经济可行性（成本、效益）</li><li>操作可行性（政治、法律、社会道德等）</li></ul></li><li>步骤：<ul><li>系统目标和范围的定义：要解决的根本问题、达到目标所需的资源和经费；</li><li>对现行系统进行分析研究：现有系统的物理模型和逻辑模型；（入口：现有系统的组织结构）</li><li>导出新系统的逻辑模型；（解决了有关问题）</li><li>设计新系统的物理方案；（最先进的方案、实用、基本方案）</li><li>推荐可行的方案 ；（包括推荐理由）</li><li>编写可行性研究报告。（结论：继续、延期和拒绝）</li></ul></li></ul><h2 id="2-1-系统分析"><a href="#2-1-系统分析" class="headerlink" title="2.1 系统分析"></a>2.1 系统分析</h2><ul><li><p>系统分析是可行性研究阶段对现有系统的功能、数据及约束条件的初步研究，了解现有系统能做什么。 </p></li><li><p>系统分析往往先从系统的<strong>组织结构</strong>入手，进而<strong>分析组织</strong>的业务功能及业务流程，最后用数据流图明确<strong>信息如何在组织中流动</strong>完成指定的业务功能。</p></li><li><p>系统的组织结构反映了组织内部的组成以及它们之间的关系。</p></li><li><p>内容：</p><ul><li><p>组织结构图：</p><p>在组织结构图中，每个方框表示一个业务域，通过层次分解精化，直至小的工作组或某个个体。</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/202111172353120.png" alt="image-20211117235306075" style="zoom:50%;"></p></li><li><p>业务联系图</p><p>业务联系图反映组织各部分与各项业务之间的联系。</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/202111222231821.png" alt="image-20211122223156489"></p></li><li><p>业务功能树</p><p>用于描述组织内部各部分的业务和功能</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/202111222233581.jpg" alt=""></p></li></ul></li><li><p>系统流程图是描绘物理系统的传统工具，可以采用系统流程图来描述项目的大概业务处理流程，其基本思想是用图形符号以黑盒子形式描绘系统各部件（如程序、数据库、文档、人工过程等）。</p></li><li><p>系统流程图表达的是信息在系统中各部件之间流动的情况，而不是对信息进行加工处理的控制过程。 </p></li><li><p>数据流图描述的是系统的逻辑模型，图中没有具体的物理元素，只是描绘信息在系统中的流动和处理情况。（数据流图是逻辑系统的图形表示）</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/202111172355696.png" alt="image-20211117235543662"></p></li><li><p>在可行性研究阶段，采用数据流图来描述数据在系统中的流动和处理情况时，不必详细描述，只须概括地描述高层的数据处理和流动。</p></li></ul><h2 id="2-2-成本估计"><a href="#2-2-成本估计" class="headerlink" title="2.2 成本估计"></a>2.2 成本估计</h2><ul><li><p>三种方法：</p><ul><li>自顶向下（基于已完成的类似项目进行估算）</li><li>自底向上（使用简单的“分解技术”来进行成本以及工作量的估算）</li><li>使用经验模型进行成本及工作量的估算</li></ul></li><li><p>自顶向下成本估计</p><ul><li><p>通常仅由少数上层技术与管理人员参加。</p></li><li><p>方式：依据先前已完成项目所耗费的总成本（总工作量），推算新开发软件的总成本（总工作量），然后在项目内部进行成本分配。 </p></li><li><p>优点:工作量小，速度快。</p></li><li><p>缺点:对开发中某些局部问题或特殊困难易低估，甚至没有考虑。如果所开发的软件缺乏可借鉴的经验，则估计偏差可能较大。</p></li></ul></li><li><p>自底向上成本估计</p><ul><li>估计者必须先了解待开发软件的范围。软件范围包括功能、性能、限制、接口和可靠性等。</li><li>方式：在估算开始之前，应对软件范围进行适当的<strong>细化</strong>，以提供较详细的细节。对于细化得到的任务单元可交给该任务的开发人员去<strong>估计</strong>，得到各任务单元的估计成本。然后，将各任务单元的成本<strong>汇合</strong>成项目的总成本。</li><li>对涉及全局的花费（如质量管理）可能估计不足甚至完全忽视，使成本估计可能偏低。</li></ul></li><li><p>基于经验模型的成本估计</p><ul><li><p>利用已完成项目的样本数据进行分析，从而建立有关经验公式来预测项目所需的成本、工作量等，具有比较客观（与前面的估算方法相比）、计算结果可重复（即无论何时使用模型，其结果相同）等优点。</p></li><li><p>由于经验数据是从一些有限的项目中得到的，而且软件类型和开发环境各不相同，因而模型中得到的结果必须慎重使用。 </p></li><li><p>主要经验模型：</p><ul><li><p>静态单变量模型</p><p>典型结构为：$E=A+B\times(估计变量)^C$，其中，A、B和C是由经验导出的常数；E是以人月（PM）为单位的工作量；“估计变量”是被估软件特征的估计量，如代码行数等。</p></li><li><p>动态多变量模型：</p><p>模型把项目的资源需求看成是时间的函数。</p><p>例如：$L=C<em>{k}<em>K^{4/3}</em>t</em>{d}^{4/3}$，其中，L表示源代码行数（以LOC计算）；K表示软件全生存周期（含维护在内）所需工作量（以人年计）；$t_{d}$表示项目开发持续时间（以年计）；$C_k$表示技术状态常数。</p><p><strong>这表明，如果缩短开发时间，将意味着增加项目的开发工作量</strong></p></li><li><p>COCOMO模型 </p><p>Boehm将软件成本估算分成3个由粗到细的层次：基本层、中间层和详细层。每个层次又按软件项目的应用领域和复杂程序分成3种类型：组织型、半独立型和嵌入层。 </p><p>模型形式：$ TDEV=C<em>(MM)^d , MM=a</em>(KDSI)^b*\sum\limits_{i = 1}^{15} {f_i} $ ，其中，其中MM表示开发工作量，以人月计；KDSI表示源指令条数，以千行计算；TDEV表示开发时间，以月计算；$f_i$(i=1～15)表示15项项目影响调节因子；a,c表示模型系数；b,d表示模型指数。 </p><ul><li><p>基本层COCOMO模型</p><p>不考虑成本影响调节因子，是对软件成本的一种宏观粗略估计，是一个静态单变量模型</p><ul><li>组织型——较小、较简单的软件项目</li><li>半独立型——软件的需求介于“组织型”和“嵌入型”之间。</li><li>嵌入型——必须在一组严格的硬件、软件及操作约束下开发的软件项目，对接口、数据结构、算法要求较高。 </li></ul></li><li><p>中间层COCOMO模型</p><p>主要考虑了从整个生存期来衡量成本影响调节因子，共15项，分成4类：产品、硬件、人员及项目。</p></li><li><p>详细层COCOMO模型</p><p>详细层COCOMO模型需要考虑各调节因子对于不同开发阶段的影响。 </p><p>针对每一个影响因素，按模块级、子系统级和系统级，有三张工作量因素分级表，供不同级别的估算使用。 </p><p>详细层COCOMO模型的模型形式与中间层COCOMO模型相同，只是fi的取值在详细层COCOMO模型中应分级和分阶段给定。</p></li></ul><p>改进：COCOMOII模型可以处理较广泛的软件工程技术，例如，面向对象、包含瀑布模型及其它生存期模型、复用、第四代语言等等。 </p><p>Boehm关于自己提出的COCOMO模型的评价意见是：一个软件估算模型能够在成本估算上相差不到20%，时间估算上相差不到70%，就相当不错了。 </p></li><li><p>运用：</p><p>使用时应根据实际环境进行调整以适合自己的应用项目。同时对于估算结果的精度也不应期望过高。</p><p>当开发产品时，实际的开发工作量应与预测值进行比较。出现偏差可作为一个有问题的早期警告。管理者应该分析出现问题的原因，如开发小组不胜任，产品规模低估了等，并采取合适的行动使影响最小化。</p></li></ul></li></ul></li></ul><h2 id="2-3-效益分析"><a href="#2-3-效益分析" class="headerlink" title="2.3 效益分析"></a>2.3 效益分析</h2><ul><li><p>系统的效益有两部分：经济效益和社会效益。</p></li><li><p>经济效益是指用使用新系统而增加的收入，包括使用新系统节省的运行费用，是一种有形的效益。</p></li><li><p>社会效益是一种无形的效益，主要从性质上、心理上进行衡量，很难直接量化，但在某些情况下，无效的效益能转化成有形的效益。</p></li><li><p>度量指标：</p><ul><li><p>货币的时间价值：常用利率的形式表示</p></li><li><p>纯收入：其值等于整个生存周期内系统的累积经济效益（折算成当前值）与投资之差。</p></li><li><p>投资回收期：其值等于使累计的经济效益（折算成当前值）等于最初投资所需要的时间。</p><p>投资回收期越短，就能越快地获得经济效益，因而这项工程也就越值得投资。</p></li><li><p>投资回收率：用来衡量投资效益的大小，并可以和银行年利率进行比较</p><p>计算公式：$P=F_1/(1+j)+F_2/(1+j)^2+…+F_n/(1+j)^n$</p><p>其中，P表示当前的投资额，$F_i$表示第i年年底的效益（i=1,2, …,n），n表示系统的使用寿命，j表示投资回收率。</p></li></ul></li><li><p>系统的效益分析随系统的特征而异。 </p><p>根据总投资的情况和年度效益分析的结果，可以进一步计算纯收入、投资回收期和投资回收率等。</p><p>管理者根据有关分析结果，结合其它潜在的对投资的使用，考虑有关社会效益，可以在经济上确定系统是否值得投资开发。</p></li></ul><h2 id="2-4-风险分析"><a href="#2-4-风险分析" class="headerlink" title="2.4 风险分析"></a>2.4 风险分析</h2><blockquote><p>如果你不主动攻击风险，风险就会主动攻击你。</p><p>主动的、明智的风险管理策略应该在技术工作开始之前，先<strong>标识</strong>出潜在的风险，<strong>评估</strong>它们出现的概率及产生的影响，并按重要性加以排序，然后项目组织再制订一个计划来<strong>管理</strong>风险。</p></blockquote><p>风险分析活动：风险标识、风险估计、风险评价和风险管理与监控。</p><h3 id="2-4-1-风险标识"><a href="#2-4-1-风险标识" class="headerlink" title="2.4.1 风险标识"></a>2.4.1 风险标识</h3><ul><li><p>类型：</p><ul><li><p>宏观角度：项目风险、技术风险和商业风险</p></li><li><p>Charette：已知风险、可预测风险和不可预测风险</p></li></ul></li><li><p>方法：</p><ul><li>产品规模：与待开发或修改的软件的总体规模相关的风险。 </li><li>商业影响：与管理或市场所加约束相关的风险。 </li><li>客户特性：与客户的素质以及开发者和客户定期通信的能力相关的风险。 </li><li>过程定义：与软件过程被定义的程度以及它们被开发组织所遵守的程度相关的风险。 </li><li>开发环境：与用以建造产品的工具的可用性及质量相关的风险。 </li><li>建造技术：与待开发软件的复杂性及系统所包含技术的“新奇性”相关的风险。</li><li>人员数量及经验：与参与工作的软件技术人员的总体水平及项目经验相关的风险。 </li></ul></li></ul><h3 id="2-4-2-风险估计"><a href="#2-4-2-风险估计" class="headerlink" title="2.4.2 风险估计"></a>2.4.2 风险估计</h3><ul><li>风险发生的可能性。风险可能性尺度可以用布尔值、定量或定性的方式表示。</li><li>可能带来的损失：灾难的、严重的、轻微的和可忽略的。</li></ul><h3 id="2-4-3-风险评价"><a href="#2-4-3-风险评价" class="headerlink" title="2.4.3 风险评价"></a>2.4.3 风险评价</h3><ul><li>根据风险估计的结果，建立一系列三元组：[r~i~, p~i~, e~i~]，其中r~i~表示风险，p~i~表示风险出现的概率，e~i~表示风险产生的影响 ；</li><li>定义项目的各种风险参考水准，如成本、进度等； </li><li>找出每个[r~i~, p~i~, e~i~]与各参考水准之间的关系； </li><li>预测一组临界点以定义项目的终止区，该区由一条曲线或易变动区域来界定； </li><li>预测怎样的风险组合，会影响参考水准。 </li><li><img src="https://gitee.com/sehowyoung/images/raw/master/202111221637672.png" alt="image-20211122163714608" style="zoom:50%;"></li></ul><h3 id="2-4-4-风险管理与监控"><a href="#2-4-4-风险管理与监控" class="headerlink" title="2.4.4 风险管理与监控"></a>2.4.4 风险管理与监控</h3><ul><li><p>风险管理</p><ul><li><p>风险管理是指利用某些技术，如原型化、软件自动化、可靠性工程学，以及某些项目管理方法等设法避免或转移风险。 </p></li><li><p>实施==风险管理策略==会带来一些额外的开销。<u>仅当实施风险管理策略所需的成本小于风险管理带来的效益</u>（即风险带来的影响）时才可考虑实施风险管理策略。</p></li><li><p>高影响且发生概率为中到高的风险以及低影响且高发生概率的风险，应该首先列入管理的考虑之中。 </p></li><li><p>按照Pareto的80-20规则，80%的软件风险能够由仅仅20%的已标出风险来说明。 </p></li></ul></li><li><p>风险监控的三个目标：</p><ul><li>事件和主要风险因素的跟踪，判断一个预测的风险事实上是否发生了； </li><li>风险估计，确保针对某个风险制定的风险管理措施正在实施； </li><li>收集可用于将来风险分析的信息。 </li></ul></li></ul><h2 id="2-5-进度安排"><a href="#2-5-进度安排" class="headerlink" title="2.5 进度安排"></a>2.5 进度安排</h2><ul><li><p>方式：</p><ul><li>系统最终交付日期已经确定，软件开发组织在这一约束下将工作量进行分配；</li><li>系统最终交付日期只确定了大致的期限，最终发布日期由软件开发组织确定，工作量以一种能够最好地利用资源的方式进行分配。</li></ul><p><strong>在实际工作中，第一种方式发生的频率远高于第二种方式。</strong></p></li><li><p>基本原则：</p><ul><li>任务分解：将软件工程项目的任务分解成易管理的子任务,即作业;</li><li>作业依存：确保作业间的依存关系——顺序和并发；</li><li>时间分配：为每个作业指定开始和终止时间； </li><li>资源约束：在进行时间分配时应考虑资源约束，如人员数量、工具； </li><li>定义责任：应指定某特定小组负责某个作业； </li><li>定义结果：对每个作业定义相应的结果——产品或产品的一部分； </li><li>定义里程碑：每个作业或作业系列应与项目的里程碑相联系。</li></ul></li><li><p>工作量分配：</p><p>40-20-40规则：在整个软件开发过程中，编码的工作量约占20%，编码前的工作量占40%，编码后的工作量也占40%</p></li><li><p>进度安排方法：</p><ul><li>原则上可以把一般工程项目的进度安排方法和工具应用于软件工程项目。 </li><li>首先识别一组项目任务作业，建立任务作业之间的相互关联，然后估算各个任务的工作量，分配人力和其它资源，指定进度时序。</li><li>方法：PERT技术和Gantt图方法</li></ul></li><li><p>PERT技术</p><ul><li>PERT技术（Program Evaluation &amp; Review Technique，PERT） 又叫计划评审技术、工程网络技术</li><li><img src="https://gitee.com/sehowyoung/images/raw/master/202111221645045.png" alt="PERT图" style="zoom:67%;"></li><li>计算事件的最早发生时间（EET）<ul><li>通常规定，起始事件的最早发生时刻为0；</li><li>考虑进入该事件的所有作业；</li><li>对于每个作业均计算其起始事件的最早发生时刻EET与持续时间之和；</li><li>选取上述和数中的最大值作为该事件的最早发生时刻EET。 </li></ul></li><li>计算事件的最晚发生时间（LET）<ul><li>通常规定，工程最后一个事件的最迟发生时刻等于最早发生时刻；</li><li>考虑离开该事件的所有作业；</li><li>对于每个作业都计算其结束事件的最迟发生时刻LET与作业持续时间之差；</li><li>选取上述差数中的最小值作为该事件的最迟发生时该LET。</li></ul></li><li><img src="https://gitee.com/sehowyoung/images/raw/master/202111221648265.png" alt="示例"></li><li>利用机动时间安排进度<ul><li>机动时间=LET-EET-作业持续时间</li><li><strong>先安排关键作业，再利用机动时间安排非关键作业。</strong></li><li><img src="https://gitee.com/sehowyoung/images/raw/master/202111221650072.png" alt="image-20211122165008026" style="zoom:67%;"></li></ul></li></ul></li></ul><h2 id="2-6-项目组织与计划"><a href="#2-6-项目组织与计划" class="headerlink" title="2.6 项目组织与计划"></a>2.6 项目组织与计划</h2><ul><li><p>人尽其才</p></li><li><p>人员组织规律</p><ul><li><img src="https://gitee.com/sehowyoung/images/raw/master/202111221651552.png" alt="Rayleigh-Norden曲线"></li><li>如果在软件生存周期平均使用人力，则会造成：起始阶段人力过剩（图中①）、开发后期和维护前期人力不足（图中②）和维护时期人力补偿为时已晚（图中③）</li></ul></li><li><p>各类人员参与程度曲线</p><ul><li><img src="https://gitee.com/sehowyoung/images/raw/master/202111221652290.png" alt="各类人员参与程度曲线"></li><li>初级技术人员在编码时参与最多，而在其它阶段参与则较少；高级技术人员在软件开始的开始阶段和结束阶段参与较多，在中间阶段参与较少；管理人员在项目开始阶段参与较多，其它则参与较少。</li></ul></li><li><p>两大定律：</p><ul><li>人员——时间权衡定律<ul><li>软件开发工作量与软件开发时间的4次方成反比。</li><li>如果适当延长软件开发时间，则可减少软件开发的工作量；反之，如果缩短软件开发时间，则工作量会大幅度增加</li></ul></li><li>Brooks定律<ul><li>向一个已经延期的软件项目追加开发人员，可能会使它完成得更晚。</li><li>当开发人员以算术级数增长时，人员之间的通信将以几何级数增长。</li></ul></li></ul><p>由这两条定律，可以得出：<strong>对于软件项目，开发时间宁可长一些，开发人员可少而精一些。</strong></p></li><li><p>人员组织形式</p><ul><li>软件开发机构选择怎样的人员组织形式，要针对<strong>软件项目的特点和参与人员的素质</strong>来决定。</li><li>在建立软件开发组织时，应注意：<ol><li>责任到人——尽早将责任落实，便于管理；</li><li>合理分工——减少不必要的通信，提高工作效率；</li><li>责权均衡——责任与权力的平衡，有助于任务的完成。</li></ol></li><li>层次模式<ul><li><img src="https://gitee.com/sehowyoung/images/raw/master/202111221707726.png" alt="层次模式"></li><li>软件经理负责整个开发部门的管理工作，在各项目之间分配和协调各种资源。</li><li>目经理负责一个具体项目开发的各个方面。</li><li>每个小组负责项目的一部分工作。 </li><li>审查小组与项目经理同属一个层次，主要从事质量保证活动，在项目开发的里程碑进行技术审查和管理复审。  </li></ul></li><li>矩阵模式<ul><li><img src="https://gitee.com/sehowyoung/images/raw/master/202111221708535.png" alt="矩阵模式"></li><li>项目经理注重于问题域知识，阶段经理则熟悉阶段的开发知识。 </li></ul></li></ul><p>对于层次模式中的小组和矩阵模式中的子项的组织，主要有三种组织形式</p><ul><li>主程序员小组<ul><li><img src="https://gitee.com/sehowyoung/images/raw/master/202111221711579.png" alt="主程序员小组"></li><li>主程序员负责制订计划、协调与审查工作，并完成结构设计及代码中关键和复杂部分的实现。</li><li>技术人员负责项目的具体分析与开发以及文档资料的编写工作。 </li><li>后备程序员主要协助主程序员的工作，必要时可替代主程序的工作。</li></ul></li><li>民主小组<ul><li><img src="https://gitee.com/sehowyoung/images/raw/master/202111221712683.png" alt="民主小组" style="zoom:33%;"></li><li>民主小组的最基本概念是“无我程序设计”（egoless programming） </li><li>日本许多公司使用权用民主小组的组织形式进行软件开发 </li></ul></li><li>层次小组<ul><li><img src="https://gitee.com/sehowyoung/images/raw/master/202111221712292.png" alt="层次小组"></li><li>层次间按隶属关系进行通信，组内平等通信。</li><li>这种组织方式适合于<strong>大型软件开发项目</strong>，尤其是项目本身就是层次结构状的课题。 </li></ul></li></ul></li></ul><h1 id="第三章-需求分析"><a href="#第三章-需求分析" class="headerlink" title="第三章 需求分析"></a>第三章 需求分析</h1><blockquote><p>需求分析是指开发人员通过细致的调查分析，详细、准确和完整地理解用户需要什么样的软件，将用户非形式的需求陈述转化为完整的需求定义，再将需求定义转换到相应的需求规格说明的过程。<br>通常，把一整套的需求分析方法、技术和工具等的集合称为建模方法。</p></blockquote><h2 id="3-1-需求分析的目标"><a href="#3-1-需求分析的目标" class="headerlink" title="3.1 需求分析的目标"></a>3.1 需求分析的目标</h2><ul><li>AO:决定是否建立一个系统</li><li>A1:理解最终的软件系统应该解决哪些问题。</li><li>A2:引出这些问题和系统的一些相关问题。</li><li>A3:提供一个与这些问题和系统特征有关的回答问题的基础。</li><li>A4:决定系统应该做什么。</li><li>A5:决定系统不应该做什么</li><li>A6:确认系统将能够满足用户的需要，并且定义相应的验收标准。</li><li>A7:为系统开发提供一个基础。</li></ul><p>需求分析的这些目标可由三个子阶段完成：</p><ul><li>可行性分析主要是完成AO目标，即要决定是否建立一个系统；</li><li>需求收集主要完成目标A1~A6；</li><li>目标A7则由需求规格说明完成。</li></ul><h2 id="3-2-需求收集"><a href="#3-2-需求收集" class="headerlink" title="3.2 需求收集"></a>3.2 需求收集</h2><ul><li><p>收集的内容</p><ul><li>信息需求（数据需求）</li><li>功能需求</li><li>性能需求</li><li>运行需求</li><li>未来需求</li></ul><p>除此之外，还有用户界面需求、资源使用需求(如人、财、物)等其他专门需求。</p></li><li><p>方法：</p><ul><li>访谈</li><li>问卷调查</li><li>场景使用</li><li>用户资料收集</li><li>建立快速原型</li></ul></li></ul><h2 id="3-3-需求规格说明"><a href="#3-3-需求规格说明" class="headerlink" title="3.3 需求规格说明"></a>3.3 需求规格说明</h2><blockquote><p>一旦系统分析员确信收集到了用户的需求之后，接着就应该把它们整理成规范化的形式，即进行系统的需求规格说明。一方面，因为需求规格说明是系统分析员在用户的参与下做出的双方对系统必须要做什么的一致的理解。因此，需求规格说明应该清楚明了，只有这样，用户才能看得懂，才有可能接受。另一方面，需求规格说明将是设计组进行设计的依据，这就要求需求规格说明必須做到完整、详尽。</p></blockquote><p>需求规格说明必须做到：</p><ul><li>技术性描述不要太强，用户才容易阅读；</li><li>要足够准确，设计人员据此设计的产品才可能满足最终用户的要求。</li></ul><p>多种需求规格说明的方法和技术：</p><ul><li>非形式化的需求规格说明使用自然语言进行描述；</li><li>半形式化的需求规格说明使用图形并辅以自然语言进行描述；</li><li>形式化的需求规格说明采用比半形式化的方式更为严格的形式，如VDM系统、乙系统和 RAISE系统等采用严格的数学描述形式。</li></ul><h2 id="3-4-数据流建模"><a href="#3-4-数据流建模" class="headerlink" title="3.4 数据流建模"></a>3.4 数据流建模</h2><ul><li>数据流建模方法是一种<strong>结构化分析方法</strong>；</li><li><strong>自顶向下、逐层分解</strong>地定义系统需求；</li><li>特点是<strong>利用数据流图来对用户需求进行分析</strong>；</li><li>可用于分析<strong>任何</strong>应用系统的需求</li></ul><h3 id="3-4-1-数据流图"><a href="#3-4-1-数据流图" class="headerlink" title="3.4.1 数据流图"></a>3.4.1 数据流图</h3><ul><li><p>据流(用箭头表示）；</p></li><li><p>加工（加工一般用一个圆圈或圆角方框来表示 ）；</p></li><li><p>数据存储(一般用开口的矩形框或双划线来表示)； </p></li><li><p>数据的源点和终点（一般用正方形或立方体来表示 ）；</p></li><li><p>扩展符号主要有：*、+和⊕ 。</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/202111221852410.png" alt="例3-1"></p></li><li><p>分层数据流图</p><ul><li>分层数据流图可以避免一次引入过多的细节，有利于控制问题的复杂度，从而便于对大型系统描述的实现。 </li><li>不同的用户可以只选择分层数据流图中与本身有关或感兴趣的部分，不必阅读全图，从而便于用户的使用和理解。</li><li>顶层数据流图<ul><li>主要描述整个系统的作用范围，说明系统的边界，反映系统和外部环境之间的关系，即系统的输入和输出数据流。</li><li><strong>只有一张</strong></li><li><img src="https://gitee.com/sehowyoung/images/raw/master/202111221854830.png" alt="例3-2"></li></ul></li><li>底层数据流图<ul><li>有一些不必再进行分解的加工组成（基本加工）</li><li><img src="https://gitee.com/sehowyoung/images/raw/master/202111221856088.png" alt="图3-3"></li></ul></li><li>中间层数据流图<ul><li>通过分解高层加工得到的</li><li><img src="https://gitee.com/sehowyoung/images/raw/master/202111221856550.png" alt="图3-4"></li></ul></li></ul></li></ul><h3 id="3-4-2-数据词典"><a href="#3-4-2-数据词典" class="headerlink" title="3.4.2 数据词典"></a>3.4.2 数据词典</h3><blockquote><p>数据词典（Data Dictionary，DD），又称数据字典，是关于数据信息的集合，是对数据流图中的每个数据，包括数据流和数据存储，进行严格定义的场所，以保持数据在系统中的一致性。</p></blockquote><p>组成描述符：</p><div class="table-container"><table><thead><tr><th>符号</th><th>涵义</th></tr></thead><tbody><tr><td>=</td><td>表示等价于（或定义为）</td></tr><tr><td>+</td><td>表示连接两个数据元素，即“与”的关系</td></tr><tr><td>[ \</td><td>]</td><td>表示从方括号内列出的若干个数据元素中选择一个</td></tr><tr><td>{}</td><td>表示重复花括号内的数据元素若干次($1{E}10$或$_1^{10}{E}$)</td></tr><tr><td>()</td><td>表示愿口号内的元素是可有可无的</td></tr><tr><td>m..n</td><td>表示界域，从m到n</td></tr><tr><td>*..*</td><td>表示两个星号间的内容为对跳内的注释</td></tr></tbody></table></div><h3 id="3-4-3-加工说明"><a href="#3-4-3-加工说明" class="headerlink" title="3.4.3 加工说明"></a>3.4.3 加工说明</h3><ul><li><p>数据流图中的“基本加工”由于没有进一步分解得到子图，因而需要加工说明来对其进行描述。</p></li><li><p>描述基本加工如何把输入数据流变换成输出数据流的加工规则；描述实现加工的策略而不是实现加工的细节。</p></li><li><p>IPO图、结构化语言、判定表、判定树等均可作为加工说明的工具。 </p></li><li><p>IPO（Input/Process/Output）图</p><ul><li><img src="https://gitee.com/sehowyoung/images/raw/master/202111221859761.png" alt="IPO图"></li><li>IPO图除可用于分析阶段描述加工逻辑说明外，也常与层次图（Hierachy Chart, HC）一起用于设计阶段，形成HIPO图。 </li></ul></li><li><p>结构化语言</p><ul><li>结构化语言，又称PDL（Program Design Language, PDL）或伪代码（Pseudo Code），是一种介于自然语言和形式语言之间的一种半形式语言。</li></ul></li><li><p>判定表/判定树</p><ul><li>适合：完成加工的一组动作是由于某一组条件取值的组合而引发的动作</li><li><img src="https://gitee.com/sehowyoung/images/raw/master/202111221928990.png" alt="判定表"></li><li>判定树是判定表的图形表示，有时比判定表更直观。 </li><li><img src="https://gitee.com/sehowyoung/images/raw/master/202111221929874.png" alt="判定树"></li></ul></li></ul><h3 id="3-4-4-数据流建模步骤"><a href="#3-4-4-数据流建模步骤" class="headerlink" title="3.4.4 数据流建模步骤"></a>3.4.4 数据流建模步骤</h3><p>原则上是由外向里、自顶向下</p><ul><li>画顶层数据流图</li><li>画分层数据流图</li><li>用数据词典定义数据流图中的所有数据</li><li>用加工说明描述数据流图中的基本加工</li></ul><h2 id="3-5-实体一关系建模"><a href="#3-5-实体一关系建模" class="headerlink" title="3.5 实体一关系建模"></a>3.5 实体一关系建模</h2><ul><li><p>实体关系图由三个相互关联的部分构成：<strong>实体</strong>（即数据对象）、实体之间的<strong>关系</strong>以及实体和关系的<strong>属性</strong>。</p><ul><li>实体：对必须由软件理解的任何复合信息的表示。在E-R图中，实体用矩形框表示</li><li>属性：定义了一个实体的特征并呈现三种不容的性质之一：<ul><li>命名一个实例</li><li>描述一个实例</li><li>引用另一个表的实例</li></ul></li><li>关系</li></ul></li><li><p>基数</p><ul><li>定义：表示一个给定的关系中的实体数据</li><li>两个对象可能的关系：一对一、一对多、多对多</li></ul></li><li><p>模态</p><ul><li>如果一个实体的某一个实例对一个关系没有明显的要求或者关系是可选的，则这一关系的模态值为0</li><li>如果一个实体的任一个实例对一个关系有明确的强制性的要求，则这一关系的模态值为1。</li></ul><p><img src="https://gitee.com/sehowyoung/images/raw/master/202111221939210.png" alt="例3-5"></p><ul><li>“人”和“计算机”之间的“买”的关系是1对多的关系，也就是说，一个“人”可以买0或多台“计算机”，但是，任何一台“计算机”只能被1个“人”购买。图中，基数用靠近实体的竖线或水平放置的爪形表示：竖线表示“1”，爪形表示“多”。模<br>态则用远离实体的竖线或圆圈表示：竖线表示“强制”，圆圈表示“可选”。因此，该图表示，系统中的“计算机”必须要有一个“人”购买，否则，系统不保存有关信息：但是，系统中的“人”可能买了“计算机”，也可能还未买（是潜在的客户）。</li></ul></li></ul><h2 id="3-6-用例建模"><a href="#3-6-用例建模" class="headerlink" title="3.6 用例建模"></a>3.6 用例建模</h2><ul><li>用例建模是一种从<strong>用户使用系统</strong>的角度来建立系统功能需求模型的一种方法。</li><li>用例建模既非从数据模型开始，亦非从系统数据流着手，而是从<strong>组成系统的实际操作</strong>入手。</li><li>用例图，又称用例模型，是用例建模的主要成果，它从系统外部执行者的角度来描述系统需要提供哪些功能以及谁使用这些功能。</li></ul><h3 id="3-6-1-用例图"><a href="#3-6-1-用例图" class="headerlink" title="3.6.1 用例图"></a>3.6.1 用例图</h3><ul><li><p>四种主要成分：</p><ul><li>系统：待开发的任何事物，包括软件、硬件或者过程</li><li>参与者：使用系统的对象，系统外部的实体，以某种方式参与用例的执行过程<ul><li>主要参与者：主动发起人，通过使用用例从系统中获得业务价值。主要参与者可能是一个，可能是多个。</li><li>次要参与者：为其他参与者创造业务价值</li></ul></li><li>用例：参与者为达到某个目的而与系统进行的一系列交互，执行结果将为参与者提供可度量的价值</li><li>关系：描述参与者和用力之间的关系<ul><li>通信关系：描述参与者和用力之间的关系</li><li>泛化关系：参与者之间的泛化关系意味着一个参与者可以完成另一个参与者同样的任务，它也可补充额外的任务。用例之间的泛化关系意味着一个用例是另一个用例的特殊版本。</li><li>包含关系：包含关系描述了用例间的共同行为。当两个或两个以上用例有共同的执行序列片断时，可以将这些执行序列片断抽出，形成被包含例。同时，当一个用例描述的执行序列是另一个用例的执行序列的一部分时，也可使用包含关系。</li><li>拓展关系：对一个已存在用例增加新功能</li></ul></li></ul><p><img src="https://gitee.com/sehowyoung/images/raw/master/202111221958193.png" alt="简单ATM系统用例图"></p></li></ul><h3 id="3-6-2-参与者及用例的描述"><a href="#3-6-2-参与者及用例的描述" class="headerlink" title="3.6.2 参与者及用例的描述"></a>3.6.2 参与者及用例的描述</h3><ul><li>参与者描述的内容主要包括参与者的名称、是否为抽象参者与及对参与者的简要描述。</li><li><img src="https://gitee.com/sehowyoung/images/raw/master/202111222000449.png" alt="参与者规格说明"></li><li>用例描述有许多种方法，如简单文字、模板、表格、形式化语言和图形等，开发人员可根据项目进展及用户特点灵活选择。</li></ul><h3 id="3-6-3-用例建模步骤"><a href="#3-6-3-用例建模步骤" class="headerlink" title="3.6.3 用例建模步骤"></a>3.6.3 用例建模步骤</h3><ol><li>找出系统的参与者和用例；<br>（<strong>在选择参与者时</strong>，有两个非常有用的标准：首先，应该能至少确定一个用户来扮演参与者；其次，与系统相关的不同参与者实例所充当的角色间的重叠应该最少。<strong>在确定用例时</strong>，“有价值的结果”和“特定参与者”是两个有用的准则。） </li><li>区分用例的优先次序；</li><li>详细描述每个用例；</li><li>构造用户界面原型；</li><li>构造用例图。</li></ol><p>（用例的结构关系应尽量反映真实情况；需要将每个单独的用例视为一个单独的制品；应尽量避免从功能上分解用例。）</p><h2 id="3-7-面向对象建模"><a href="#3-7-面向对象建模" class="headerlink" title="3.7 面向对象建模"></a>3.7 面向对象建模</h2><ul><li><p>对象建模的主要任务是了解某个特定应用问题域内所涉及的对象，以及各种各样的结构和通信关系。</p></li><li><p>面向对象方法学的三原则：</p><ol><li>一切事物皆对象</li><li>任何系统都由对象构成，系统本身也是对象</li><li>系统的发展和进化过程都是由系统的内部对象和外部对象（内部对象）之间的相互作用完成的</li></ol></li><li><p>面向对象方法的主要特征：</p><ul><li>由对象组成的，软件中的任何元素都是对象</li><li>将所有对象划分成各种类，每个类都定义一组数据和一组方法</li><li>按照子类和父类的关系，将若干类组成一个层次的系统</li><li><p>对象与对象之间只能通过传递消息进行通信</p></li><li><p><strong>面向对象=对象+类+继承+通信</strong></p></li></ul></li><li><p>封装、继承与多态是面向对象方法区别于传统的结构化方法的三个主要特点。</p><ul><li><p>封装：是指其类与对象把数据和操纵数据的方法合在一起构成一个整体，外部只能通过消息来同对象打交道。</p></li><li><p>继承：子类可以继承父类的所有属性和方法</p></li><li><p>多态：指为不同数据类型的实体提供统一的接口，或使用一个单一的符号来表示多个不同的类型。</p></li></ul></li></ul><h3 id="3-7-1-确定对象-amp-类（对象层）"><a href="#3-7-1-确定对象-amp-类（对象层）" class="headerlink" title="3.7.1 确定对象&amp;类（对象层）"></a>3.7.1 确定对象&amp;类（对象层）</h3><ul><li>对象是现实世界某些事物的一个抽象，它反映该事物在系统中需要保存的信息和发挥作用。 </li><li>类是具有相同属性和操作的一组对象的集合。</li><li>方法：<ul><li>三视图模型法（实体一关系模型、数据流模型、状态—迁移模型）</li><li>基于语言的信息分析法（短语频率分析、矩阵分析）；类职责协作（Class—Reponsibility—Collaboration，CRC）卡片。</li></ul></li><li>应该说明的是：①最后得到的对象&amp;类不可能被证明是绝对正确或绝对错误；②用户的偏好对模型最后所选择的对象&amp;类有很大的影响。</li></ul><h3 id="3-7-2-标识结构（结构层）"><a href="#3-7-2-标识结构（结构层）" class="headerlink" title="3.7.2 标识结构（结构层）"></a>3.7.2 标识结构（结构层）</h3><ul><li>标识结构是用来处理对象建模复杂性的机制之一。</li><li>现实世界的事物之间有两种主要关系：继承关系、整体/部分关系。</li><li><img src="https://gitee.com/sehowyoung/images/raw/master/202111222124700.png" alt="image-20211122212458646"></li><li>对于分类继承关系，可以采用如下的方式来标识：自顶向下和自底向上方式。 </li><li>对于整体/部分的聚合和组合关系，一方面，把每一个对象的类看成是一个整体，考虑：什么是它的部分或组成成份。另一方面，把每一个对象的类看成一个部件，考虑：该对象的类适合什么样的组装整体。</li></ul><h3 id="3-7-3-标识主题（主题层）"><a href="#3-7-3-标识主题（主题层）" class="headerlink" title="3.7.3 标识主题（主题层）"></a>3.7.3 标识主题（主题层）</h3><ul><li><p>方法：</p><ul><li>对每一个结构增加一个相应的主题；</li><li>对每个对象增加一个相应的主题；</li><li>将紧密耦合的主题组合起来得到更好的主题；</li><li>如果主题的数目较多不符合“7±2规则”，则应进一步精炼主题。 </li></ul><p>注：1. 在选择主题时，不应用功能分解方法，开发人员可以依据子问题域、子系统，甚至组织或地域来区分主题。</p><ol><li>若将一个主题看成是问题域中的整体/部分关系，即问题域由主题组成，则对建立模型很有用。</li></ol></li></ul><h3 id="3-7-4-定义属性及实力关联（属性层）"><a href="#3-7-4-定义属性及实力关联（属性层）" class="headerlink" title="3.7.4 定义属性及实力关联（属性层）"></a>3.7.4 定义属性及实力关联（属性层）</h3><ul><li>属性是对象&amp;类的数据单元，定义属性使得问题域更加明确，也使对对象&amp;类和结构的认识更深入具体。</li><li>在分析阶段，一般不使用属性来表示对象&amp;类之间的关系，而使用对象&amp;类的实例关联来描述。 </li><li>实例关联可以看成是一种事务规则或应用论域限制。当实现这些对象的时侯，这些事务规则指明操作如何运行，以确保与系统的策略相一致。</li><li>在UML中，实例的关联表示包括：关联名称、角色名称、多重性和导航性； </li><li>一般，在图中要么注明关联名称，要么注明角色名称，而不同时注明角色名称和关联名称；</li><li>在UML中，多重性被说明为用逗号分隔的区间，每个区间具有如下形式：minimum、maximum ；在UML中，如果多重性不显式说明，则多重性就不确定；</li><li>导航性的意义可看做“消息仅能够沿箭头所指的方向传递”。在UML中，没有导航性标识，则表示关联是双向的。</li><li>属性定义：<ul><li>分类：描述性、命名性、参考属性</li><li>定义属性应该在原子概念的层次上进行。</li><li>方法：依据属性的种类考察每个对象&amp;类可帮助定义属性；如果已建立数据视图，如IDEF1X图，ER图，数据视图中的实体的属性表示了存储数据的需求，这些存储数据的需求必须体现在模型中，一般作为对象&amp;类的属性；另外，通过考察对象的描述，也可为定义属性提供帮助。</li><li>对于分类结构，应该利用继承机制来定位属性的位置。</li></ul></li><li>实力关联定义：<ul><li>实例关联反映了对象&amp;类的实例之间的相互依赖、相互作用的关系。整体/部分关系是一种特殊的实例关联。 </li><li>方法：直接提取需求陈述中的动词词组；领域知识；矩阵分析；等。</li><li>实例关联应仅选择哪些系统必须维持的实例对应关系。</li></ul></li></ul><h3 id="3-7-5-定义服务及消息连接（服务层）"><a href="#3-7-5-定义服务及消息连接（服务层）" class="headerlink" title="3.7.5 定义服务及消息连接（服务层）"></a>3.7.5 定义服务及消息连接（服务层）</h3><ul><li>定义服务也即标识对象&amp;类的操作。对象&amp;类所执行的操作以及对象之间传递的消息反映了对象&amp;类的动态关系，也即系统的动态方面。 </li><li>定义服务的方法：考察系统的责任；研究问题域；分析对象&amp;类状态或追踪对象&amp;类的执行线路；用例模型中的事件流</li><li>定义消息连接：<ul><li>在对象建模中，消息是对象&amp;类之间在行为上的唯一联系方式。 </li><li>方法：在已经存在实例连接的对象&amp;类和分类结构之间增加消息连接；检查对象&amp;类和分类结构，寻找一个实例所需要的另一个实例的操作。 </li><li>在UML的类图中，可以采用实例关联的导航性来表示消息连接。也可采用单独的协作图或顺序图来描述对象&amp;类实例的消息连接。 </li></ul></li></ul><h2 id="3-8-统一建模语言UML"><a href="#3-8-统一建模语言UML" class="headerlink" title="3.8 统一建模语言UML"></a>3.8 统一建模语言UML</h2><blockquote><p>UML（Unified Modeling Language, UML）是一种可以应用于任面向对象软件开发方法的标记法和语义语言。</p></blockquote><h3 id="3-8-1-UML结构"><a href="#3-8-1-UML结构" class="headerlink" title="3.8.1 UML结构"></a>3.8.1 UML结构</h3><p><img src="https://gitee.com/sehowyoung/images/raw/master/202111222139523.png" alt="UML结构"></p><ul><li><p>关系：<a href="http://igiggle.cn/archives/u-m-l-lei-tu-yi-ji-lei-jian-guan-xi--fan-hua---shi-xian--yi-lai--guan-lian--ju-he--zu-he-">UML类图以及类间关系(泛化 、实现、依赖、关联、聚合、组合)</a></p><p>| 关系      | 标记法                     | 说明                         |<br>| ————- | ————————————— | —————————————— |<br>| 关联      | ——————————                 | 对象之间的一组连接           |<br>| 依赖      | -·-·-·-·-&gt;                 | 物件的改变引起依赖物件的改变 |<br>| 泛化/继承 | —————————$\triangleright $ | 继承父类                     |<br>| 实现      | - - - - -$\triangleright $ | 实现接口或者抽象类           |</p></li><li><p><img src="https://gitee.com/sehowyoung/images/raw/master/202111222204232.png" alt="视图框架"></p></li><li><p>类图：</p><ul><li>描述了对象的结构</li><li>关键元素是类元（类、接口等）以及它们之间的关系</li><li>类元之间有关联、泛化及各种不同的依赖关系，包括实现和使用关系。</li><li><img src="https://gitee.com/sehowyoung/images/raw/master/202111222207944.png" alt="image-20211122220758890" style="zoom:67%;"></li></ul></li><li><p>包图</p><ul><li>包图由包或类组成，表示包与包、包与类之间的关系，用于描述系统的分层结构。 </li><li>包图中包用文件夹图形来描述。</li><li><img src="https://gitee.com/sehowyoung/images/raw/master/202111222208593.png" alt="包图"></li></ul></li><li><p>组件图</p><ul><li>组件图，又称构件图，用来描述软件的各个组件（包括源代码文件、二进制文件、脚本、可执行文件等）之间的依赖关系。 </li><li>在UML中，组件使用左侧带两个小矩形的大矩形表示。 </li><li><img src="https://gitee.com/sehowyoung/images/raw/master/202111222209939.png" alt="组件图"></li></ul></li><li><p>部署图</p><ul><li>部署图，又称配置图，显示的是对运行时处理节点以及其中的组件的配置，反映了系统硬件的物理拓扑结构。 </li><li>在UML中，节点用一个三维矩形表示。 </li><li><img src="https://gitee.com/sehowyoung/images/raw/master/202111222210583.png" alt="部署图"></li></ul></li><li><p>对象图</p><ul><li>对象图描述的一组对象以及它们之间的关系。 </li><li>对象是类的一个具体实例，在UML中采用矩阵形表示。其中标明对象名和属性取值。</li><li><img src="https://gitee.com/sehowyoung/images/raw/master/202111222210118.png" alt="对象图"></li></ul></li><li><p>用例图</p><ul><li>用例图从系统外部执行者的角度来描述系统需要提供哪些功能，指明这些功能的参与者，即用例图描述了参与者和用例及它们之间的关系。</li></ul></li><li><p>顺序图</p><ul><li>顺序图用来建模以时间顺序安排的对象间的交互。</li><li><img src="https://gitee.com/sehowyoung/images/raw/master/202111222211057.png" alt="顺序图"></li></ul></li><li><p>协作图</p><ul><li>协作图，又称合作图，用来建模对象或角色之间的交互，描述这些对象或角色之间是如何彼此通信的。</li><li><img src="https://gitee.com/sehowyoung/images/raw/master/202111222212002.png" alt="协作图"></li></ul></li><li><p>状态图</p><ul><li>状态图描述一个类对象所经历的各种状态以及事件发生时状态的转移条件。 </li><li><img src="https://gitee.com/sehowyoung/images/raw/master/202111222213097.png" alt="状态图"></li></ul></li><li><p>活动图</p><ul><li>活动图是由状态图变化而来的，描述需要执行的活动以及执行这些活动的顺序。</li><li><img src="https://gitee.com/sehowyoung/images/raw/master/202111222213773.png" alt="活动图"></li><li><img src="https://gitee.com/sehowyoung/images/raw/master/202111222214058.png" alt="泳道形式的活动图示例" style="zoom:50%;"></li></ul></li></ul><h3 id="3-8-2-特点"><a href="#3-8-2-特点" class="headerlink" title="3.8.2 特点"></a>3.8.2 特点</h3><ol><li>统一了面向对象方法的基本概念 ；</li><li>具有更强的建模能力 ；</li><li>独立于特定的开发语言和开发过程。</li></ol><h3 id="3-8-3-应用"><a href="#3-8-3-应用" class="headerlink" title="3.8.3 应用"></a>3.8.3 应用</h3><ol><li><p>需求分析 </p><p>用例图—-功能的需求；类图—-静态结构 ；</p><p>状态图、顺序图和协作图等—-类之间所需的协作，实现用例。</p></li><li><p>设计 </p><p>定义软件系统中的技术细节用到的类，如引入处理用户交互的类、处理数据的类、处理通信和并行性的类等。 </p></li><li><p>实现 </p><p>组件图—-代码组件的物理结构以及组件之间的关系；部署图—-硬件的拓扑结构和组件的分布。</p></li><li><p>测试 </p><p>类图—-单元测试；组件图、协作图—-集成测试；用例图 —-确认测试 </p></li></ol><h1 id="第四章-软件设计"><a href="#第四章-软件设计" class="headerlink" title="第四章 软件设计"></a>第四章 软件设计</h1><h2 id="4-1-软件设计的任务和过程"><a href="#4-1-软件设计的任务和过程" class="headerlink" title="4.1 软件设计的任务和过程"></a>4.1 软件设计的任务和过程</h2><ul><li>概要设计的主要任务是回答“系统总体上应该如何做？”，即将分析模型映射为具体的软件结构。</li><li>详细设计则将概要设计的结果具体化，其主要任务是确定软件系统各组组成成分内部的数据结构和算法过程。</li><li>过程：<ol><li>数据设计（对象设计）：设计数据结构（类的属性）</li><li>软件结构（子系统）设计：定义主要元素间的关系（划分子系统）</li><li>接口（消息）设计：系统内部、系统之间、系统与用户如何通信</li><li>过程（方法）设计：得到系统各个功能的过程化描述</li></ol></li></ul><h2 id="4-2-软件设计基本原则"><a href="#4-2-软件设计基本原则" class="headerlink" title="4.2 软件设计基本原则"></a>4.2 软件设计基本原则</h2><h3 id="4-2-1-抽象与求精"><a href="#4-2-1-抽象与求精" class="headerlink" title="4.2.1 抽象与求精"></a>4.2.1 抽象与求精</h3><ul><li>抽象是一种常用的思考和解决问题的方式，即抽取事物的本质的共同特性而暂时避开不必要的低层细节。 </li><li>方式：过程抽象、数据抽象和控制抽象。</li><li>抽象过程是指具有特定功能的一个命名的指令序列。（如：二维图形创建 ）</li><li>抽象数据则是描述数据对象的一个命名的数据集合。（如：“图画”数据对象 ） </li><li>抽象控制包含了一种程序控制机制而无须刻画其内部细节。（如：操作系统中的“同步信号量”）</li><li>求精是由N. Wirth最初提出的一种自顶向下设计策略，其主要思想是：将某个宏观功能不断分解，逐步确定过程细节，直至用程序设计语言描述的算法实现为止。</li><li>抽象使得设计人员能够避开过早地陷入细节之中刻画过程和数据。</li><li>求精能够帮助设计人员随着设计过程的深入而不断呈现更低层次的信息。</li></ul><h3 id="4-2-2-模块化和信息隐藏"><a href="#4-2-2-模块化和信息隐藏" class="headerlink" title="4.2.2 模块化和信息隐藏"></a>4.2.2 模块化和信息隐藏</h3><ul><li>软件应该分解成可单独命名的且可访问的部件，这些部件称为模块。</li><li>分而治之：把一个大问题分解成若干小问题来解决时将会更加容易。</li><li><img src="https://gitee.com/sehowyoung/images/raw/master/202111222330549.png" alt="image-20211122233026420"></li><li>信息隐藏：是指模块中所包含的信息（包括数据和过程）对不需要这些信息的其它模块是不可访问的。</li><li>抽象有助于定义组成软件的过程（或信息）实体</li><li>隐藏定义并加强了对模块内部访问的约束，有助于分离模块的实现者和使用者。</li></ul><h3 id="4-2-3-模块独立性"><a href="#4-2-3-模块独立性" class="headerlink" title="4.2.3 模块独立性"></a>4.2.3 模块独立性</h3><ul><li><p>模块独立性：是模块化、抽象和信息隐藏的直接产物，其基本含义是每一个模块只完成功能需求中的一个特定的子功能，而且从程序结构的其它部分来看这一模块只具有一个简单的接口</p></li><li><p>模块的功能独立性可以使得模块既容易开发又容易维护。</p></li><li><p>模块独立性有两个定性的度量标准：内聚度和耦合度。 </p></li><li><p>内聚度：</p><ul><li>内聚度（Cohesion）是指模块内部各成分联系紧密的程度。</li><li>通常，内聚度越高，模块的独立性就越强。 </li><li>内聚程度从高到低的顺序是：功能内聚、信息内聚、通信内聚、过程内聚、时间内聚、逻辑内聚和偶然内聚。 </li><li>设计模块时，应该尽可能<strong>避免</strong>使用偶然内聚等低级内聚的模块，<strong>争取</strong>高级内聚的模块，以提高模块的独立性。</li></ul><p><img src="https://gitee.com/sehowyoung/images/raw/master/202111222342563.png" alt="image-20211122234256412"></p></li><li><p>耦合度：</p><ul><li>耦合（Coupling）是模块之间相互关联紧密的程度。</li><li>一般地，模块的耦合度越低，模块的独立性越强。</li><li>模块之间的耦合程度从低到高也可分为七种：非直接耦合、数据耦合、标记耦合、控制耦合、外部耦合、公共耦合、内容耦合。 </li><li>在设计模块时，应该<strong>尽量</strong>使用数据耦合，<strong>必要时</strong>使用标记耦合，<strong>少用</strong>控制耦合，限制使用公共耦合，<strong>最好不要</strong>使用内容耦合。 </li></ul><p><img src="https://gitee.com/sehowyoung/images/raw/master/202111222353750.png" alt="image-20211122235314594"></p></li></ul><h2 id="4-3-面向数据流图的设计方法"><a href="#4-3-面向数据流图的设计方法" class="headerlink" title="4.3 面向数据流图的设计方法"></a>4.3 面向数据流图的设计方法</h2><ul><li><p>面向数据流图的设计方法是一种结构化设计方法</p></li><li><p>两种设计方法：数据流分析和事务分析</p></li><li><p>过程：</p><ol><li>研究、分析和审查数据流图，确保数据流图符合实际，必要时还要进一步精化数据流图。</li><li>确定数据流图的类型，即变换型数据流或事务型数据流。</li><li>再依据数据流图的类型采用变换分析法或事务分析法导出系统初始的软件结构。</li><li>依据软件设计原理和一些优化策略改进系统初始的软件结构，形成最终的软件结构。</li></ol></li></ul><p><img src="https://gitee.com/sehowyoung/images/raw/master/202111231422860.png" alt="结构化分析模型转换为结构化设计模型示意图"></p><h3 id="4-3-1-层次图和改进的IPO图"><a href="#4-3-1-层次图和改进的IPO图" class="headerlink" title="4.3.1 层次图和改进的IPO图"></a>4.3.1 层次图和改进的IPO图</h3><ul><li>层次图主要用来描绘软件的层次结构，矩形框代表一个模块，矩形框间的连线表示模块间的调用关系。层次图很适于在自顶向下设计软件的过程中使用，且常与IPO图一起使用，形成HPO图，层次图中的每个方框对应一个IPO图。为了使用方便，在层<br>次图中除顶层外，每个方框都加了编号，且对IPO图进行了改进。</li><li><img src="https://gitee.com/sehowyoung/images/raw/master/202111231432330.png" alt="层次图示例"></li><li><img src="https://gitee.com/sehowyoung/images/raw/master/202111231432881.png" alt="改进的IPO图示例"></li></ul><h3 id="4-3-2-软件结构图"><a href="#4-3-2-软件结构图" class="headerlink" title="4.3.2 软件结构图"></a>4.3.2 软件结构图</h3><ul><li>在结构化设计方法中，软件结构是软件系统模块层次结构，反映了整个系统功能及其之间的关系。 </li><li>软件结构图的主要内容有：<ul><li>模块<ul><li>6种：传入模块、传出模块、变换模块、协调模块、源模块和漏模块</li><li>用<strong>方框</strong>表示，并用名字标识方框</li></ul></li><li>模块间的调用关系<ul><li>三种：顺序调用、选择调用、循环调用</li><li>方框之间的箭头表示模块之间的调用与被调用关系。</li><li>模块间调用的次序，习惯上是<strong>从左至右</strong>。</li><li><img src="https://gitee.com/sehowyoung/images/raw/master/202111231426058.png" alt="三种调用关系"></li></ul></li><li>模块之间传递的信息。<ul><li>模块传递的信息用带名称的<strong>短线箭头</strong>来表示。箭头方向代表信息传递的方向。 </li><li>若箭头线尾是带<strong>空心圆圈</strong>，则表示该箭头线代表的是<strong>数据</strong>；若箭头线尾是带<strong>实心圆圈</strong>，则表示该箭头线代表的是<strong>控制</strong></li><li><img src="https://gitee.com/sehowyoung/images/raw/master/202111231427195.png" alt="image-20211123142707153" style="zoom:33%;"></li></ul></li></ul></li></ul><h3 id="4-3-3-数据流变换分析法"><a href="#4-3-3-数据流变换分析法" class="headerlink" title="4.3.3 数据流变换分析法"></a>4.3.3 数据流变换分析法</h3><ul><li><p>数据流变换分析法是一种将变换型数据流图映射为变换型软件结构图的软件系统设计方法。 </p></li><li><p>变换型数据流图一般呈线性形状，大致由三部分组成：传入路径、变换中心和传出路径。 </p></li><li><p>变换型软件结构图则大致由四部分模块组成：输入模块、中心加工模块，输出模块和主控模块。</p></li><li><p>传入、传出路径和交换中心的标识</p><ul><li>一般，可以采用<strong>试探的办法</strong>来确定系统的变换中心和传入/传出路径。 </li><li>从数据流图的物理输入始端出发，沿数据流一步步往数据流图的输出末端移动，直到遇到的数据流不能再被看作是系统的输入数据为止，则其前一个数据流便是<strong>系统的逻辑输入</strong>。 </li><li>从数据流图的物理输出未端一步步往数据流图的输入始端移动，直到遇到的数据流不能再被看作是系统的输入数据为止，则其后一个数据流便是<strong>系统的逻辑输出</strong>。</li><li>从物理输入始端至系统的逻辑输入构成系统的<strong>传入路径部分</strong>。从物理输出未端至系统的逻辑输出构成系统的<strong>传出路径部分</strong>。逻辑输入和逻辑输出之间的部分构成<strong>变换中心部分</strong>。</li></ul></li><li><p>例子：</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/202111231444778.png" alt="例4-3-1"></p><p>在找出系统的传入/传出路径和变换中心后，在数据流图中用分界线来标识它们。</p><ul><li><p>一级分解：</p><ul><li>将数据流图映射为一个能为信息的输入、变换和输出提供控制的特定结构。</li></ul><p><img src="https://gitee.com/sehowyoung/images/raw/master/202111231445368.png" alt="一级分解"></p></li><li><p>二级分解：</p><ul><li>将数据流图中的每一个加工处理映射为软件结构图中一个模块。 </li><li>对于<strong>传入路径中的加工处理</strong>，从变换中心的边界开始，沿着传入路径向外移动，把传入路径中遇到的每个加工处理映射成软件结构图中输入信息处理控制模块直接或间接调用的模块。</li><li>对于<strong>传出路径中的加工处理</strong>，从变换中心的边界开始，沿着传出路径向外移动，把传出路径中遇到的每个加工处理映射成软件结构图中输出信息处理控制模块直接或间接调用的模块。</li><li>对于<strong>变换中心的加工处理</strong>，则直接映射为变换流控制模块直接调用的模块。 </li></ul><p><img src="https://gitee.com/sehowyoung/images/raw/master/202111231446573.png" alt="二级分解"></p></li></ul></li></ul><h3 id="4-3-4-事务分析法"><a href="#4-3-4-事务分析法" class="headerlink" title="4.3.4 事务分析法"></a>4.3.4 事务分析法</h3><ul><li><p>事务分析法是将事务型数据流图映射为事务型软件结构图的软件系统设计方法。</p></li><li><p>事务型数据流图一般呈幅射状，由三部分组成，即至少一条接收路径、一个事务中心和若干条动作路径。</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/202111231449294.png" alt="事务型数据流图"></p></li><li><p>事务型软件结构图大致由四部分模块构成。事务接受模块、事务调度模块、事务处理控制模块和总控模块。</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/202111231450529.png" alt="事务型软件结构图"></p></li><li><p>数据流图事务中心的标识 </p><ul><li>事务中心一般位于几条动作路径的起始点上。</li><li>动作路径具有自己的结构特征，可能是事务型的，也可能是变换型的。在标识事务中心的同时，还应确定每条动作路径的结构特征，并在数据流图中标识。</li></ul></li><li><p>例子：</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/202111231451307.png" alt="例4-3-2"></p><ul><li><p>一级分解</p><ul><li>将事务型的数据流图图映射到包含一个事务接收分支和一个事务分类处理分支的软件结构上。</li></ul><p><img src="https://gitee.com/sehowyoung/images/raw/master/202111231452193.png" alt="一级分解"></p></li><li><p>二级分解</p><ul><li>细化事务接收模块和事务处理控制模块。</li><li>从事务中心开始，沿接收路径的变换被映射成事务接收模块直接或间调用的模块。</li><li>数据流图的每一条动作路径映射成与其自身的数据流图类型相一致的软件结构，其方法是变换分析法或事务分析法。</li></ul><p><img src="https://gitee.com/sehowyoung/images/raw/master/202111231454757.png" alt="二级分解"></p></li></ul><h4 id="4-3-5-改进"><a href="#4-3-5-改进" class="headerlink" title="4.3.5 改进"></a>4.3.5 改进</h4><ul><li>在改进软件结构时应该记住“一个不能工作的最佳设计”是毫无价值的。 </li><li>设计人员应该致力于设计能够满足所有功能和性能要求，而且按照设计原理和改进规则衡量是值得接收的软件。</li></ul><ol><li>模块大小适中<ul><li>模块大小影响模块的可理解性。</li><li>限制模块的大小也是减少软件复杂性的手段之一。</li><li><strong>对于规模较大的模块，检查其包含的功能，从中分离出一些功能构成软件结构图中的同层或下一层的其它模块。</strong> </li><li><strong>对于规模较小的模块，应考虑是否可以同它的上层调用模块合并。</strong></li></ul></li><li>模块扇入扇出合理<ul><li>模块的扇出是指模块直接调用多少其它模块。 </li><li>模块的扇入是指共有多个模块直接调用本模块。 </li><li>模块的扇出过大，表明该模块过分复杂，需要协调和控制过多的下层模块。 </li><li>模块的扇入过大，而它又不是公用模块，一般来说明该模块可能具有多个功能。 </li><li>一个模块的扇出不要超过7个(7土2原则)，否则应考虑<strong>重新分解</strong>，如增加中间层但如果模块功能是“分类”，则顺其自然，不受限制。</li><li>经验表明，良好的软件结构图，上层模快（主要是控制模块）往往具有较高的扇出，底层的模块（主要是功能型模块）具有较高的扇入，呈两头小、中间大的清真寺状。</li></ul></li><li>模块的作用域应在控制域内<ul><li>模块的作用域是指模块中判定的作用范围，它是指所有受这个判定影响的模块。 </li><li>模块的控制域是指模块本身及其直接或间接调用的模块。 </li><li>如果模块的作用域不在控制域之内，则会增加模块间数据的传递量，使模块之间出现控制耦合。</li><li>可从以下几个方面对结构图进行改造:<ul><li>将做判定的模块合并到它的上层调用模块中，从而使判定处于足够高的层次。</li><li>将受判定影响的模块下移到控制范围内。</li><li>将判定上移到层次较高的位置</li></ul></li></ul></li></ol></li></ul><h2 id="4-4-面向对象设计原则"><a href="#4-4-面向对象设计原则" class="headerlink" title="4.4 面向对象设计原则"></a>4.4 面向对象设计原则</h2><div class="table-container"><table><thead><tr><th>原则</th><th>定义</th></tr></thead><tbody><tr><td>单一职责原则</td><td>一个对象只包含单一的职责，并且该职责被完整地封装在一个类中</td></tr><tr><td>开闭原则</td><td>对拓展开放，对修改关闭</td></tr><tr><td>里氏替换原则</td><td>使用基类的地方必须能透明地使用其子类</td></tr><tr><td>依赖倒转原则</td><td>高层模块不应该依赖低层模块，应该以来抽象。抽象不应该依赖于细节，细节应该依赖于抽象</td></tr><tr><td>接口隔离原则</td><td>客户端不应该依赖那些不需要的接口</td></tr><tr><td>合成复用原则</td><td>优先使用对象组合，而不是通过继承来达到复用的目的</td></tr><tr><td>迪米特法则</td><td>每一个软件单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位</td></tr></tbody></table></div><h2 id="4-5-面向对象的设计方法"><a href="#4-5-面向对象的设计方法" class="headerlink" title="4.5 面向对象的设计方法"></a>4.5 面向对象的设计方法</h2><h3 id="4-5-1-软件复用"><a href="#4-5-1-软件复用" class="headerlink" title="4.5.1 软件复用"></a>4.5.1 软件复用</h3><ul><li>软件复用：是指软件开发过程中重复使用相同或相似的软件元素</li><li>目标：缩短开发周期、降低维护代价、可靠性、高效性、一致性、保护投资</li><li>对象：<ul><li>个人的复用</li><li>设计和功能规格说明的复用</li><li>设计模式的复用</li><li>源代码的复用</li><li>抽象模块的复用</li></ul></li><li>阻力<ul><li>管理人员：纠正开发人员不愿意复用的思想</li><li>经济方面：软件开发人员不愿意写得通用，害怕无事可做</li><li>软件部件的管理：没有有效的管理</li><li>增加的开发费用：将软件转换成可复用的软件部件需要付出很大的代价</li><li>法律方面：版权问题</li></ul></li><li>对模块化结构的要求<ul><li>类型可变：高层次设计软件模块时可能规定了通用类型，因此需要支持不同的类型</li><li>例程组合：在设计可复用的软件部件的时候，相关的例程应该能组成一个包</li><li>实现可变：多种实现方式</li><li>表示独立性：使用者只关心接口，不关系实现细节</li><li>抽出共同的行为</li></ul></li></ul><h3 id="4-5-2-面向对象设计"><a href="#4-5-2-面向对象设计" class="headerlink" title="4.5.2 面向对象设计"></a>4.5.2 面向对象设计</h3><ol><li><p>子系统设计</p><ol><li><p>问题域部分设计</p><ul><li>最能反映用户需求的一个部件，也是面向对象需求分析中已经做了分析的部件。</li><li>修改<ul><li>调整需求； </li><li>重用已有的类；</li><li>将问题域有关的类组成一组，并建立一个公共的协议；</li><li>对继承进行调整，以利于实现；</li><li>提高性能。</li></ul></li></ul></li><li><p>人机交互部分设计</p><ul><li>人机交互部分突出人如保命令系统以及系统如何向用户提供交互信息。 </li><li>在设计人机交互部分时，首先考虑的是人，其次是任务，然后再是有关工具。 </li><li>人机交互部分在系统行为和用户界面之间架起了一座桥梁。</li><li>主要对象：窗口和报表</li><li>三类窗口<ul><li>登录窗口：进入系统的必经之路</li><li>设置窗口：三个目的：①建立和初始化系统正常运行所必需的对象，如建立、维护和删除持久性对象的窗口。②完成系统管理功能，如增加和删除授权使用系统的用户，或设置用户使用系统的权限级别。③由人来激活或关闭系统中的设备，如打印机、CD-ROM、视频摄像机等。</li><li>商务功能窗口：人机交互来完成商务功能</li></ul></li></ul></li><li><p>数据管理部件的设计</p><p>目的：</p><ol><li>用于存储问题域中持久性的对象</li><li>用于封装问题域中持久性对象的存储和检索机制</li></ol></li><li><p>系统交互部件的设计</p><p>主要负责系统与系统的物理设备之间、各子系统之间以及系统与其他系统之间的通信和数据交换</p></li></ol></li><li><p>对象设计</p><p>对每一个对象中的数据部分进行设计，得到每一个对象的更为准确的属性，然后设计这个属性相应的数据结构</p></li><li><p>消息设计</p><ul><li>描述每一个对象可以接收和发送消息的接口</li><li>出发点：<ul><li>对象与对象之间的关系，实质上代表相互之间传递消息的关系</li><li>对象与对象之间的事件跟踪图也是消息设计的一个出发点</li></ul></li></ul></li><li><p>方法设计</p><p>目的：</p><ul><li>将之前遗漏的方法找出来</li><li>定义每一种方法过程化的细节</li></ul></li></ol><h2 id="4-6-面向对象软件设计模式"><a href="#4-6-面向对象软件设计模式" class="headerlink" title="4.6 面向对象软件设计模式"></a>4.6 面向对象软件设计模式</h2><ul><li>设计模式是指系统地命名、解释和评价某一重要的、可重用的面向对象设计方案</li></ul><h3 id="4-6-1-创建型模式"><a href="#4-6-1-创建型模式" class="headerlink" title="4.6.1 创建型模式"></a>4.6.1 创建型模式</h3><ol><li><p>工厂方法模式</p><ul><li><p>适用情况：</p><ul><li><p>一个类不知道他所创建的对象的类</p></li><li><p>一个类希望由其子类确定他创建的对象</p></li><li><p>类将创建对象的职责分配给多个帮助者子类中的一个，且将哪一个帮助者子类作为代表这项信息布局化</p></li></ul></li><li><p>使用效果：</p><ul><li>比直接产生对象更加灵活</li><li>连接平行类层次，可见下图</li></ul></li><li><p><img src="https://gitee.com/sehowyoung/images/raw/master/202111231729997.png" alt="工厂方法示例"></p></li></ul></li><li><p>抽象工厂模式</p><ul><li>适用情景：<ul><li>系统与如何创建、组合和表示其产品无关</li><li>系统由多个产品族之一来配置</li><li>强调一系列相关产品对象的设计以便联合使用</li><li>提供一个产品类库，旦只想显示其接口。</li></ul></li><li>使用效果：<ul><li>隔离了具体的类</li><li>使产品族间的转换容易进行</li><li>容易实现一次应用只使用同一个系统中的产品对象</li><li>难以扩展抽象工厂以支持新种类的产品。</li></ul></li></ul></li></ol><p><img src="https://gitee.com/sehowyoung/images/raw/master/202111231732603.png" alt="抽象工厂模式"></p><h3 id="4-6-2-结构型模式"><a href="#4-6-2-结构型模式" class="headerlink" title="4.6.2 结构型模式"></a>4.6.2 结构型模式</h3><ol><li><p>适配器模式</p><ul><li>适用情景：<ul><li>希望使用一个已存在的类，但它的接口与希望的接口不匹配</li><li>要创建一个可复用的类，该类可以与其他不相关的类或不可预见的类协同工作</li><li>想使用一些已存在的类，但不能对每一个类子类化以匹配它们的接口（仅适用于对象组合的适配器模式）。</li></ul></li></ul><p><img src="https://gitee.com/sehowyoung/images/raw/master/202111231740240.png" alt="适配器模式"></p></li><li><p>组合模式</p><ul><li>使用条件：<ul><li>希望表示对象的整体、部分层次结构</li><li>希望一致的处理叶子对象和组合对象</li></ul></li><li>使用效果：<ul><li>定义了对象的整体/部分层次结构，且客户代码中任何用到叶子对象的地方均可使用组合对象</li><li>简化了客户代码，客户代码不必关心处理的是叶子对象还是组合对象，即可以一致地使用叶子对象和组合对象</li><li>易于添加新的组合子类和叶子子类，客户代码不必因新的组合子类和叶子子类而改变；</li><li>使设计更加通用，但难于实现只组合某些特定的部件限制。</li></ul></li><li><img src="https://gitee.com/sehowyoung/images/raw/master/202111231744054.png" alt="组合模式"></li></ul></li></ol><h3 id="4-6-3-行为型模式"><a href="#4-6-3-行为型模式" class="headerlink" title="4.6.3 行为型模式"></a>4.6.3 行为型模式</h3><ol><li><p>迭代器模式</p><ul><li>使用条件<ul><li>在不暴露聚合对象内部表示的条件下访问聚集对象。</li><li>支持对聚合对象的多种遍历。</li><li>为遍历不同的聚合对象提供一个统一接口。</li></ul></li><li>使用效果<ul><li>支持以不同的方式遍历聚合对象。</li><li>简化了聚合对象的接口。迭代器的遍历接口使聚合对象本身不再需要类似的遍历接口。</li><li>由于每个迭代器保持它自己的遍历状态，因此可以在同一个聚合对象进行多种遍历。</li></ul></li><li><img src="https://gitee.com/sehowyoung/images/raw/master/202111231755159.png" alt="迭代器模式"></li></ul></li><li><p>观察者模式</p><ul><li>适用条件<ul><li>一个模型有两个方面，其中一方面依赖于另一方面。将二者分别封装在独立的对象中可使它们可以各自独立地改变和复用。</li><li>一个对象的改变需要同时改变其它对象，且不知道有多少对象需改变。</li><li>一个对象必须能够在对别的对象一无所知的情况下通知它们。</li></ul></li><li>使用效果<ul><li>减少了Subject类和Observer类之间的耦合。</li><li>支持广播通信。主题发送的通知不需指定它的接收者。处理还是忽略一个通知取决于观察者。</li><li>可能会发生预想不到的更新。在主题上一个看似无关紧要的操作可能会引起一系列对观察者以及依赖这些观察者的那些对象的更新。</li></ul></li></ul><p><img src="https://gitee.com/sehowyoung/images/raw/master/202111231756311.png" alt=""></p></li></ol><h2 id="4-7-模型一视图一控制器框架"><a href="#4-7-模型一视图一控制器框架" class="headerlink" title="4.7 模型一视图一控制器框架"></a>4.7 模型一视图一控制器框架</h2><ul><li><p>模型－视图－控制器（Model-View-Controller， MVC）框架结构是为那些需要为同一数据提供多个视图的应用程序而设计的，它很好的实现了数据层与表示层的分离。</p></li><li><p><img src="https://gitee.com/sehowyoung/images/raw/master/202111231801066.png" alt="MVC框架中类的交互"></p><ol><li><p>当用户进行一些输入动作后，控制器接收用户事件，并根据事件的类型来改变模型</p></li><li><p>视图事先会在模型中登记，当模型数据发生改变时，马上通知已向此模型登记的每个视图，视图从模型中取得最新的数据并刷新自己。</p></li></ol></li></ul><h2 id="4-8-软件体系结构"><a href="#4-8-软件体系结构" class="headerlink" title="4.8 软件体系结构"></a>4.8 软件体系结构</h2><ul><li>SEI 定义:软件体系结构是指一个程序/系统构件的结构，它们之间的相互关系， 以及在设计和交付的整个过程中的原则和指导方针.<br>Mary Shaw 和 David Garlan 认为， 软件体系结构包括构成系统的设计元素的描述，设计元素的交互，设计元素组合的模式，以及在这些模式中的约束。<br>国内普遍定义:软件体系结构包括构件、连接件和约束，它是可预制和可重构的软件框<br>架结构。 构件是可预制和可重用的软件部件，是组成体系结构的基本计算单元或数据存储单元;连接件也是可预制和可重用的软件部件，是构件之间的连接单元;构件和连接件之间的关系用约束来描述</li><li>软件体系结构包括：构件(Component)、连接件(Connector)和约束(Constraint)或配置(Configuration)三大要素。 <ul><li>构件：<ul><li>是指一个计算单元或者数据存储单元，可以是一个处理过程或数据元素</li><li>构件是用于实现计算和状态的单元，可以工作在：客户端、服务器端、数据库或层等。</li></ul></li><li>连接件：<ul><li>连接件是体系结构的一个元素，它可以用于建模：<ul><li>构件之间的相互作用</li><li>控制这些相互作用的规则</li></ul></li></ul></li><li>约束<ul><li>约束描述了体系结构的配置和拓扑要求，配置或拓扑是指构件和连接件组成的一个连接图，它用于描述软件体系结构的构成，确定了体系结构的构件与连接件之间的连接关系：<ul><li>正确的连接性</li><li>并发和分布性</li><li>符合设计的启发式和风格规则</li></ul></li></ul></li></ul></li><li>软件体系结构优势：<ul><li>易理解</li><li>可重用</li><li>控制成本</li><li>可分析性</li></ul></li></ul><h2 id="4-9-软件详细设计"><a href="#4-9-软件详细设计" class="headerlink" title="4.9 软件详细设计"></a>4.9 软件详细设计</h2><ul><li>目标：<ul><li>详细设计阶段具体地设计所要求的系统，得出新系统的软件详细规格。同时，要求设计出的规格简明易懂，便于下一阶段用某种程序设计语言在计算机上实现。 </li><li>如何高质量地完成详细设计是提高软件质量的关键。</li></ul></li><li>任务：<ul><li>算法过程的设计;</li><li>数据结构的设计;</li><li>数据库物理设计;</li><li>信息编码设计;</li><li>测试用例的设计;</li><li>其他设计：网络、输入输出等</li><li>编写“详细设计说明书” 。</li></ul></li><li>结构化程序的详细设计技术的特点：<ul><li>自顶向下，逐步求精</li><li>单入口、单出口的三种基本流程控制结构</li></ul></li><li>程序流程图<ul><li>优点：直观、灵活、易使用，便于初学者掌握</li><li>缺点：程序流程图本质上并不是逐步求精的好工具，它诱使程序设计人员过早考虑程序的控制流程，而不去考虑程序的全局结构；另一方面，用箭头表示控制流方向，可以实现控制流的任意转移，如果使用得当则简单易懂且灵活，否则非结构化的程序流程图可能非常难理解，无法进行修改和维护。同时，程序流程图也不便于表示数据结构。</li></ul></li><li>盒图<ul><li><img src="https://gitee.com/sehowyoung/images/raw/master/202111231953114.png" alt="盒图"></li><li>优点：它强制设计人员使用结构化技术，从而可以保证设计的质量。同时，从盒图上可以直观地看出某一特定控制结构的作用范围，为理解设计意图、编程实现、选择测试用例等带来了方便。在使用时还可附上一个描述数据结构的盒子，使得盒图更加适用于详细设计</li><li>缺点：盒图的修改比较麻烦，且结构嵌套层次较多时不太容易绘制，以致盒图的使用至今仍不流行</li></ul></li><li>判定树和判定表：见前面</li><li>问题分析图<ul><li><img src="https://gitee.com/sehowyoung/images/raw/master/202111231955384.png" alt="常用符号"></li><li>特点：<ul><li>问题分析图强制设计人员采用结构化技术。</li><li>采用树形结构，既克服了程序流程图不能清晰表现程序层次结构的缺点，又不同于盒图将处理约束在一个盒子里而使修改麻烦，并且这种结构为软件的自动生成提供了有力的帮助（树遍历）</li></ul></li></ul></li><li>Jackson程序设计方法<ul><li>Jackson结构程序设计方法（Jackson Structured Programming，JSP）是英国人M.A.Jackson首先提出来的，是一种面向数据结构的结构化程序设计方法。</li><li>该方法通过分析问题的输入、输出数据结构（用Jackson图表示）的对应关系，按一定的映射规则将其映射成软件的过程描述，用Jackson伪代码表示。</li><li><img src="https://gitee.com/sehowyoung/images/raw/master/202111231958762.png" alt="Jackson图"></li><li><img src="https://gitee.com/sehowyoung/images/raw/master/202111231959892.png" alt="Jackson伪代码"></li><li>步骤：<ul><li>分析并确定问题的输入和输出数据结构，并用Jackson图表示。 </li><li>找出输入和输出数据结构中有对应关系的数据单元。 </li><li>将数据结构映射为程序结构。</li><li>列出完成程序结构图中各处理框功能的全部操作，以及有关条件，并将它们分配到程序结构图的适当位置。 </li><li>用Jackson伪代码写出与程序结构图相对应的过程性表示。</li></ul></li></ul></li><li>Wariner图<ul><li><img src="https://gitee.com/sehowyoung/images/raw/master/202111232000138.png" alt="Wariner图"></li><li>步骤：<ul><li>分析和确定问题的输入和输出数据结构，并用Warnier图来表示；</li><li>从数据结构（特别是输入数据结构）导出程序的处理结构，用Warnier图表示；</li><li>将程序结构改用程序流程图表示；</li><li>根据上一步得出的程序流程图，写出程序的详细过程性描述</li></ul></li></ul></li><li>面向对象程序的详细设计<ul><li>面向对象程序的核心概念是类，具有三种基本特性：封装、继承、多态</li><li>封装性：类的封装性使得数据和操纵数据的算法（函数或过程）紧密地捆绑在一起，这样就可以使得操纵数据的函数或过程的作用域和可视性限制在软件系统的局部区域内</li><li>继承性：在面向对象程序设计中，允许某个类继承其它类的成员函数或数据成员。被继承的类称为基类、父类或超类，继承的类称为派生类或子类</li><li>多态性：多态性使得相关的类可有同名的函数，这个同名的函数根据不同类产生不同的结果。换言之，不同类的对象可以具有相同的接口，这些相同的接口自然会呈现出不同的行为。通过多态性程序设计，可以编写并编译代码以处理未知类型的对象。</li><li>设计原则：<ul><li>可复用性:保证方法的内聚性;减少一个方法的代码规模;保持方法对外接口的一致性;分离策略（控制）方法和实现方法;方法应均匀覆盖数据；加强封装性；减少方法的耦合性。 </li><li>可扩展性：封装数据；封装方法内部的数据结构；避免情况分支语句；区分公有方法和私有方法。</li><li>健壮性 ：防止输入错误 （围栏）；把握优化代码的时机；检查参数的合法性；选择适当的实现方法。</li><li>协作性：对类进行详细的文档化；把类打包成模块；尽量使得代码容易理解；等等</li></ul></li></ul></li></ul><h1 id="第五章-软件验证技术"><a href="#第五章-软件验证技术" class="headerlink" title="第五章 软件验证技术"></a>第五章 软件验证技术</h1><ul><li>进行软件验证的方式大体有两种：测试和证明</li><li>测试又分静态测试和动态测试两种。 </li><li>静态测试，又称评审，是对软件进行的一种分析和检查活动。 </li><li>动态测试是通过运行软件来检验其动态行为和运行结果的正确性。 </li><li>证明是一种通过形式化的数学方法来确保软件正确性的活动。</li><li>软件测试是<strong>确保软件质量</strong>和降低软件成本的重要手段，<u>涉及软件的整个生存周期</u></li></ul><h2 id="5-1-软件测试基础"><a href="#5-1-软件测试基础" class="headerlink" title="5.1 软件测试基础"></a>5.1 软件测试基础</h2><ul><li><p>软件测试≠程序测试</p></li><li><p>软件测试对象：软件生存周期各阶段<strong>文档和代码</strong></p></li><li><p>据美国一家公司统计：64%的错误属于分析和设计的错误，<strong>编码错误只占36%。</strong></p></li><li><p>软件测试<strong>不是打消软件工程师积极性</strong>的过程，而是同软件分析与设计一样，是为了建成高质量的软件，只不过是从不同的侧面进行罢了。</p></li><li><p>软件测试试图以<strong>最少的代价</strong>发现软件分析、设计和编码中存在的各种不同类型的<strong>错误</strong>，从而提高软件<strong>质量</strong>，降低软件<strong>成本</strong>。</p></li><li><p>测试原则:</p><ul><li>测试应“尽早地和不断地进行”。</li><li>较早确定测试计划，严格执行测试计划。</li><li>注意错误的群集现象和应用Pareto原则。</li><li>测试规模应从小到大。</li><li>测试应一般由独立的第三方进行。</li><li>应保证测试用例的完整性和有效性。</li><li>应保存所有测试用例和出错统计等，直至软件不用为止。</li></ul></li><li><p>测试工具:一种测试软件，开发人员借助它可以提高软件测试工作的效率</p><ul><li>按工作方式分类:静态测试工具和动态测试工具</li><li>按功能分类:测试计划工具——支持制订测试计划；测试设计与开发工具——支持测试数据生成等；测试执行工具——支持特定的测试方法，支持回归测试等；测试评价工具——报告测试覆盖情况；测试管理工具——协助进行测试组织工作；以及其它辅助测试工具等</li></ul></li><li><p>典型软件测试工具</p><ul><li>静态分析工具<ul><li>通过扫描被测程序的正文，对其数据流和控制流进行分析，然后送出测试报告。</li><li>主要功能包括：变量检查、逻辑结构检查、接口检查、编程风格检查和静态特性统计等，通过建立交叉引用表的方式等实现。</li></ul></li><li>动态测试工具<ul><li>通过对被测程序有控制地运行，自动地监视、记录和统计被测程序的运行情况。</li><li>主要功能包括：语句执行次数统计、执行开销估算、CPU执行时间分析和软硬件资源利用分析等。</li></ul></li><li>测试数据自动生成程序<ul><li>用来为被测程序自动产生测试输入数据。这样，一方面可以减轻生成大量测试数据的负担，另一方面可以避免人为的偏见。对于预期结果，可以利用手工计算等得到</li><li>按生成测试数据的方式来分有：路径测试数据生成程序、随机测试数据生成程序、根据数据规格说明生成测试数据等</li></ul></li><li>文档比较程序<ul><li>用来自动检查测试结果。 </li><li>其检查过程一般主要由三步组成；首先建立一个存放预期结果的文件；然后执行测试，并把测试结果存进另一文件；最后，使用文件比较程序比较上述两个文件，打印出有差异者的情况</li></ul></li></ul></li><li><p>测试组织</p><ul><li>一般来讲，独立测试之前，软件开发者应负责对程序单个模块测试，以保证每个模块能完成详细设计的功能等。</li><li>在很多情况下，软件开发者也进行集成测试，以保证每个模块能按总体设计的要求形成整个软件系统。</li><li>在系统形成之后，独立测试小组才开始介入，同时为了保证测试顺利进行，在测试过程中，开发人员必须协助。独立测试应确保系统满足需求分析的要求和用户意图。</li></ul></li><li><p>测试与调试</p><ul><li>测试是查找错误症状的过程</li><li>调试则是查找错误症状原因并改正错误的过程</li></ul></li><li><p>动态测试步骤</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/202111232034021.png" alt="动态测试步骤"></p></li></ul><h2 id="5-2-代码复审"><a href="#5-2-代码复审" class="headerlink" title="5.2 代码复审"></a>5.2 代码复审</h2><ul><li>代码复审一般在程序通过编译（如查找语法等错误）及静态分析工具检查（如找出程序在结构、编码标准与风格等方面的错误）之后，在动态测试之前进行。 </li><li>代码复审是一种人工进行的测试，可以由程序作者本人非正式地进行，也可以由审查小组以开会的方式进行。</li><li>代码复审的主要方法有：代码会审、走查、办公桌检查。 </li><li>经验表明，代码复审是一种非常有效的程序验证技术，该方法能够有效地发现30%到70%的逻辑设计和编码错误。</li><li>内容:<ul><li>对源程序代码进行的复审主要着重于检查编码实现是否完备、正确等。 </li><li>在复审过程中，可以对照有关条例或错误检验表，查找程序在结构、功能、编码标准和风格等方面的错误或提出质疑。</li><li><img src="https://gitee.com/sehowyoung/images/raw/master/202111232036776.png" alt="代码复审内容条例举例"></li><li><img src="https://gitee.com/sehowyoung/images/raw/master/202111232037515.png" alt="错误检验表一般内容"></li></ul></li><li>代码会审<ul><li>会审小组一般由4人左右组成，包括组长1人，程序作者1人，其他程序员（或测试员）1~2人。会审小组通过对评审材料阅读、讨论和争议，对程序代码进行检查。 </li><li>会前，小组负责人将待评审的材料及有关附件发放给与会者，以熟悉有关内容。 </li><li>会上，程序作者逐句朗读并讲解程序代码，其他人则集中精力对照有关条例或检查表，捕捉程序可能存在的问题，也可以展开讨论。 </li><li>会后，应把查出的问题清单交给程序作者处理，作者处理完后交回组长。如果问题很多，或者程序改动较大，则在改正后应再次组织会审。</li><li><strong>会审一方面可使得同行之间相互启发从而更易于发现错误，另一方面有利于互相学习、交流经验、取长补短，以进一步提高软件开发质量和效率。</strong></li></ul></li><li>走查<ul><li>会前，发放有关材料给与会者进行熟悉，并至少指定一人设计测试用例。 </li><li>会上，与会者扮演计算机角色，人工“执行”被测程序。通过将测试用例“输入”被测程序，对程序的逻辑和功能提出各种疑问，并进行有关的讨论和争议，以发现程序中存在的问题。 </li><li>会后的处理同代码会审相同 。</li></ul></li><li>办公桌检查<ul><li>办公桌检查可以看成是由一个人进行的代码复审。 </li><li>程序作者在程序通过编译之后，进行单元测试之前，对源代码进行分析、检验，并补充有关文档，以发现程序中的错误。</li><li>其方式可以按照错误检验表来分析被查程序，也可以仿照走查对程序进行人工“执行”。 </li></ul></li></ul><h2 id="5-3-白盒测试"><a href="#5-3-白盒测试" class="headerlink" title="5.3 白盒测试"></a>5.3 白盒测试</h2><ul><li>白盒测试是一种以程序的内部逻辑结构为依据设计测试用例的方法，因而又称结构测试或玻璃盒测试。</li><li>合理的白盒测试就是要选取足够的测试用例，对源代码实行比较充分的覆盖，以便尽可能多地发现程序中的错误。（原因：穷举测试不合理）。</li><li>主要有两种方法：一种称为逻辑覆盖法，另一种称为路径覆盖法。除此外，对循环的测试，可采用循环覆盖法。 </li></ul><h3 id="5-3-1-逻辑覆盖法"><a href="#5-3-1-逻辑覆盖法" class="headerlink" title="5.3.1 逻辑覆盖法:"></a>5.3.1 逻辑覆盖法:</h3><ul><li><p>内容:</p><ul><li>语句覆盖：测试用例能使被测程序的每条执行语句至少执行一次。</li><li>判定覆盖：测试用例能使被测程序中的每个判定至少取得一次“真”和一次“假”。又称分支覆盖。</li><li>条件覆盖：测试用例能使被测程序中每个判定的每个条件至少取得一次“真”和一次“假”。如果判定中只有一个条件，则条件覆盖便满足判定覆盖，否则，不一定。</li><li>判定/条件覆盖：测试用例既满足判定覆盖，又满足条件覆盖。</li><li>条件组合覆盖：测试用例使每个判定中所有可能的条件取值组合至少执行一次。</li></ul></li><li><p>步骤:</p><ul><li>选择逻辑覆盖程度类型；</li><li>选择测试路径以满足选定的覆盖程度；</li><li>选择测试输入数据以满足选定的测试路径和覆盖程度；</li><li>根据测试输入数据和测试路径计算预期结果。</li></ul></li></ul><h3 id="5-3-2-基本路径覆盖法"><a href="#5-3-2-基本路径覆盖法" class="headerlink" title="5.3.2 基本路径覆盖法:"></a>5.3.2 基本路径覆盖法:</h3><ul><li>逻辑覆盖法并没有检测程序的所有执行路径。 </li><li>基本路径测试是T.McCabe（音译：麦凯伯）首先提出的一种白盒测试技术。所谓基本路径是指程序中至少引进一条新的语句或一个新的条件的任一路径。 </li><li>循环处理在计算路径时只计算一次。</li><li>基本路径测试法是在<strong>程序图</strong>的基础上，通过分析环形复杂性，导出基本路径集，然后设计测试用例使基本路径集中的每条路径至少经过一次。 </li><li>步骤:<ul><li>以详细设计结果或源程序代码为基础，导出程序图；（注意应将复合条件判定转化为单一条件判定）。</li><li>计算程序图的环形复杂度；（可以采用图形矩阵方法计算，也可采用其它方法来计算）。</li><li>确定基本路径集；（基本路径集的路径数就是环形复杂度大小）。</li><li>生成测试用例，使基本路径集中的每条路径至少经过一次。</li></ul></li></ul><h3 id="5-3-3-循环覆盖法"><a href="#5-3-3-循环覆盖法" class="headerlink" title="5.3.3 循环覆盖法"></a>5.3.3 循环覆盖法</h3><ul><li>逻辑覆盖法和基本路径覆盖法对于循环只进行了循环一次的测试，显然是不充分的。而循环是大多数软件实现算法的关键部分，因此对循环的测试是十分重要的。</li><li>对于结构化程序而言，循环主要有三种：<ul><li>简单循环<ul><li><img src="https://gitee.com/sehowyoung/images/raw/master/202111232057052.png" alt="简单循环"></li><li>对于简单循环，假设n是循环的最大次数，则可以采用如下策略设计测试用例：<ul><li>整个跳过循环，即循环0次；</li><li>只有一次通过循环，即循环1次；</li><li>循环2次；</li><li>循环m次，其中m＜n；</li><li>分别循环n-1，n和n+1次。</li></ul></li></ul></li><li>嵌套循环<ul><li><img src="https://gitee.com/sehowyoung/images/raw/master/202111232058610.png" alt="嵌套循环"></li><li>对于嵌套循环，可以采用如下策略来导出测试用例：<ul><li>从最内层循环开始，其他循环设置为最小次数循环；</li><li>对最内层循环使用简单循环策略，并为范围外或排除的值增加其他测试；</li><li>由内向外构造下一个循环的测试，使其外层循环为最小次数，其内部嵌套循环为“典型”次数，直到所有循环测试完</li></ul></li></ul></li><li>串接循环<ul><li><img src="https://gitee.com/sehowyoung/images/raw/master/202111232059541.png" alt="串接循环"></li><li>对于串接循环，如果串接循环的循环都彼此独立，则可以采用简单循环的测试策略；如果循环不独立，如第二个循环变量的初始值是外层第一个循环变量的当前值，则应使用嵌套循环的测试策略。</li></ul></li></ul></li></ul><h2 id="5-4-黑盒测试"><a href="#5-4-黑盒测试" class="headerlink" title="5.4 黑盒测试"></a>5.4 黑盒测试</h2><ul><li><p>黑盒测试又称功能测试、数据驱动测试等，它将待测试对象看成是一个黑盒子，不考虑程序内部的逻辑结构和特性，只依据规格说明书检查程序的功能是否能正常使用。</p></li><li><p>通常，白盒测试用于测试的早期，而黑盒测试由于不需了解程序内部情况，因而被许多后期测试（如确认测试、系统测试）采用</p></li><li><p>黑盒测试常发现错误类型:</p><ul><li>功能错误：表现在功能不正确或功能遗漏或实现了不该实现的功能等。</li><li>接口错误：表现在不能正确地接收信息或输出信息。</li><li>数据错误：表现在数据结构错误或外部信息（如数据文件）访问错误。</li><li>性能错误：表现在性能需求得不到满足。</li><li>初始化或终止错误：表现在不能进行正确的初始化或终止。</li></ul></li><li><p>测试用例设计方法:</p><ul><li><p>等价分类法</p><ul><li>等价分类法将所有可能的<strong>输入数据</strong>（有效的或无效的）<strong>划分成若干个等价类，然后从每个等价类中选出一个作为“代表”形成测试用例</strong>。</li><li>假定：<strong>等价类中的所有数据对于暴露程序中的错误是等效的</strong>。</li><li>在确定输入数据的等价类时常要分析输出数据的等价类，以便根据输出数据的等价类导出对应的输入数据等价类。</li><li>等价类划分指南:<ul><li>如果输入条件规定了一个<strong>取值范围或值的个数</strong>，则可以定义一个有效等价类和两个无效等价类。</li><li>如果输入条件是一个<strong>布尔量</strong>，则可以确定一个有效等价类和一个无效等价类。</li><li>如果规定了<strong>输入值的集合</strong>，或者规定了“必须如何”的条件，则可以定义一个有效等价类和一个无效等价类。</li><li>如果规定了<strong>输入数据必须遵守的规则</strong>，则可以定义一个有效等价类（符合规则）和若干无效等价类（从不同角度违反规则）。</li><li>如果规定了<strong>输入数据的一组值</strong>，而且程序对<strong>不同输入值做不同</strong>处理，则可以定义若干有效等价类（每个值一个有效等价类）和一个无效等价类。</li><li>如果确知已划分的<strong>等价类中各元素在程序中的处理方式是不同</strong>的，则应将此等价类进一步划分成更小的等价类。</li></ul></li><li>步骤:<ul><li>划分等价类，形成<strong>等价类表</strong>；</li><li>为每个等价类规定一个唯一的<strong>编号</strong>；</li><li>设计一个新的测试用例，使其尽量多地覆盖尚未被覆盖的<strong>有效等价类</strong>，重复这一步，直到所有的有效等价类都被覆盖为止。</li><li>设计一个新的测试用例。使其覆盖一个而且只覆盖一个<strong>无效等价类</strong>，重复这一步，直到所有无效等价类均被覆盖为止。</li></ul></li></ul></li><li><p>边界值分析法</p><ul><li>边界值分析法主要用来选择等价类边界值作为测试用例检查程序边界运行情况，是一种补充等价分类法的测试用例设计技术。</li><li>通常，输入等价类和输出等价类的边界情况是测试的重点，应当选择正好等于，刚刚小于和刚刚大于边界的值作为测试数据</li><li>指南:<ul><li>如果输入条件代表以a和b为边界的范围，则测试用例应当包含a、b、略小于下界a，略大于上界b的值。</li><li>如果输入条件规定了值的个数，则用最大个数、最小个数、比最大个数多1，比最小个数少1的数作为测试数据。</li><li>上述两条指南对输出条件也适用。</li><li>如果程序的规格说明中给出的输入和输出域是有序集合（如有序表），则应选取集合的第一个元素和最后一个元素作为测试数据。</li><li>如果程序数据结构有预定义的边界（如数组有100项，下标下界是0，上界是99），则应选择测试数据测试其边界的数据项。</li></ul></li></ul></li><li><p>猜错法</p><ul><li><p>猜错法能充分发挥人的经验和直觉，在一个测试小组中集思广益，方便实用，特别是在软件测试基础较差的情况下，很好地组织测试小组（也可包括外来人员）进行错误猜测，是一种很有效的测试方法</p></li><li><p>例子:</p><p>测试一个排序程序，可先用边界值分析法设计以下的测试用例：①排序序列为空；②排序序列仅有一个数据；③排序序列为满序列数据。然后，再用猜错法补充以下测试用例：④排序序列已经按要求排好序；⑤排序序列的顺序与要求的顺序恰好相反；⑥排序序列中的所有数据全部相等；等等</p></li></ul></li><li><p>因果图法</p><ul><li>因果图法借助图形来设计测试用例，特别适用于被测程序具有多种输入条件，程序的输出又依赖于输入条件的各种组合的情况。</li><li><img src="https://gitee.com/sehowyoung/images/raw/master/202111232144249.png" alt="因果图"></li><li>步骤:<ul><li>分析程序规格说明中哪些是原因，哪些是结果。原因常常是输入条件或输入条件的等价类，结果则是输出条件。</li><li>分析程序规格说明中描述内容的语义和限制，找出两类关系，画出因果图。</li><li>把因果图转换成判定表。</li><li>对判定表的每一列写成一个测试用例</li></ul></li></ul></li></ul></li><li><p>黑盒法综合策略</p><ul><li>首先用边界值分析法设计测试用例；</li><li>必要时用等价分类法补充测试用例；</li><li>必要时再用猜错法补充测试用例；</li><li>如果在程序的说明中含有输入条件的组合，宜在一开始末就采用因果法，然后再按上述步骤进行。</li></ul></li></ul><h2 id="5-5-单元测试"><a href="#5-5-单元测试" class="headerlink" title="5.5 单元测试"></a>5.5 单元测试</h2><ul><li><p>单元测试又称模块测试或分调，是动态测试中的第一步，通常在<strong>编码阶段</strong>进行。</p></li><li><p>单元测试集中检查软件设计的最小单元——<strong>模块</strong>，即程序中最小的独立编译单位。在源程序代码经过编译、评审，确认没有语法错误之后，便可开始进行单元测试的测试用例设计，以发现程序内部逻辑结构的错误。</p></li><li><p>单元测试可以由<strong>程序作者</strong>进行，也可以由<strong>同行</strong>互测对方的单元进行。</p></li><li><p>测试策略:</p><p>单元测试一般总是把白盒法和黑盒法结合运用。先用黑盒法设计出一组基本的测试用例，然后用白盒法，根据覆盖标准要求补充新的测试用例满足覆盖标准。在一般情况下，单元测试应以白盒法为主。</p></li><li><p>作用:</p><ul><li>采用从单元开始而不是对整个程序进行测试，一方面可以减少测试工作的复杂性，另一方面容易进行错误定位和纠错。同时，对多个模块的测试可以并行地进行，从而缩短测试的周期。 </li><li>性价比好</li></ul></li><li><p>内容:考察模块的接口和内部结构，检查是否符合程序规格说明（即详细设计说明书）的要求</p><ul><li>模块的接口:进出数据是否正确</li><li>局部数据结构:检查局部数据结构能否保持完整性</li><li>重要的执行通路:检查由于计算错误、判定错误、控制流错误导致的程序错误</li><li>出错处理路径:检查内部错误处理设施是否有效</li><li>影响以上各项的边界条件:检查临界数据是否正确处理</li></ul></li><li><p>测试的阶段及活动</p><ul><li>善测试计划阶段<br> (制定方法、资源及进度的计划;确定需测试的与需求有关的特性；细化计划)</li><li>获得测试用例集阶段<br>（设计测试用例集；执行测试计划及实现设计）</li><li>评价测试单元阶段<br>（执行测试规程；核对终止情况；评价测试效果和被测单元）</li></ul></li><li><p>测试软件</p><ul><li><img src="https://gitee.com/sehowyoung/images/raw/master/202111232204933.png" alt="image-20211123220450883"></li><li>一般地，<strong>驱动模块</strong>应完成接收测试数据，并把数据传给被测模块，然后打印有关结果等任务；<strong>桩模块</strong>应该模拟实际模块完成少量数据处理，并检验和打印入口处的信息，然后将控制返回给被测模块。</li></ul></li></ul><h2 id="5-6-集成测试"><a href="#5-6-集成测试" class="headerlink" title="5.6 集成测试"></a>5.6 集成测试</h2><ul><li><p>集成测试，又称组装测试、综合测试或联调，是在单元测试完成之后，将所有模块按概要设计要求组装成系统的时候进行的测试。</p></li><li><p>主要目标是发现与接口有关的问题。</p></li><li><p>集成测试有组装和检验两重意义，一方面将各经过单元测试的模块拼装起来形成完整可运行的系统；另一方面要检验每一步拼装过程是否正确。</p></li><li><p>测试内容:</p><ul><li>主要检查模块接口和全局数据。 </li><li>检查清单：<ul><li>穿越模块接口的数据是否会丢失；</li><li>一个模块是否对另一个模块产生不利的副作用；</li><li>模块组装后，能否达到预期要求的功能；</li><li>全局数据结构在引用中是否有问题；</li><li>模块的误差积累是否可以接受。</li></ul></li><li>主要内容:<ul><li>接口完整性</li><li>功能有效性</li><li>数据一致性</li><li>性能</li></ul></li></ul></li><li><p>测试策略:</p><ul><li>集成测试一般应由<strong>独立的测试小组</strong>进行，由测试小组提出测试用例，记录测试结果，并编制测试报告。</li><li>测试用例的设计通常采用黑盒法，其实施策略又分为<strong>非渐增式</strong>和渐增式两种。 </li><li>在模块组装起来后，新的数据流路径建立起来了，新的控制逻辑可能激活了等等。这些改变可能会使原本工作正常的功能产生错误，因此，应对某些已经进行过的测试的测试用例再重新执行一遍，以保证上述改变不会传播意外的副作用，称之为<strong>回归测试</strong>。</li></ul></li><li><p>非渐增式:</p><ul><li>采用非渐增式测试，一般应先经过单元测试，然后再把所有模块一次性组装在一起进行测试，最终得到要求的软件系统。 </li><li>将模块一次性组装在一起运行成功的可能性并不大。其结果往往是发现有错误，但由于程序中模块一次性引入过多，难于进行错误定位。同时，一旦修正错误之后，新的错误很可能马上会出现。 </li><li>除规模很小的程序，一般很少采用此种测试策略。</li></ul></li><li><p>渐增式:</p><ul><li><p>渐增式测试采用逐步加入模块或功能簇的方式进行，在加入过程中边连接边测试，比较容易定位和修正错误，且接口也可以更容易进行彻底地测试。</p></li><li><p>按照添加模块的方式，又可分为自顶向下的渐增测试和自底向上的渐增测试</p></li><li><p>自顶向下的渐增式</p><ul><li><p>首先集成主控模块，然后按照软件结构的控制层次自上而下进行集成，把主控模块的直接（或间接）调用模块按深度优先或广度优先的方式集成到整个软件结构中。</p></li><li><p>步骤:</p><ol><li>以主控模块为被测模块兼驱动模块，所有被主控模块直接调用的下层模块全部用桩模块代替，对主控模块进行测试。</li><li>根据集成的实现方法（如深度或广度优先），用实际模块替换相应桩模块，再用桩模块代替它们的直接下属模块。</li><li>在每一个模块集成的时候都要进行测试。</li><li>进行回归测试（即重新执行以前做过的全部测试或部分测试），排除组装过程中引入新的错误。</li><li>重复(2)～(4)，直到所有的模块都已组装到系统中</li></ol></li><li><p>特点:</p><ul><li>能较早地显示整个程序的轮廓，对增强开发人员的信心，取得用户的支持，有重要的作用；</li><li>只需编写桩模块供测试用，驱动模块可以利用实际模块；</li><li>能尽早发现主要控制中的问题，减少以后的返工；</li><li>可先对逻辑输入的分支进行组装和测试，检查和克服潜藏的错误，为其后对主加工分支的组装和测试提供了保证；</li><li>由于每添加一个新模块，就进行一次测试，这样虽然耗费一些时间，但却使被测程序测试更彻底，尤其是上层模块。</li></ul></li><li><p>存在逻辑次序问题:最常见的是出现在当高层测试需要首先对较低层次进行足够测试后才能完成的时候。为了能够准确地实施测试，应当让桩模块正确而有效地模拟下层被调模块的功能和合理的接口，不能是只包含返回语句或只显示该模块已调用信息，不执行任何功能的哑模块。</p><p>解决方法:把测试推迟到桩模块用实际模块替代之后进行，或者采用自底向上组装和测试软件</p></li></ul></li><li><p>自底向上的渐增式测试</p><ul><li>步骤:<ol><li>把低层模块组合成实现某个特定的子功能的模块簇，并用编写的驱动模块控制它进行测试；可以对若干功能簇并行进行测试；</li><li>用实际模块换掉驱动模块，沿软件结构自下而上移动，把子功能簇组合起来形成更大的子功能簇，并进行测试；</li><li>重复(2)直到所有模块组装完毕</li></ol></li><li>特点:<ul><li>不能在测试的早期显示出程序的轮廓。程序的总体结构，要等到加入最后一个模块时才能最终形成；</li><li>测试软件只需要驱动模块，不需要桩模块，而且随着组装层次的上移，驱动模块将大为减少（在多数情况下，编写驱动模块要比桩模块容易）；</li><li>由于从低层模块开始组合，所以较易产生测试用例</li></ul></li></ul></li><li><p>混合的渐增式测试</p><ul><li>对上层模块采取自顶向下测试，使之能较早地显示系统的总体轮廓；</li><li>对某些关键模块或子系统采用由底向上组装和测试的方法，以便一方面能减少对模块的重复测试次数，另一方面能较容易产生测试用例。 </li></ul><p>注:这里所谓的关键模块是指：（1）具有输入/输出功能的模块。（2）有重要功能、性能或含有新算法的模块。</p></li></ul></li><li><p>回归测试</p><ul><li>采用软件改动前测试时执行过的测试用例对改动后的软件再进行测试。 </li><li>回归测试的测试用例有三种不同类型：<ul><li>能够测试软件的所有功能的代表性测试用例；</li><li>针对可能会被修改所影响的软件功能而进行附加测试的测试用例；</li><li>针对修改过的软件成分进行测试的测试用例。</li></ul></li></ul></li></ul><h2 id="5-7-确认测试"><a href="#5-7-确认测试" class="headerlink" title="5.7 确认测试"></a>5.7 确认测试</h2><ul><li>所谓确认测试就是验证所开发软件的功能和性能及其他特性是否符合软件需求规格说明书的要求。所以，确认测试又称之为有效性测试。</li><li>一般在模拟的环境（也可能就是开发的环境）下，运用黑盒法进行测试。</li><li>确认测试是由软件开发单位组织进行的最后一次测试，也是把软件交给用户，进行正式的安装和验收之前所作的一次重要的准备。为了确保测试质量，一方面应组织独立的测试小组进行测试，另一方面吸收任务委托单位及用户代表参加测试，以提高测试的可信度。同时，应将测试中发现的错误填入问题清单，交开发者处理。</li><li>确认测试内容:<ul><li>功能测试；</li><li>性能测试；</li><li>强度测试；</li><li>配置复审</li></ul></li><li>α测试和β测试<ul><li>α测试和β测试的测试方法，用以发现可能只有最终用户才能发现的错误。</li><li>α测试:<ul><li>α测试是由一个用户在开发环境下进行的测试；也可以是开发机构内部的用户在模拟实际操作环境下进行的测试，软件在一个自然设置状态下使用。软件在开发者对用户的“指导”下进行测试，开发者负责记录错误和使用中出现的问题。显然，α测试是在一个受控的环境中进行。</li><li>α测试的目的是评价软件产品的功能（F）、局域化（L）、可使用性（U）、可靠性（R）、性能（P）和支持（S）等方面的特性，尤其注重产品的界面和特色。</li><li>α测试可以从软件编码结束之时开始，或在模块或集成测试完成之后开始，也可以在确认测试过程中产品达到一定的稳定和可靠程度之后再开始。</li></ul></li><li>β测试:<ul><li>β测试是由软件的最终用户（多个）在一个或多个用户场所来进行。这些用户是与软件厂商签定了支持产品预发行合同的外部客户，要求用户使用该产品，并愿意返回有关问题给开发者。一般地，β测试时开发者通常不在测试现场，软件是在开发者不能控制的现场中应用。</li><li>在β测试中，由用户负责记下遇到的所有问题，包括主观认定的和真实的问题，定期向开发者报告，开发者在综合用户的报告之后进行修改，最后将软件产品交付给全体用户使用。</li><li>只有当α测试达到一定的可靠程度时，才能开始β测试。</li><li>β测试的主要目标是测试可支持性，包括文档、客户培训等。一般β测试应尽可能由主持产品发行的人员来管理。 </li></ul></li></ul></li></ul><h2 id="5-8-系统测试"><a href="#5-8-系统测试" class="headerlink" title="5.8 系统测试"></a>5.8 系统测试</h2><ul><li>系统测试是在更大范围内进行的测试，它将经过确认测试的软件作为整个基于计算机的系统的一个元素，与计算机硬件、外设、支持软件、数据和人员等其他系统元素结合在一起，在实际运行环境下，对系统进行的一系列集成和确认测试。</li><li>系统测试通常由任务委托单位或用户组织的验收小组负责，一般应根据需求分析说明书来设计测试用例，在实际使用环境中运行。</li><li>系统测试的内容对不同的系统各不相同</li><li>恢复测试<ul><li>恢复测试就是要通过各种手段，让软件强制性地发生故障，然后验证恢复是否能正常进行的一种系统测试方法。 </li><li>如果系统的恢复是自动的（由系统本身来进行），则应对重新初始化、数据恢复、重新启动等逐个进行正确性评价。</li><li>如果恢复需要人工干预，则需对修复的平均时间进行评估以判定它是否在允许的范围之内。</li></ul></li><li>安全性测试<ul><li>安全测试用来验证集成在系统内的保护机制是否能够在实际中保护系统不受到非法侵入。 </li><li>主要破坏方法:①攻击易受损坏的部分，破坏安全性；②有目的地引发系统出错，期望在系统恢复过程中侵入系统；③通过各种手段，获取系统的密码；④浏览非保密数据，从中找到进入系统的方法；等等。</li><li>若有足够的时间和资源，好的安全性测试应能最终侵入系统。</li><li>系统设计者的任务是：把系统设计为攻破系统的代价远大于攻破系统后从中得到的好处。</li></ul></li><li>可用性测试:主要从使用的方便性、易理解性和易学性等方面对系统进行检查，以发现人为因素或使用习惯等的问题。</li><li>安装测试:要找出系统安装过程中出现的问题</li><li>互联测试:验证两个或多个不同的系统之间的互操作性。这类测试对支持标准规格说明，或承诺支持与其他系统互连的软件系统有效</li></ul><h2 id="5-9-调试"><a href="#5-9-调试" class="headerlink" title="5.9 调试"></a>5.9 调试</h2><ul><li><p>调试，又称纠错或排错，是程序测试后开始的工作，<strong>主要任务是依据测试发现的错误迹象确定错误位置和原因，并加以改正</strong>。</p></li><li><p>调试活动由两部分组成：</p><ul><li>确定程序中可疑错误的确切性质和位置。</li><li>对程序（设计，编码）进行修改，排除这个错误。</li></ul></li><li><p>调试是通过现象，找出原因的一个思维分析的过程</p></li><li><p>步骤:</p><ul><li>从错误的外部表现形式入手，确定程序中出错位置；</li><li>研究有关部分的程序，找出错误的内在原因；</li><li>修改设计和代码，以排除这个错误；</li><li>重复进行暴露了这个错误的原始测试或某些有关测试，以确认该错误是否被排除；是否引进了新的错误。</li><li>如果所做的修正无效，则撤消这次改动，重复上述过程，直到找到一个有效的解决办法为止。</li></ul></li><li><p>难点:</p><ul><li>错误的症状和引起错误的原因可能相隔很远，尤其是在高度耦合的程序结构中；</li><li>错误症状可能在另一错误被纠正后消失或暂时性的消失；</li><li>错误症状可能实际并不是由错误引起的（如舍入误差）；</li><li>错误症状可能是由不易跟踪的人工操作引起的；</li><li>错误症状可能是和时间相关的，而不是处理问题；</li><li>很难再现产生错误症状的输入条件；</li><li>错误症状可能时有时无（如在软硬件结合的嵌入式系统中常常遇到）；</li><li>错误症状可能是由于把任务分布在若干不同处理器上运行而造成。 </li></ul></li><li><p>调试的策略:</p><ul><li><p>猜想法:该方法通过分析错误症状，根据以往经验，辅助使用已有的计算机工具，猜测错误的原因并进行定位。可以通过“在程序中插入打印语句”、“使用注释或GOTO语句运行部分程序”或“调试工具”等来实现该方法。</p></li><li><p>跟踪法:先分析错误征兆，确定最先发现“<strong>症状</strong>”的位置。然后，人工<strong>沿程序的控制流程</strong>，向回追踪源程序代码，直到找到<strong>错误根源</strong>或确定<strong>错误产生的范围</strong>。</p><p>跟踪法对于<strong>小程序很有效</strong>，往往能把错误范围缩小到程序中的一小段代码；仔细分析这段代码不难确定出错的准确位置。但对于大程序，由于回溯的路径数目较多，回溯会变得很困难。</p></li><li><p>演绎法:演绎法排错是测试人员首先根据已有的测试用例，设想及枚举出所有可能出错的原因做为假设；然后再用原始测试数据或新的测试，从中逐个排除不可能正确的假设；最后，再用测试数据验证余下的假设确是出错的原因。</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/202111232238210.png" alt="image-20211123223831158"></p></li><li><p>归纳法:基本思想是：从一些线索（错误征兆）着手，通过分析它们之间的关系来找出错误。</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/202111232239524.png" alt="image-20211123223916473"></p></li></ul></li><li><p>调试的原则:</p><ul><li><strong>冷静多思</strong>。调试是软件开发过程中最艰巨的脑力劳动之一。错误症状同错误原因之间往往没有明显的联系。这就要求调试人员要有耐心，并且细心，在面临困惑的情况下虚心向同行请教。</li><li><strong>彻底修改</strong>。一方面应注意其周围是否存在类似的其它错误，即考虑错误的群集现象；另一方面要纠正错误本身而不是其症状。</li><li><strong>防止引入新的错误</strong>。进行回归测试是一种较好的办法。</li></ul></li></ul><h1 id="第六章-软件维护技术"><a href="#第六章-软件维护技术" class="headerlink" title="第六章 软件维护技术"></a>第六章 软件维护技术</h1><h2 id="6-1-软件维护的基本概念"><a href="#6-1-软件维护的基本概念" class="headerlink" title="6.1 软件维护的基本概念"></a>6.1 软件维护的基本概念</h2><ul><li><p>所谓软件维护是指软件交付使用之后，为了改正错误或满足新的需求等而修改软件以达到延长软件寿命为目的的过程。 </p></li><li><p>软件维护阶段的长短决定了软件寿命的长短；</p></li><li><p>软件维护阶段的费用占软件总成本的大部分。</p></li><li><p>原因:主要原因是软件维护不是因为使用时软件磨损或老化引起，而是由于软件设计不正确、不完善或使用环境的变化等引起</p></li><li><p>维护类型:</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/202111232243062.png" alt="image-20211123224310994"></p></li><li><p>策略:不同的维护类型需要采用不同的维护策略</p><ul><li>改正性维护:通过使用一些新技术，可以大大减少进行改正性维护的需要.除此之外，还可通过以下方法来减少此类维护活动：<ul><li>利用应用软件包；</li><li>进行防错程序设计；</li><li>提高系统结构化程度；</li><li>进行周期性维护审查。</li></ul></li><li>适应性维护:运行环境的变化是不可避免的，但可以控制<ul><li>进行配置管理。把硬件、操作系统和其他相关环境因素的可能变化进行配置管理。</li><li>修改局部化。把因环境变化而必须修改的程序局部于某些程序模块中。</li><li>使用例行程序包等。例如使用内部程序列表等，可为维护性修改程序提供方便</li></ul></li><li>完善性维护:利用前两类维护中列举的方法，可以减少此类维护。另外，使用功能强且易于使用的工具和通过用户使用系统原型模型完整地确定系统需求等可以减少完善性维护的工作量。</li><li>预防性维护:可通过采用提前实现或软件重用等手段或技术来减少此类维护活动的工作量</li><li>支援性维护:可通过提供最新用户文档或联机用户文档，进行适当的用户培训或设立专门的维护人员等方式来减少此类维护活动。</li></ul></li><li><p>软件维护成本:软件维护活动所花费的工作量占软件整个生存期工作量的70%以上</p><ul><li>Boehm模型:<ul><li>$MM<em>{维护}=ACT*MM</em>{开发}*EAF$</li><li>$ACT=(修改的指令数+增加的指令数)/指令总数$</li><li>调节因子EAF</li></ul></li><li>Belady与Lehman模型<ul><li>$M=P+K^{(c-d)}$</li><li>M表示维护所需工作量；</li><li>P表示生产性工作量，如问题分析和评价、修改设计、实现等；</li><li>K表示一个经验常数；</li><li>c表示因未采用结构化方法和缺少文档而增加的软件复杂度；</li><li>d表示维护人员对软件的熟悉程度。</li></ul></li></ul></li><li><p>副作用:指由于修改程序而导致的错误或其它不需要的活动。</p><ul><li>修改代码的副作用</li><li>修改数据的副作用</li><li>修改文档资料的副作用</li></ul></li><li><p>控制副作用:</p><ul><li>按模块把修改分组；</li><li>自顶向下地安排所修改模块的顺序；</li><li>每次修改一个模块；</li><li>对于每个修改了的模块，在安排修改下一个模块之前，要确定这个修改的副作用</li></ul></li><li><p>困难:</p><ul><li>理解别人的程序困难，且困难程度随软件配置成分的减少而迅速增加。</li><li>需要维护的软件往往存在文档资料不全，甚至有文档也不易理解并和程序代码可能不一致。当前，有些软件的文档是在代码形成后为了应付所谓的鉴定而突击出来的。</li><li>大多数软件在开发时没有考虑到将来的维护。</li><li>软件维护被人们看成是一种没有创造性的工作，往往不能引起人们的重视。部分人认为，维护别人的程序不如开发新的程序。</li></ul></li></ul><h2 id="6-2-软件维护过程"><a href="#6-2-软件维护过程" class="headerlink" title="6.2 软件维护过程"></a>6.2 软件维护过程</h2><ul><li><p>软件维护过程:本质上是修改和压缩了的软件定义和软件开发过程。</p></li><li><p>过程</p><ul><li>首先，必须建立一个维护组织，确定提出维护申请的过程及评价的过程，为每个维护申请规定标准的处理步骤。建立维护活动的登记制度，并规定复审标准。</li><li>然后，按维护组织建立的过程进行维护活动。</li></ul></li><li><p>维护组织:</p><ul><li><img src="https://gitee.com/sehowyoung/images/raw/master/202111232253014.png" alt="image-20211123225313959"></li><li>职责:<ul><li>将维护申请提交给<strong>维护管理员</strong>，由维护管理员将其交给某系统的系统管理员去评价。</li><li><strong>系统管理员</strong>是熟悉产品程序的某部分的技术人员。</li><li>系统管理员对维护申请评价后由<strong>修改批准人员</strong>（又称变化授权人）决定如何进行修改。</li><li><strong>维护人员</strong>在系统管理员的指导下修改软件系统。在维护人员对系统进行修改的过程中，<strong>配置管理员</strong>应对软件配置进行审查。</li></ul></li></ul></li><li><p>维护申请</p><ul><li>维护组织通常提供维护申请表（Maintenance Request Form，简写为MRF），由申请维护的用户填写。</li><li>如果是改正性的维护，用户必须完整地说明出错的情况，如输入数据，全部输出信息以及其他有关材料。</li><li>如果申请的是适应性或完善性维护，则应提出一个简短的需求说明书</li></ul></li><li><p>维护工作流程:</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/202111232254465.png" alt="image-20211123225449407"></p></li><li><p>维护记录与评价:</p><ul><li><p>维护记录</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/202111232256112.png" alt="image-20211123225621059"></p></li><li><p>维护评价:</p><ul><li>程序运行失败的平均数；</li><li>于每类维护活动的总人时数；</li><li>平均每个程序、每种语言、每种维护类型所做的程序变动数；</li><li>维护过程中增加或删除一个源程序语句平均花费的人时数；</li><li>维护每种语言所花费的工作量（平均人时数）；</li><li>一张维护申请表的平均周转时间；</li><li>不同维护类型所占百分比。</li></ul></li></ul></li></ul><h2 id="6-3-软件可维护性"><a href="#6-3-软件可维护性" class="headerlink" title="6.3 软件可维护性"></a>6.3 软件可维护性</h2><ul><li><p>软件可维护性是指纠正软件系统中出现的错误或缺陷，以及为满足新的要求进行修改、扩充和压缩软件的容易程度。</p></li><li><p>影响软件可维护性的软件属性:</p><ul><li>可理解性:表现为人们通过阅读源代码和相关文档，理解软件的结构、接口、功能和内部过程的容易程度。 </li><li>可测试性:一个软件容易被测试的程度。 </li><li>可修改性:程序容易修改的程度。</li></ul></li><li><p>软件可维护性的定量度量</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/202111232257521.png" alt="image-20211123225755464"></p></li><li><p>提高可维护性的方法:</p><ul><li>建立明确的软件质量目标和优先级； </li><li>使用提高软件质量的技术和工具； </li><li>进行明确的质量保证审查； </li><li>选择可维护的程序设计语言； </li><li>改进程序文档； </li><li>开发时考虑到维护。</li></ul></li></ul><h2 id="6-4-软件再工程技术"><a href="#6-4-软件再工程技术" class="headerlink" title="6.4 软件再工程技术"></a>6.4 软件再工程技术</h2><ul><li><p>软件再工程（Reengineering）是一类软件工程活动，通过对旧软件(遗留系统)实施处理，以增进对软件的理解，同时又提高了软件自身的可维护性、可复用性等。</p></li><li><p>维护的局限:</p><ul><li>采用新技术所带来的竞争优势受到严重限制；</li><li>维护旧软件的成本随时间不断增加；</li><li>修改越来越困难。</li></ul></li><li><p>逆向工程:软件逆向工程，通过对程序的分析，导出更高抽象层次的表示</p></li><li><p>重构</p><ul><li>软件重构是对源代码和/或数据进行修改，使其易于理解或维护，以适应将来的变更。 </li><li>Arnold总结了软件重构的好处，即：提高了程序的质量；改善了软件生产率；减少了维护工作量；使软件易于测试和调试；等等。</li><li>面向对象软件重构<ul><li>重构（名词）：对软件内部结构的一种调整，目的是在<strong>不改变软件可观察之行为</strong>的前提下提高其可理解性、降低其修改的成本。</li><li>重构（动词）：使用一系列的重构（名词），在<strong>不改变软件可观察之行为</strong>的前提下调整其结构，以达到提高其可理解性、降低其修改成本的目的。</li><li>重构是语义保持的（有测试作为保证）。因此重构只会使软件质量不断变好，不会造成破坏。</li></ul></li><li>工具支持:<ul><li>Refactoring Browser, XRefactory , jFactor工具提供半自动方法实现重构；</li><li>SmallTalk 的VisualWorks V7，Eclipse V2，Together ControlCenter V6，Intellij IDEA V3，Borland JBuilder V7等开发环境有集成的重构工具。</li></ul></li></ul></li><li><p>正向工程</p><ul><li>正向工程也称为改造，用从现存软件恢复设计中得到的信息去重构现存系统，以改善其整体质量。 </li><li>由于软件的原型（现存系统）已经存在，正向工程的生产率将远高于平均水平；同时，又由于用户已对该软件有经验，因而正向工程过程可以很容易地确定新的需求和变化的方向。</li></ul></li><li><p>再工程成本/效益分析</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/202111232302371.png" alt="image-20211123230224315"></p></li><li><p>在工程风险分析</p><ul><li><strong>过程风险</strong>：未进行再工程成本/效益分析或在规定的时间内未达到成本/效益要求；对再工程项目的人力投入缺乏管理；对再工程方案实施缺乏监督等等。</li><li><strong>应用领域风险</strong>：再工程项目缺少本地应用领域专家支持；对源程序中体现的业务知识不熟悉；等等。</li><li><strong>技术风险</strong>：恢复设计得到的信息无用或未被充分利用；逆向工程得到的成果不可分享；缺乏再工程技术支持；等等。</li><li>除这些之外，还有<strong>人员风险</strong>（如人员缺乏协作精神）、<strong>工具风险</strong>（如工具不可靠）等等。</li></ul></li></ul><h1 id="第七章-软件质量保证与分析"><a href="#第七章-软件质量保证与分析" class="headerlink" title="第七章 软件质量保证与分析"></a>第七章 软件质量保证与分析</h1><h2 id="7-1-软件质量"><a href="#7-1-软件质量" class="headerlink" title="7.1 软件质量"></a>7.1 软件质量</h2><ul><li><p>软件质量特性:</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/202111232329348.png" alt="软件质量特性"></p></li><li><p>软件质量评价</p><ul><li>评价软件质量可从三个方面进行，即产品或中间产品、过程（即软件生产所需的资源和活动）和项目</li><li>产品或中间产品评价<ul><li>定义质量需求<br>质量需求包含两个方面：①问题规定或隐含的需求；②软件质量标准和其它技术信息。</li><li>准备评价<br>首先选择质量度量；然后定义质量等级；再定义评估准则。 </li><li>评价过程<br>评价过程实际上是对软件产品就第2步中准备的评价内容进行实施，也分3步：<ol><li>测量——把选定的质量度量应用到软件产品上；</li><li>评级——确定某测量值的等级；</li><li>评估——根据评估准则确定产品质量，并依据管理准则判定产品是否可通过验收或是否发行等等。 </li></ol></li></ul></li><li>过程或项目评价<ul><li>主要通过考察软件企业的质量保证与质量管理的质量来评价软件产品的质量。 </li><li>一般来说，好的质量保证与质量管理会带来高的产品质量。</li></ul></li></ul></li><li><p>软件质量保证</p><ul><li>所谓质量保证（Quality Assurance）是为了提供足够的信任表明实体能满足质量要求，而在<strong>质量体系</strong>中实施并根据需要进行证实的全部有计划、系统化的活动。 </li><li>质量体系（Quality System）是为实施质量管理所需的组织结构、程序、过程和资源 </li><li>参与者:<ul><li>软件工程师：通过采用可靠的技术方法和措施，进行正式的技术复审、执行计划周密的软件测试来保证软件质量 </li><li>软件质量保证小组(SQA)小组：主要辅助软件工程小组制作高质量的最终产品</li></ul></li></ul></li><li><p>软件质量管理</p><ul><li><p>确定质量方针、目标和职责，并在质量体系中通过诸如：质量策划、质量控制、质量保证和质量改进，使其实施全部管理职能的所有活动。 </p></li><li><p>类型：质量检验型管理、全面质量管理和质量认证</p><p>| 质量管理                                     | 质量保证                               |<br>| —————————————————————— | ——————————————————— |<br>| 由组织内部利益相关者发起，特别是组织的管理者 | 由利益相关者发起，特别是组织外部的顾客 |<br>| 使所有利益相关者满意为目的                   | 以所有顾客满意为目的                   |<br>| 关系到质量结果的取得                         | 对达到质量要求的证明                   |<br>| 预期的结果是所有工作都很出色                 | 预期结果是确信组织的产品能为顾客满意   |</p></li></ul></li></ul><h2 id="7-2-软件复杂性分析"><a href="#7-2-软件复杂性分析" class="headerlink" title="7.2 软件复杂性分析"></a>7.2 软件复杂性分析</h2><ul><li>软件度量具有的特征：<ul><li>简单的和可计算的;</li><li>经验和直觉上有说服力;</li><li>一致的和客观的;</li><li>单位和维度的使用上是一致的;</li><li>编程语言独立性;</li><li>质量反馈的有效机制</li></ul></li></ul><h3 id="7-2-1-基于需求分析的复杂性分析"><a href="#7-2-1-基于需求分析的复杂性分析" class="headerlink" title="7.2.1 基于需求分析的复杂性分析"></a>7.2.1 基于需求分析的复杂性分析</h3><p>功能点方法</p><ul><li><p>Albrecht首先提出来；</p></li><li><p>功能点方法以需求规格说明书中双方确认的软件功能为依据，着重分析待开发系统的功能度（Functionality）。 </p></li><li><p>假定：软件的大小与软件的功能度相关，而与软件功能的描述无关，也与功能需求的如何实现无关</p></li><li><p>五类功能点：</p><ul><li>用户输入数；</li><li>用户输出数；</li><li>用户查询数；</li><li>文件数；</li><li>外部接口数</li></ul></li><li><p>功能复杂性分布</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/202111232341633.png" alt="功能复杂性分布"></p></li><li><p>影响因子及度量</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/202111232342364.png" alt="影响因子及度量"></p></li><li><p>功能点计算</p><ul><li><p>$功能点FP=为调节功能点UFP<em>(常数C_1+常数C_2</em>复杂度调节值CA)$</p></li><li><p>其中，$UFP=\sum<em>{i=1}^{5}\sum</em>{j=1}^{3}W<em>{ij}C</em>{ij}$，i表示功能点型号，共5类；j表示复杂性的级数，共3级；</p><p>$W_{ij}$表示第i类功能点处于第j级复杂性的度量值</p><p>$C_{ij}$表示第i类功能点处于第j级复杂性的数目。</p><p>也可以简单地将所有同类功能点处理成同级复杂度，就有 $UFP’=\sum<em>{i=1}^{5}W_i’C_i’$， $W_i’$表示第i类功能点复杂性的度量值，$C</em>{i}’$表示第i类功能点处于第j级复杂性的数目。</p></li><li><p>常数C~1~和C~2~根据经验确定，如C~1~=0.65，C~2~=0.01</p></li><li><p>$CA=F<em>1+F_2+···+F</em>{14}$，其中，F~i~是第i类影响因子对功能点的影响调节值，取值范围为0~5，主要是根据经验确定。</p></li></ul></li><li><p>功能点的应用</p><ul><li>每个功能点（FP）的错误数；</li><li>每个功能点（FP）的缺陷数；</li><li>每个月完成的功能点（FP）数；</li><li>每个功能点（FP）的文档页数；</li><li>每个功能点（FP）的成本</li></ul></li><li><p>不足：</p><ul><li>如何划分功能点类（即如确定那些是用户输入，哪些是外部接口等）不同的人有不同的看法；</li><li>F~i~和C~1~、C~2~的确定也是主观的；</li><li>功能点方法最初主要是用于商业信息系统应用软件中，只强调了数据成份，从而对于强调功能及控制的非数据处理软件（如嵌入式软件、过程控制软件等）并不适用。</li></ul></li></ul><h3 id="7-2-2-基于软件设计的复杂性分析"><a href="#7-2-2-基于软件设计的复杂性分析" class="headerlink" title="7.2.2 基于软件设计的复杂性分析"></a>7.2.2 基于软件设计的复杂性分析</h3><ul><li>概要设计复杂性度量主要集中在软件结构的特征上。</li><li>Card和Glass定义了三种软件设计复杂度测度：结构复杂度、数据复杂度和系统复杂度。其定义分别如下：<ul><li>模块i的结构复杂度$S(i)=f^2_{out}(i)$；</li><li>模块i的数据复杂度$D(i)=V(i)/[f_{out}(i)+1]$；</li><li>系统复杂度$C(i)=S(i)+D(i)$；</li><li>其中$f_{out}(i)$表示模块i的扇出，$V(i)$表示模块i的输入/输出变量的个数。 </li></ul></li><li>设计结构质量指标（DSQI）方法:<ul><li>从数据和体系结构设计中获得数据：<ul><li>S~1~=软件结构中定义的模块总数</li><li>S~2~=正确功能依赖于输入源数据或产生在其他地方使用的数据的模块数</li><li>S~3~=正确功能依赖于前导处理的模块数</li><li>S~4~=数据库中项目数（包括数据对象和所有定义对象的属性）</li><li>S~5~=特殊数据库项目总数</li><li>S~6~=数据库段数目（不同的记录或单个对象）</li><li>S~7~=有单个入口和出口的模块数目（异常处理不被看作是多重出口）</li></ul></li><li>根据S~1~～S~7~计算如下中间数据:<ul><li>程序结构：$D_1=1或0$ （如果软件结构是用明确的方法设计，如面向数据流设计，则$D_1=1$，其它$D_1=0$）</li><li>模块独立性：$D_2=1-(S2/S1)$</li><li>模块不依赖于前导处理：$D_3=1-(S3/S1)$</li><li>数据库大小：$D_4=1-(S5/S4)$</li><li>数据库分区：$D_5=1-(S6/S4)$</li><li>模块出/入口特性：$D_6=1-(S7/S1)$</li></ul></li><li>根据D~1~～D~6~计算DSQI的值:<ul><li>$DSQI=W_1D_1+W_2D_2+W_3D_3+W_4D_4+W_5D_5+W_6D_6$<br>其中W~i~是每个中间值的重要性的相对值且$W_1+W_2+…+W_6=1$</li><li>如果计算出来的DSQI明显低于平均值，则意味着应进一步改进设计；同样，如果要对一个现存的设计做重要的改动，这些改动对DSQI的影响也可以被计算出来。 </li></ul></li></ul></li><li>McCabe环形计数法<ul><li>详细设计复杂性度量主要集中在模块内部结构的复杂性上</li><li>程序环形复杂度V(G)=程序流程图中的“判定数”+1<pre><code>                =程序图中的“环形数”。                =m-n+2</code></pre>其中m对应于程序图中的弧数，n对应于程序图中的节点数</li></ul></li></ul><h3 id="7-2-3-基于源程序代码的复杂性分析"><a href="#7-2-3-基于源程序代码的复杂性分析" class="headerlink" title="7.2.3 基于源程序代码的复杂性分析"></a>7.2.3 基于源程序代码的复杂性分析</h3><ul><li>霍尔斯特德（Halstead）根据源代码中<strong>运算符和操作数</strong>的测量值来度量源程序代码的复杂度。</li><li>在Halstead方法中，运算符是指用来处理程序中常量和变量的语法元素等，如算术运算符、逻辑运算符、关系运算符、流程控制语句、函数调用等；操作数则是指源程序代码中的常量和变量等。但对非执行语句，如注释，则不进行考虑。</li><li>Halstead方法的基本测量数据：<ul><li>程序中运算符总数N~1~</li><li>程序中操作数总数N~2~</li><li>程序中运算符种类数n~1~</li><li>程序中操作数种类数n~2~</li></ul></li><li>源程序代码复杂性度量：<ul><li>实际程序长度$N=N_1+N_2$<br>编程语言层次$L=(2/n_1)*(n_2/N_2)$</li><li>程序容量 $V=(N_1+N_2)*log_2(n_1+n_2)$</li><li>预测程序长度$N’= n_1<em>log_2n_1+n_2</em>log_2n_2$  （可在详细设计后进行预测）</li><li>估计程序工作量 $E’=V/L=(n_1<em>N_2</em>(N_1+N_2)<em>log_2(n_1+n_2))/(2</em>n_2)$ 预</li><li>测程序错误数$E”=((N_1+N_2)*log_2(n_1+n_2))/3000$</li></ul></li></ul><h3 id="7-2-4-基于软件维护的复杂性分析"><a href="#7-2-4-基于软件维护的复杂性分析" class="headerlink" title="7.2.4 基于软件维护的复杂性分析"></a>7.2.4 基于软件维护的复杂性分析</h3><ul><li>IEEE建议采用一种软件成熟度指标（SMI），以提供对软件产品的稳定性指示（基于为每一软件产品发布而做的变化）。</li><li>将SMI和维护工作量联系起来，形成一个经验模型，则可用来度量软件维护的复杂性。 </li><li>SMI方法：<ul><li>测量数据：<ul><li>当前发布软件中的模块数M~T~；</li><li>当前发布软件中已经改变的模块数F~c~；</li><li>当前发布软件中已经添加的模块数F~a~；</li><li>当前发布软件中已经删除的前一次发布软件中的模块数F~d~。</li></ul></li><li>则软件成熟度指标按下式进行计算：<br>$SMI=[M_T-（F_a+F_c+F_d）]/M_T$</li><li>当SMI接近1的时候，产品便开始稳定。</li></ul></li></ul><h2 id="7-3-IS0软件质量体系"><a href="#7-3-IS0软件质量体系" class="headerlink" title="7.3 IS0软件质量体系"></a>7.3 IS0软件质量体系</h2><ul><li><p>质量体系（Quality System）是一种质量管理制度。</p></li><li><p>建立质量体系是企业保证产品质量能够持续稳定地满足质量标准要求的根本途径。</p></li><li><p>质量体系是质量管理的核心，质量管理则通过质量体系来实现。</p></li><li><p>ISO 9000族国际标准</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/202111240048133.png" alt="image-20211124004813020"></p></li><li><p>5类标准之间的关系 </p><ul><li>“质量术语标准”是讨论问题的前提，统一术语是为了明确概念，建立共同语言。</li><li>三个“质量保证标准“是ISO 9000族标准的核心，是质量认证的基准。</li><li>“质量管理标准”描述了要达到质量保证标准应怎么管理。</li><li>“标准选用与实施指南”是对质量保证标准的解释和导引。</li><li>“支持性技术标准”则从更广泛的意义上给予标准实施的支持。</li></ul></li><li><p>ISO 9000族标准中的ISO 9001质量保证标准是软件机构推行质量认证工作的一个基础标准，我国已将其转化为国家推荐标准：GB/T 19001-1994。 </p></li><li><p>ISO 9001标准在20个方面规定了供方在全部生产活动过程中的质量要求，也称为20个质量体系要素。</p></li><li><p>在欧洲和日本，主要的质量标准是ISO 9001。</p></li><li><p>ISO 9000-3是计算机软件机构实施ISO 9001的指南性标准。由于ISO 9000族标准主要针对传统的制造业制订的，不少软件企业的技术人员和管理人员觉得ISO 9001标准中质量体系要素的要求和软件工程项目有距离，ISO 9000-3这个实施指南起到了桥梁作用。</p></li><li><p>指南性主要表现在：（1）从软件的角度对ISO 9001的内容给出了具体的说明和解释；（2）指南性的标准不是认证审核的依据，依据仍是ISO 9001的各质量体系要素的实施情况。</p></li><li><p>企业软件质量体系的建立和实施：</p><ul><li>准备阶段;</li><li>质量体系策划;</li><li>编写质量体系文件;</li><li>培训内部审核员;</li><li>质量体系试运行;</li><li>内部质量体系审核;</li><li>管理评审;</li><li>质量体系认证前的准备；</li><li>质量体系认证；</li><li>质量体系的进一步改进与完善。</li></ul></li></ul><h2 id="7-4-软件配置管理"><a href="#7-4-软件配置管理" class="headerlink" title="7.4 软件配置管理"></a>7.4 软件配置管理</h2><ul><li><p>在软件的生存周期内，变化是不可避免的，而且产生的信息又非常庞大。</p></li><li><p>软件配置管理就是针对这个变化而又庞大的信息集进行有效管理的保护性活动。它可以用来:（1）标识变化；（2）控制变化；（3）保证变化被适当地实现；以及（4）记录变化，并将变化的情况报告给有关人员。 </p></li><li><p>软件配置管理项：Software Configuration Items，简称SCI）是软件配置管理的对象，它包括软件生存周期内产生的所有信息项。</p><ul><li><p>配置项：</p><ul><li>与合同、源代码、过程、计划和产品有关的文档及数据；</li><li>目标代码和可执行代码；</li><li>相关产品，包括：软件工具、库内的可复用件、外购软件等。</li></ul></li><li><p>按ISO 9000-3的叙述，软件配置管理是一个管理学科，对配置项的开发和支持生存周期给予技术上和管理上的指导。 </p></li><li><p>软件配置管理不同于软件维护，最主要的一点是软件配置管理是当软件项目开始时就启动，并且仅当软件终止运行后才结束的一组跟踪和控制变化的活动。 </p></li><li><p>任务：</p><ul><li>制订配置管理计划；</li><li>确定配置标识；</li><li>进行配置控制，实施变更管理；</li><li>配置审计；</li><li>记录并报告配置状态；</li><li>版本控制；</li><li>发行管理和交付 </li></ul><p><strong><u>软件配置管理概括地说就是标识变更、控制变更以及发布变更</u></strong></p></li></ul></li></ul><h2 id="7-5-软件过程能力成熟度模型"><a href="#7-5-软件过程能力成熟度模型" class="headerlink" title="7.5 软件过程能力成熟度模型"></a>7.5 软件过程能力成熟度模型</h2><ul><li><p>作用：一方面，可以用来评价软件组织的质量保证能力；另一方面，也为软件组织改进软件过程，提高软件过程能力提供了依据。</p></li><li><p>基本概念：</p><ul><li>软件过程：人们用于开发和维护软件及其有关产品（如项目计划、设计文档、代码、用户手册等，在模型中又称为软件工作产品）的一系列活动，包括软件工程活动和软件管理活动。 </li><li>软件过程能力：描述开发组织或项目组通过执行其软件过程能实现预期结果的程度。</li><li>软件过程性能：表示开发组织或项目组遵循其软件过程所得到的实际结果。</li><li>软件过程成熟度：一个特定软件过程被明确和有效地定义、管理、测量和控制的程度。 </li><li>软件能力成熟度等级：软件开发组织在走向成熟的途中几个具有明确定义的、表征软件过程能力成熟度的平台。</li><li>关键过程域：互相关联的若干软件实践活动和有关基础设施的集合。 </li><li>关键实践：对关键过程域的实施起关键作用的方针、规程、措施、活动以及相关基础设施的建立。 </li><li>软件过程能力成熟度模型：对软件组织进化阶段的描述，随着软件组织定义、实施、测量、控制和改进其软件过程，软件组织的能力经过这些阶段逐步前进</li><li><img src="https://gitee.com/sehowyoung/images/raw/master/202111240042592.png" alt="软件过程能力成熟度模型结构"></li></ul></li><li><p>软件过程能力成熟度等级</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/202111240043511.png" alt="软件过程能力成熟度等级"></p></li><li><p>关键过程域：</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/202111240044247.png" alt="关键过程域"></p></li><li><p>关键实践：</p><ul><li><strong>执行约定</strong>：描述一个组织在保证将过程建立起来并持续起作用方面所必须采取的行动。执行约定一般包括制定组织的方针和规定高级管理者的支持。</li><li><strong>执行能力</strong>：描述为了实施软件过程，项目或组织中必须存在的先决条件。执行能力一般包括资源、组织机构和培训。</li><li><strong>执行的活动</strong>：描述为实现一个关键过程域所必须的角色和规程（即描述必须由何人做何事）。执行的活动一般包括制订计划与规程、执行计划、跟踪执行情况，必要时采取纠正措施。</li><li><strong>测量和分析</strong>：描述对过程进行测量和对测量结果进行分析的需要。测量和分析一般包括为了确定所执行活动的状态及有效性所能采用的测量和分析。</li><li><strong>验证实施</strong>：描述遵照已建立的过程进行活动的措施。验证实施一般包括管理者和软件质量保证部门所作的评审和审计。</li></ul></li><li><p>软件过程能力成熟度模型的应用</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/202111240046063.png" alt="软件过程能力成熟度模型的应用"></p></li><li><p>CMM与ISO9001的主要区别：</p><ul><li>CMM明确强调持续的过程改进，而ISO9001则确定可接受的质量体系的最低要求；</li><li>CMM严格适用于软件；而ISO 9001范围很广，涵盖了硬件、软件、加工材料和服务。</li></ul></li></ul><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="逻辑覆盖法例题"><a href="#逻辑覆盖法例题" class="headerlink" title="逻辑覆盖法例题"></a>逻辑覆盖法例题</h2><p><img src="https://gitee.com/sehowyoung/images/raw/master/202111232047925.png" alt="逻辑覆盖法例题"></p><h2 id="基本路径覆盖法例题"><a href="#基本路径覆盖法例题" class="headerlink" title="基本路径覆盖法例题"></a>基本路径覆盖法例题</h2><p><img src="https://gitee.com/sehowyoung/images/raw/master/202111232053361.png" alt="image-20211123205306301"></p><p><img src="https://gitee.com/sehowyoung/images/raw/master/202111232053509.png" alt="image-20211123205317445"></p><p><img src="https://gitee.com/sehowyoung/images/raw/master/202111232054269.png" alt="image-20211123205406200"></p><h2 id="等价类划分例题"><a href="#等价类划分例题" class="headerlink" title="等价类划分例题"></a>等价类划分例题</h2><p><img src="https://gitee.com/sehowyoung/images/raw/master/202111232141914.png" alt="image-20211123214106848"></p><p><img src="https://gitee.com/sehowyoung/images/raw/master/202111232141136.png" alt="image-20211123214115074"></p><h2 id="边界值分析法例子"><a href="#边界值分析法例子" class="headerlink" title="边界值分析法例子"></a>边界值分析法例子</h2><p><img src="https://gitee.com/sehowyoung/images/raw/master/202111232143941.png" alt="image-20211123214312885"></p><h2 id="因果图法的例子"><a href="#因果图法的例子" class="headerlink" title="因果图法的例子"></a>因果图法的例子</h2><p><img src="https://gitee.com/sehowyoung/images/raw/master/202111232148741.png" alt="image-20211123214835674"></p><p><img src="https://gitee.com/sehowyoung/images/raw/master/202111232147940.png" alt="image-20211123214754879"></p><h2 id="功能点计算例子"><a href="#功能点计算例子" class="headerlink" title="功能点计算例子"></a>功能点计算例子</h2><p><img src="https://gitee.com/sehowyoung/images/raw/master/202111240004976.png" alt="image-20211124000418913"><img src="https://gitee.com/sehowyoung/images/raw/master/202111240004383.png" alt="image-20211124000445299"></p><h2 id="McCabe环形计数法例子"><a href="#McCabe环形计数法例子" class="headerlink" title="McCabe环形计数法例子"></a>McCabe环形计数法例子</h2><p><img src="https://gitee.com/sehowyoung/images/raw/master/202111240023221.png" alt="image-20211124002339154"><img src="https://gitee.com/sehowyoung/images/raw/master/202111240024469.png" alt="image-20211124002449393"><img src="https://gitee.com/sehowyoung/images/raw/master/202111240025454.png" alt="image-20211124002509387"></p><h2 id="Halstead方法例子"><a href="#Halstead方法例子" class="headerlink" title="Halstead方法例子"></a>Halstead方法例子</h2><p><img src="https://gitee.com/sehowyoung/images/raw/master/202111240034021.png" alt="image-20211124003410924"></p>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>各种学习资料</title>
      <link href="/posts/15096.html"/>
      <url>/posts/15096.html</url>
      
        <content type="html"><![CDATA[<h1 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h1><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><ol><li>中学生信息学奥赛C++语法精讲和基础算法<br>链接: <a href="https://pan.baidu.com/s/18DROpgf0kpexsXC9adN6kw">https://pan.baidu.com/s/18DROpgf0kpexsXC9adN6kw</a> 提取码: v425</li><li>C++ 24期就业班(高清不加密)<br>链接: <a href="https://pan.baidu.com/s/1D5YcoZSQc5rWcvN7FXrRJA">https://pan.baidu.com/s/1D5YcoZSQc5rWcvN7FXrRJA</a> 提取码: 39zr</li></ol><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><ol><li>JVM与GC调优课程<br>链接: <a href="https://pan.baidu.com/s/1c6-9bvRIVxdW9F_-U-AxPg">https://pan.baidu.com/s/1c6-9bvRIVxdW9F_-U-AxPg</a> 提取码: s4fr</li><li>Java架构师提升课程<br>链接: <a href="https://pan.baidu.com/s/1LzF5Y38SR_FGqR_0Ei9o6w">https://pan.baidu.com/s/1LzF5Y38SR_FGqR_0Ei9o6w</a> 提取码: scwc</li><li>Java进阶 20210726-高薪必备JVM面试题解惑<br>链接: <a href="https://pan.baidu.com/s/1SBiLLIq8xaupVjfxqpRlhA">https://pan.baidu.com/s/1SBiLLIq8xaupVjfxqpRlhA</a> 提取码: ue69</li><li>《Java高级开发工程师》课程包含六大专题【完整】<br>链接: <a href="https://pan.baidu.com/s/1-DXe6woRplhsmKVqgrfFAg">https://pan.baidu.com/s/1-DXe6woRplhsmKVqgrfFAg</a> 提取码: q19m</li><li>Java高级互联网架构师 1-6班<br>链接: <a href="https://pan.baidu.com/s/1p8I0Lfb3fCdlxZFxU_12iw">https://pan.baidu.com/s/1p8I0Lfb3fCdlxZFxU_12iw</a> 提取码: s985</li><li>互联网Java突击面试（1~3季)<br>链接: <a href="https://pan.baidu.com/s/1V_7C53G_866-wzULn8Ph-g">https://pan.baidu.com/s/1V_7C53G_866-wzULn8Ph-g</a> 提取码: 0w9o</li><li>JAVA架构师微职位：Java集群架构<br>链接: <a href="https://pan.baidu.com/s/1Y_veaniXXQlxpRPAKp8b8g">https://pan.baidu.com/s/1Y_veaniXXQlxpRPAKp8b8g</a> 提取码: 7una</li><li>马士兵教育Java高级工程师<br>链接: <a href="https://pan.baidu.com/s/14MRIP_S1g99OsPrB4L5N_A">https://pan.baidu.com/s/14MRIP_S1g99OsPrB4L5N_A</a> 提取码: l95k</li><li>腾讯课堂Java架构班之BATJ企业面试课<br>链接: <a href="https://pan.baidu.com/s/1TXywdwRcDmuPxkucoSjubA">https://pan.baidu.com/s/1TXywdwRcDmuPxkucoSjubA</a> 提取码: 1kqw</li><li>Jvm源码分析及调优实战课程 链接: <a href="https://pan.baidu.com/s/1YDGFJ4SRNfALpiRWsSyU3Q">https://pan.baidu.com/s/1YDGFJ4SRNfALpiRWsSyU3Q</a> 提取码: a02p</li><li>技术大咖与热点技术 轻松拿下一线大厂Offer（JAVA） 链接: <a href="https://pan.baidu.com/s/1tAAIzM-aTsIMLVJITwdaXw">https://pan.baidu.com/s/1tAAIzM-aTsIMLVJITwdaXw</a> 提取码: 65w4</li><li>奈学Java资深研发工程师1期【完结】 链接: <a href="https://pan.baidu.com/s/1lrtYYDaCHqn4N2AgIrloMQ">https://pan.baidu.com/s/1lrtYYDaCHqn4N2AgIrloMQ</a> 提取码: val6</li></ol><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><ol><li>【完结】python金融实务从入门到精通<br>链接: <a href="https://pan.baidu.com/s/1NVAAUc7wu5YpSMktTTc4FA">https://pan.baidu.com/s/1NVAAUc7wu5YpSMktTTc4FA</a> 提取码: 0gzn</li><li>数据蛙第一期就业班<br>链接: <a href="https://pan.baidu.com/s/1COYmEGBvvx-izi_PP7FnTw">https://pan.baidu.com/s/1COYmEGBvvx-izi_PP7FnTw</a> 提取码: knu5</li><li>明明白白学Python<br>链接: <a href="https://pan.baidu.com/s/1V9TD-rfVTsN9Ea1RYd92JQ">https://pan.baidu.com/s/1V9TD-rfVTsN9Ea1RYd92JQ</a> 提取码: 420b</li><li>TensorFlow2.0入门到实践<br>链接: <a href="https://pan.baidu.com/s/1BzKvr4Tj-yHk05nGM8Lkig">https://pan.baidu.com/s/1BzKvr4Tj-yHk05nGM8Lkig</a> 提取码: i057</li><li>邢不行—Python股票量化投资课程（完结）<br>链接: <a href="https://pan.baidu.com/s/1I4UrBLB7vevJkox_3b6zvg">https://pan.baidu.com/s/1I4UrBLB7vevJkox_3b6zvg</a> 提取码: p6nx</li><li>极客学院Python全套教程<br>链接: <a href="https://pan.baidu.com/s/1MyPy1mWNSO-mc98opzVwSw">https://pan.baidu.com/s/1MyPy1mWNSO-mc98opzVwSw</a> 提取码: 50e2</li><li>尹会生 —— 零基础学Python 链接: <a href="https://pan.baidu.com/s/11c_KAUZEfLfJR_JnuBzXAA">https://pan.baidu.com/s/11c_KAUZEfLfJR_JnuBzXAA</a> 提取码: kxmw</li></ol><h2 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h2><ol><li>2020新版Go开发工程师完结<br>链接: <a href="https://pan.baidu.com/s/192t-KmfKcDB-e-okqKRoxg">https://pan.baidu.com/s/192t-KmfKcDB-e-okqKRoxg</a> 提取码: u089</li><li>Go语言从入门到实战项目全套视频教程<br>链接: <a href="https://pan.baidu.com/s/1hthh3NfD5LYEj9stALuT6w">https://pan.baidu.com/s/1hthh3NfD5LYEj9stALuT6w</a> 提取码: nx31</li><li>Go语言开发教程合集 <a href="https://www.aliyundrive.com/s/VySHMYY5oHr">https://www.aliyundrive.com/s/VySHMYY5oHr</a></li></ol><h2 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h2><ol><li>PHP中文网第6期+8期线上培训班<br>链接: <a href="https://pan.baidu.com/s/13r4UhFTvqr8fwL73-b2ExA">https://pan.baidu.com/s/13r4UhFTvqr8fwL73-b2ExA</a> 提取码: 14qy</li></ol><h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><ol><li>2020年最新 尚硅谷ES6教程<br>链接: <a href="https://pan.baidu.com/s/1u_YQCtJAGGTvZsKULUnAeg">https://pan.baidu.com/s/1u_YQCtJAGGTvZsKULUnAeg</a> 提取码: ixww</li></ol><h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><ol><li>Vue2.0+Vue3.0从入门到精通教程（Kerwin老师主讲）<br>链接: <a href="https://pan.baidu.com/s/1AMN8koyq7k_Rf2sQQEaaYQ">https://pan.baidu.com/s/1AMN8koyq7k_Rf2sQQEaaYQ</a> 提取码: 7791</li><li>深入Vue3+TypeScript技术栈(28、29完整版) 链接: <a href="https://pan.baidu.com/s/1tCylTL-U0EF7xMaAz0PikA">https://pan.baidu.com/s/1tCylTL-U0EF7xMaAz0PikA</a> 提取码: pyz6</li></ol><h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><ol><li>React17+React Hook+TS4 最佳实践 仿 Jira 企业级项目（完结）<br>链接: <a href="https://pan.baidu.com/s/1DBzQWPrpk71p9wBovXMx7w">https://pan.baidu.com/s/1DBzQWPrpk71p9wBovXMx7w</a> 提取码: 3t26</li><li>深入浅出搞定 React<br>链接: <a href="https://pan.baidu.com/s/1JzeYUK-jXMvIg6rSVz25mA">https://pan.baidu.com/s/1JzeYUK-jXMvIg6rSVz25mA</a> 提取码: d1e9</li></ol><h2 id="Net"><a href="#Net" class="headerlink" title=".Net"></a>.Net</h2><ol><li>.Net Core 开发API<br>链接: <a href="https://pan.baidu.com/s/1gVGN2v2XT-rupHf24pwSsA">https://pan.baidu.com/s/1gVGN2v2XT-rupHf24pwSsA</a> 提取码: 9952</li><li>ASP.NET Core 技术教程合集（10套） 链接: <a href="https://pan.baidu.com/s/1xZlvDF_bBhXERYazA00uCw">https://pan.baidu.com/s/1xZlvDF_bBhXERYazA00uCw</a> 提取码: u8q1</li></ol><h2 id="Nodejs"><a href="#Nodejs" class="headerlink" title="Nodejs"></a>Nodejs</h2><ol><li>深入Node.js技术栈（完结）<br>链接: <a href="https://pan.baidu.com/s/1I1eniWfXN1geF1VJ_29CKw">https://pan.baidu.com/s/1I1eniWfXN1geF1VJ_29CKw</a> 提取码: a568</li></ol><h1 id="学习套餐"><a href="#学习套餐" class="headerlink" title="学习套餐"></a>学习套餐</h1><ol><li>李兴华开发合集<br>链接: <a href="https://pan.baidu.com/s/13zM0yn-TjF3Zxo87N4_Zyg">https://pan.baidu.com/s/13zM0yn-TjF3Zxo87N4_Zyg</a> 提取码: 6i4a</li><li>阿里P7开发课程<br>链接: <a href="https://pan.baidu.com/s/1d410AD4O1QkR8LJHwvA9oA">https://pan.baidu.com/s/1d410AD4O1QkR8LJHwvA9oA</a> 提取码: w0qe</li><li>Web前端高级工程师011期(完结) 链接: <a href="https://pan.baidu.com/s/1lnF48_w2WkbyNnFsJMNJfw">https://pan.baidu.com/s/1lnF48_w2WkbyNnFsJMNJfw</a> 提取码: 8yy2</li><li>奈学教育P7架构师十三期 价值14999元 链接: <a href="https://pan.baidu.com/s/1W429EsJNW7ATlMY5disuMg">https://pan.baidu.com/s/1W429EsJNW7ATlMY5disuMg</a> 提取码: 2bd4</li><li>Web全栈架构师第23期完整版本 链接: <a href="https://pan.baidu.com/s/1oa_-BWsblgWD-q56euLLpw">https://pan.baidu.com/s/1oa_-BWsblgWD-q56euLLpw</a> 提取码: n9o8</li><li>msb架构师 链接: <a href="https://pan.baidu.com/s/16_pPRlroHBIxz-O4-Dh_vA">https://pan.baidu.com/s/16_pPRlroHBIxz-O4-Dh_vA</a> 提取码: 3g43</li><li>金三银四 面试突击班（完整） 链接: <a href="https://pan.baidu.com/s/1ZVHi0GZg4Pk7zSRwKIC1hg">https://pan.baidu.com/s/1ZVHi0GZg4Pk7zSRwKIC1hg</a> 提取码: 5z2k</li></ol><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><ol><li>黑马程序员 Java设计模式（图解+框架源码分析+实战）【资料完整】<br>链接: <a href="https://pan.baidu.com/s/1vs1zG-qipnN_0D8EjyGxNQ">https://pan.baidu.com/s/1vs1zG-qipnN_0D8EjyGxNQ</a> 提取码: 223c</li></ol><h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><ol><li>JUC并发编程与源码分析课程<br>链接: <a href="https://pan.baidu.com/s/1G8n3MYTiJZfBgvsjpHUtGA">https://pan.baidu.com/s/1G8n3MYTiJZfBgvsjpHUtGA</a> 提取码: kk0s</li><li>并发编程与JVM 领域进阶计划课程 链接: <a href="https://pan.baidu.com/s/1b3cE-_oZRTcqL6YVmdZ5DQ">https://pan.baidu.com/s/1b3cE-_oZRTcqL6YVmdZ5DQ</a> 提取码: 93ps</li></ol><h1 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h1><ol><li>京东数据分析课程<br>链接: <a href="https://pan.baidu.com/s/1H9NUlOZp0cRY-D5_wua0EA">https://pan.baidu.com/s/1H9NUlOZp0cRY-D5_wua0EA</a> 提取码: 51rv</li><li>数据分析全栈大师集训营来啦！<br>链接: <a href="https://pan.baidu.com/s/1bCS22nU2yVhQL5fUFcP3Yw">https://pan.baidu.com/s/1bCS22nU2yVhQL5fUFcP3Yw</a> 提取码: u5j0</li><li>商务数据分析教程<br>链接: <a href="https://pan.baidu.com/s/1BiIgozER2HyOQIM978OYLw">https://pan.baidu.com/s/1BiIgozER2HyOQIM978OYLw</a> 提取码: ae9h</li></ol><h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><ol><li>邓俊辉-算法训练营 第二期<br>链接: <a href="https://pan.baidu.com/s/1K2Gcbw2ImW70SmZLHAMvZA">https://pan.baidu.com/s/1K2Gcbw2ImW70SmZLHAMvZA</a> 提取码: 6gm2</li><li>算法基础入门班（第五期）<br>链接: <a href="https://pan.baidu.com/s/1FLsC4xb7ETP76R3E-Rs3-w">https://pan.baidu.com/s/1FLsC4xb7ETP76R3E-Rs3-w</a> 提取码: ber6</li><li>算法基础提升班（第五期）<br>链接: <a href="https://pan.baidu.com/s/1atyHX1UjwgFiTDvp458D3Q">https://pan.baidu.com/s/1atyHX1UjwgFiTDvp458D3Q</a> 提取码: i7p5</li><li>算法高级班（第十一期）<br>链接: <a href="https://pan.baidu.com/s/1gfbAjPrXgrdTAZczm9JrvA">https://pan.baidu.com/s/1gfbAjPrXgrdTAZczm9JrvA</a> 提取码: 52mg</li><li>算法中级班（第十一期）<br>链接: <a href="https://pan.baidu.com/s/1tzF2efcKeNLxqA9nYOD0Gg">https://pan.baidu.com/s/1tzF2efcKeNLxqA9nYOD0Gg</a> 提取码: pdls</li><li>2020年最新 算法直通套餐（中级+高级）<br>链接: <a href="https://pan.baidu.com/s/1LXafedzoLpBB6IM5C8A9UA">https://pan.baidu.com/s/1LXafedzoLpBB6IM5C8A9UA</a> 提取码: h6xa</li><li>牛课班算法<br>链接: <a href="https://pan.baidu.com/s/1LYwyb5vmapk-PGQQfy1D_g">https://pan.baidu.com/s/1LYwyb5vmapk-PGQQfy1D_g</a> 提取码: 9e2b</li><li>算法初级班第4期课程（已完结）<br>链接: <a href="https://pan.baidu.com/s/1y6znDF3bGqf02zgKI7QdFQ">https://pan.baidu.com/s/1y6znDF3bGqf02zgKI7QdFQ</a> 提取码: 833s</li><li>算法进阶班第4期课程（已完结）<br>链接: <a href="https://pan.baidu.com/s/1HY1yfC2Ru8Tl2xRIc2qd0A">https://pan.baidu.com/s/1HY1yfC2Ru8Tl2xRIc2qd0A</a> 提取码: 7y94</li><li>信奥赛算法专题<br>  链接: <a href="https://pan.baidu.com/s/17rOFFwsAeNfVstubIvfqnA">https://pan.baidu.com/s/17rOFFwsAeNfVstubIvfqnA</a> 提取码: x4hg</li><li>信奥赛数据结构<br>链接: <a href="https://pan.baidu.com/s/199AEOx1RaXHWRzcrJyQqjQ">https://pan.baidu.com/s/199AEOx1RaXHWRzcrJyQqjQ</a> 提取码: ec72</li><li>算法与数据结构 两套教程<br>链接: <a href="https://pan.baidu.com/s/1meovTulkbzmWf1CivjcolQ">https://pan.baidu.com/s/1meovTulkbzmWf1CivjcolQ</a> 提取码: 2099</li><li>九章算法班 2021 版【完结】 链接: <a href="https://pan.baidu.com/s/1EML-2JValBR18ImCjV9yag">https://pan.baidu.com/s/1EML-2JValBR18ImCjV9yag</a> 提取码: yxl1</li><li>左程云 算法与数据结构进阶班 链接: <a href="https://pan.baidu.com/s/1OHIAbI31CgO8p--dete6MA">https://pan.baidu.com/s/1OHIAbI31CgO8p--dete6MA</a> 提取码: 3j83</li><li>数据结构与算法.教程.合集 <a href="https://www.aliyundrive.com/s/g5hnKTPyfWV">https://www.aliyundrive.com/s/g5hnKTPyfWV</a></li><li>数据结构实战完全手册视频课程 链接: <a href="https://pan.baidu.com/s/1DWtPlXfGpOcXRRnvXmW5iw">https://pan.baidu.com/s/1DWtPlXfGpOcXRRnvXmW5iw</a> 提取码: 17x9</li><li>算法训练营：<a href="https://www.aliyundrive.com/s/AF11EEehjm3">https://www.aliyundrive.com/s/AF11EEehjm3</a></li></ol><h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><ol><li>Spring boot源码解析【资料完整】<br>链接: <a href="https://pan.baidu.com/s/1jSEY_MU3e31uNiK-wuB42g">https://pan.baidu.com/s/1jSEY_MU3e31uNiK-wuB42g</a> 提取码: 35mc</li><li>全栈H版本+新增Spring Cloud Alibaba架构实战课程<br>链接: <a href="https://pan.baidu.com/s/1PsDWW2I_dyhhNOh9ayZ6OA">https://pan.baidu.com/s/1PsDWW2I_dyhhNOh9ayZ6OA</a> 提取码: 28m8</li><li>Spring Cloud 亿级账户系统 TCC 分布式事务实战<br>链接: <a href="https://pan.baidu.com/s/1R21zVWlJ_T164X-DjuT72w">https://pan.baidu.com/s/1R21zVWlJ_T164X-DjuT72w</a> 提取码: 2xly</li><li>SpringBoot就业编程实战<br>链接: <a href="https://pan.baidu.com/s/1zZ-UOiuBQeug0Cmwfltncg">https://pan.baidu.com/s/1zZ-UOiuBQeug0Cmwfltncg</a> 提取码: 3o24</li><li>SpringCloud alibaba微服务全家桶<br>链接: <a href="https://pan.baidu.com/s/1PolzltOVwdJvfgXluuZhcQ">https://pan.baidu.com/s/1PolzltOVwdJvfgXluuZhcQ</a> 提取码: ivxr</li><li>分布式事务实践 解决数据 （无秘）<br>链接: <a href="https://pan.baidu.com/s/1eYy7sWBQtiKmszl3Az3B9Q">https://pan.baidu.com/s/1eYy7sWBQtiKmszl3Az3B9Q</a> 提取码: 0d0e</li><li>Spring100集<br>链接: <a href="https://pan.baidu.com/s/1y146k4n38nMl0DQJ6tpKMA">https://pan.baidu.com/s/1y146k4n38nMl0DQJ6tpKMA</a> 提取码: 53na</li><li>Spring Cloud &amp; Alibaba微服务综合实战项目 链接: <a href="https://pan.baidu.com/s/151LmY510hdqdfd2q5i6kig">https://pan.baidu.com/s/151LmY510hdqdfd2q5i6kig</a> 提取码: gxq7</li><li>RPC框架核心源码深度解析 链接: <a href="https://pan.baidu.com/s/14dkOXASnWPvqEeLgv_unjA">https://pan.baidu.com/s/14dkOXASnWPvqEeLgv_unjA</a> 提取码: 9360</li><li></li></ol><h1 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h1><ol><li>大数据机器学习（2019春）<br>链接: <a href="https://pan.baidu.com/s/17zcfRtVZaS6jgXcol41VgA">https://pan.baidu.com/s/17zcfRtVZaS6jgXcol41VgA</a> 提取码: v96e</li><li>大数据HBase-Phoenix技术精讲<br>链接: <a href="https://pan.baidu.com/s/1exdhNlP_1y6NqiERmXpEoQ">https://pan.baidu.com/s/1exdhNlP_1y6NqiERmXpEoQ</a> 提取码: 4j2y</li><li>黑马程序员 - 8天零基础入门大数据<br>链接: <a href="https://pan.baidu.com/s/1oIG9R-1tuF8BUJXWTuPNfg">https://pan.baidu.com/s/1oIG9R-1tuF8BUJXWTuPNfg</a> 提取码: 8d9w</li><li>大数据Java基础课程【完整资料】<br>链接: <a href="https://pan.baidu.com/s/1H6E-o6-jYWbsv6q-M-2rVA">https://pan.baidu.com/s/1H6E-o6-jYWbsv6q-M-2rVA</a> 提取码: q5og</li><li>八斗大数据20期【完】 链接: <a href="https://pan.baidu.com/s/1fNfcEFwbCG1jrTaGM4_M9w">https://pan.baidu.com/s/1fNfcEFwbCG1jrTaGM4_M9w</a> 提取码: 5j08 </li><li>八斗大数据19期【完】 链接: <a href="https://pan.baidu.com/s/1CxPrPLIFZlxbpFbOHKwFpQ">https://pan.baidu.com/s/1CxPrPLIFZlxbpFbOHKwFpQ</a> 提取码: kl6w</li><li>上海尚学堂大数据2021版 链接: <a href="https://pan.baidu.com/s/1tUODMWOVun7V1Ub_my_wZA">https://pan.baidu.com/s/1tUODMWOVun7V1Ub_my_wZA</a> 提取码: 0uxr</li></ol><h1 id="机器学习类型"><a href="#机器学习类型" class="headerlink" title="机器学习类型"></a>机器学习类型</h1><ol><li>机器学习之Python编程基础与数据分析<br>链接: <a href="https://pan.baidu.com/s/1mQVcWpX0ZrpaeZZ0ZGkI8g">https://pan.baidu.com/s/1mQVcWpX0ZrpaeZZ0ZGkI8g</a> 提取码: 43nh</li><li>Tensorflow-物体检测-Faster-Rcnn解读<br>链接: <a href="https://pan.baidu.com/s/1bENtgT8seAaLxDOGfRvlpg">https://pan.baidu.com/s/1bENtgT8seAaLxDOGfRvlpg</a> 提取码: 77z9</li><li>Tensorflow-图像处理视频课程<br>链接: <a href="https://pan.baidu.com/s/18ZHmCP5S4etCwF9r5dFibg">https://pan.baidu.com/s/18ZHmCP5S4etCwF9r5dFibg</a> 提取码: h0c0</li><li>日月光华 tensorflow2.0课程 链接: <a href="https://pan.baidu.com/s/1Q9qzUaQ5OY8vuPNyvd45jg">https://pan.baidu.com/s/1Q9qzUaQ5OY8vuPNyvd45jg</a> 提取码: tsw5</li><li>图像处理与机器学习<br>链接: <a href="https://pan.baidu.com/s/1LN9KM7cW91-0e7VKYSwImQ">https://pan.baidu.com/s/1LN9KM7cW91-0e7VKYSwImQ</a> 提取码: 598a</li><li>深度学习之神经网络<br>链接: <a href="https://pan.baidu.com/s/1nZ2oECGskQoAZUorPy1xbw">https://pan.baidu.com/s/1nZ2oECGskQoAZUorPy1xbw</a> 提取码: fqv1</li><li>音视频开发技术学习视频教程(第一季) 链接: <a href="https://pan.baidu.com/s/1LeD1SrG5iXNZvm_BUNAxrg">https://pan.baidu.com/s/1LeD1SrG5iXNZvm_BUNAxrg</a> 提取码: 15n2</li><li>Power BI数据建模语言：DAX精讲高级课程 链接: <a href="https://pan.baidu.com/s/1IupAZloVNP9ltNYxzHW7fA">https://pan.baidu.com/s/1IupAZloVNP9ltNYxzHW7fA</a> 提取码: tl4x</li><li>名企CV-计算机视觉CV 004期 链接: <a href="https://pan.baidu.com/s/1wse913AqxaUVoHwckXecZQ">https://pan.baidu.com/s/1wse913AqxaUVoHwckXecZQ</a> 提取码: r4tw</li><li>自然语言处理动手学Bert文本分类 链接: <a href="https://pan.baidu.com/s/1cPm-fx1jTyHObVCvL_2hSg">https://pan.baidu.com/s/1cPm-fx1jTyHObVCvL_2hSg</a> 提取码: p69m</li><li>机器学习如何在企业中落地课程 链接: <a href="https://pan.baidu.com/s/1bMN4wfTrpRv9UJ5RZTb3oA">https://pan.baidu.com/s/1bMN4wfTrpRv9UJ5RZTb3oA</a> 提取码: 339x</li><li>RoboMaster机器人基础_哈尔滨工业大学 链接: <a href="https://pan.baidu.com/s/1BYxbwpWc3vz50WZOFBnrfg">https://pan.baidu.com/s/1BYxbwpWc3vz50WZOFBnrfg</a> 提取码: 1zkx</li></ol><h1 id="Linux相关（容器、网络编程等）"><a href="#Linux相关（容器、网络编程等）" class="headerlink" title="Linux相关（容器、网络编程等）"></a>Linux相关（容器、网络编程等）</h1><ol><li>带你轻松玩转Docker技术<br>链接: <a href="https://pan.baidu.com/s/1OVo2EbLNzsou1wftgqHUuw">https://pan.baidu.com/s/1OVo2EbLNzsou1wftgqHUuw</a> 提取码: b6y4</li><li>新一代容器技术Docker【资料完整】<br>链接: <a href="https://pan.baidu.com/s/1ZkoQKmmCPoArcK6zr6RziA">https://pan.baidu.com/s/1ZkoQKmmCPoArcK6zr6RziA</a> 提取码: 4g6y</li><li>K8s（kubernetes）周末班视频资料齐全<br>链接: <a href="https://pan.baidu.com/s/1hxseWrp2JhKaqdhLLFGzDw">https://pan.baidu.com/s/1hxseWrp2JhKaqdhLLFGzDw</a> 提取码: nrwo</li><li>kubernetes全栈技术讲解+企业案例演示[带你快速学习和使用k8s]【基础+进阶版】<br>链接: <a href="https://pan.baidu.com/s/1vHivOuLofQf7cP4y_Jj5HA">https://pan.baidu.com/s/1vHivOuLofQf7cP4y_Jj5HA</a> 提取码: o7uq</li><li>Linux系统及网络编程视频课程专题<br>链接: <a href="https://pan.baidu.com/s/1G8dWp3ACtSIZ8YCetiex7w">https://pan.baidu.com/s/1G8dWp3ACtSIZ8YCetiex7w</a> 提取码: 4rqy</li><li>老男孩脱产班linux运维51期<br>链接: <a href="https://pan.baidu.com/s/1VBkdwt_0ijgAx8p6pMQgQg">https://pan.baidu.com/s/1VBkdwt_0ijgAx8p6pMQgQg</a> 提取码: b1bb</li><li>黑马 Linux云计算运维开发3.0（完整资料） 链接: <a href="https://pan.baidu.com/s/1xWcfQDHeiYCLgzynMHQ01g">https://pan.baidu.com/s/1xWcfQDHeiYCLgzynMHQ01g</a> 提取码: 3x75</li></ol><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><ol><li>MSB-操作系统（第一期） 链接: <a href="https://pan.baidu.com/s/1IDGO9rgsv5lsiDeobFsv5g">https://pan.baidu.com/s/1IDGO9rgsv5lsiDeobFsv5g</a> 提取码: a039</li></ol><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><ol><li><p>分布式存储极致性能Redis6  直奔阿里P6-P7水平<br>链接: <a href="https://pan.baidu.com/s/1KI2LENhYLHiNdPKC7yu5IA">https://pan.baidu.com/s/1KI2LENhYLHiNdPKC7yu5IA</a> 提取码: zrci</p></li><li><p>数据库精讲课程<br>链接: <a href="https://pan.baidu.com/s/182QED7hvx_Bx33dZCJg6gg">https://pan.baidu.com/s/182QED7hvx_Bx33dZCJg6gg</a> 提取码: rc34</p></li><li><p>慕课网_Redis 从入门到高可用分布式实践</p><p>链接为：<a href="https://www.aliyundrive.com/s/njCUiUzvghr">https://www.aliyundrive.com/s/njCUiUzvghr</a></p></li><li><p>MySQL 教程 合集 <a href="https://www.aliyundrive.com/s/UkqLs3B5NvA">https://www.aliyundrive.com/s/UkqLs3B5NvA</a></p></li><li><p>尚硅谷MySQL入门到高级-宋红康版 链接: <a href="https://pan.baidu.com/s/15GuRtujBZy9ECuZDuQK0XA">https://pan.baidu.com/s/15GuRtujBZy9ECuZDuQK0XA</a> 提取码: a8h7</p></li></ol><h1 id="逆向破解"><a href="#逆向破解" class="headerlink" title="逆向破解"></a>逆向破解</h1><ol><li>易语言 安卓逆向<br>链接: <a href="https://pan.baidu.com/s/1mrtQaIPlPhlZUYifVdPcAA">https://pan.baidu.com/s/1mrtQaIPlPhlZUYifVdPcAA</a> 提取码: 09hn</li></ol><h1 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h1><ol><li><p>网络安全最新视频 1-20天课程<br>链接: <a href="https://pan.baidu.com/s/10rjtxz0hHsPhPcJEg4eEvA">https://pan.baidu.com/s/10rjtxz0hHsPhPcJEg4eEvA</a> 提取码: 93ws</p></li><li><p>网络安全总监Kail渗透测试代码审计等保测评应急响应<br>链接: <a href="https://pan.baidu.com/s/1LpbHMB5KHWbeZQZmEQ0s9w">https://pan.baidu.com/s/1LpbHMB5KHWbeZQZmEQ0s9w</a> 提取码: 173t</p></li><li><p>网络安全入门到入灰<br>链接: <a href="https://pan.baidu.com/s/1qZCthSTt2lCu4AyT9Cpeuw">https://pan.baidu.com/s/1qZCthSTt2lCu4AyT9Cpeuw</a> 提取码: 3e28</p></li><li><p>全栈网络安全专家<br>链接: <a href="https://pan.baidu.com/s/1GqqBpcOl8m9ARP-BaNTSTQ">https://pan.baidu.com/s/1GqqBpcOl8m9ARP-BaNTSTQ</a> 提取码: 5ctb</p></li><li><p>Kali Linux安全测试</p><p>链接：<a href="https://www.aliyundrive.com/s/w6exnNkZfQd">https://www.aliyundrive.com/s/w6exnNkZfQd</a></p></li><li><p>网络安全与网络认证 教程合集 <a href="https://www.aliyundrive.com/s/1qmGjftTXwu">https://www.aliyundrive.com/s/1qmGjftTXwu</a></p></li></ol><h1 id="虚拟引擎"><a href="#虚拟引擎" class="headerlink" title="虚拟引擎"></a>虚拟引擎</h1><ol><li>UE4虚拟引擎开发教程<br>链接: <a href="https://pan.baidu.com/s/1FA5uBKTsSoZMosEtjYGAng">https://pan.baidu.com/s/1FA5uBKTsSoZMosEtjYGAng</a> 提取码: w691</li></ol><h1 id="手机端开发"><a href="#手机端开发" class="headerlink" title="手机端开发"></a>手机端开发</h1><h2 id="鸿蒙"><a href="#鸿蒙" class="headerlink" title="鸿蒙"></a>鸿蒙</h2><ol><li>HarmonyOS鸿蒙 快速入门应用开发进阶<br>链接: <a href="https://pan.baidu.com/s/1P2hPKiHdp247ETNyykkh2w">https://pan.baidu.com/s/1P2hPKiHdp247ETNyykkh2w</a> 提取码: dvu3</li></ol><h2 id="小程序"><a href="#小程序" class="headerlink" title="小程序"></a>小程序</h2><ol><li>微信小程序（千峰版）<br>链接: <a href="https://pan.baidu.com/s/1-Ku-exEvHbCXrbQdseWNpQ">https://pan.baidu.com/s/1-Ku-exEvHbCXrbQdseWNpQ</a> 提取码: vmov</li><li>微信小程序（极客版）<br>链接: <a href="https://pan.baidu.com/s/16MkQkv2DRaNhupd-NoYrXA">https://pan.baidu.com/s/16MkQkv2DRaNhupd-NoYrXA</a> 提取码: 7do6</li><li>干货！5搞小时搞定微信小程序开发<br>链接: <a href="https://pan.baidu.com/s/1TaTsMJf5whSySHsnAvwglQ">https://pan.baidu.com/s/1TaTsMJf5whSySHsnAvwglQ</a> 提取码: 4a9y</li><li>微信小程序入门与实战-2020全新版 链接: <a href="https://pan.baidu.com/s/1Ulw7gpQ0Or-VnoFe8kBbVQ">https://pan.baidu.com/s/1Ulw7gpQ0Or-VnoFe8kBbVQ</a> 提取码: rj1m</li></ol><h1 id="产品经理"><a href="#产品经理" class="headerlink" title="产品经理"></a>产品经理</h1><ol><li>开课吧-产品经理护航计划2021<br>链接: <a href="https://pan.baidu.com/s/1SSkkilRc3xiyj4IxO41VWw">https://pan.baidu.com/s/1SSkkilRc3xiyj4IxO41VWw</a> 提取码: 6688</li><li>2020年最新黑马产品经理课程（完整资料）<br>链接: <a href="https://pan.baidu.com/s/17bKgHOVzzdGS2z3XRGXNAA">https://pan.baidu.com/s/17bKgHOVzzdGS2z3XRGXNAA</a> 提取码: 8369</li></ol><h1 id="软件测试"><a href="#软件测试" class="headerlink" title="软件测试"></a>软件测试</h1><ol><li>自动化工具Jmeter 入门到进阶6小时搞定<br>链接: <a href="https://pan.baidu.com/s/18mIgRmQjvUNGOf5XUYLpxg">https://pan.baidu.com/s/18mIgRmQjvUNGOf5XUYLpxg</a> 提取码: 5c8p</li><li>渗透测试全套（初高级）<br>链接: <a href="https://pan.baidu.com/s/1sB2c98JJL_QukH5PnUJHPQ">https://pan.baidu.com/s/1sB2c98JJL_QukH5PnUJHPQ</a> 提取码: 9t6k</li><li>黑马测试4.0 链接: <a href="https://pan.baidu.com/s/1ecj22xu679FqWe9o6r_B0w">https://pan.baidu.com/s/1ecj22xu679FqWe9o6r_B0w</a> 提取码: a1gm</li></ol><h1 id="考研"><a href="#考研" class="headerlink" title="考研"></a>考研</h1><ol><li>20天勤计算机复试上机辅导<br>链接: <a href="https://pan.baidu.com/s/1WamuZelJbRkEnRw9uCG6LQ">https://pan.baidu.com/s/1WamuZelJbRkEnRw9uCG6LQ</a> 提取码: b19z</li></ol><h1 id="项目实战"><a href="#项目实战" class="headerlink" title="项目实战"></a>项目实战</h1><h2 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h2><ol><li>Java实战项目 双11互联网电商秒杀系统解决方案<br>链接: <a href="https://pan.baidu.com/s/1IVXHoPB4_yxxITgC6pXDFw">https://pan.baidu.com/s/1IVXHoPB4_yxxITgC6pXDFw</a> 提取码: jgx8</li><li>Java企业级实战全栈项目 中信CRM（完整资料）<br>链接: <a href="https://pan.baidu.com/s/1LHSRVgYrrKOMMQXrpx2ZYw">https://pan.baidu.com/s/1LHSRVgYrrKOMMQXrpx2ZYw</a> 提取码: 4y6e</li><li>Java企业级项目 易购商城（完整资料）<br>链接: <a href="https://pan.baidu.com/s/1GqAzvlX-2YiJ9jH4p1i2jA">https://pan.baidu.com/s/1GqAzvlX-2YiJ9jH4p1i2jA</a> 提取码: qkwf</li><li>Spark离线和实时电影推荐系统直播回放(视频+文档+代码）<br>链接: <a href="https://pan.baidu.com/s/1HS-3xXqhe_zKx6ujbCwqgQ">https://pan.baidu.com/s/1HS-3xXqhe_zKx6ujbCwqgQ</a> 提取码: 074a</li><li>Java智能电话本项目实战（完整资料） 链接: <a href="https://pan.baidu.com/s/13Qc_T9Z6FCcunpITpOgCqA">https://pan.baidu.com/s/13Qc_T9Z6FCcunpITpOgCqA</a> 提取码: 7xeh</li></ol><h2 id="python-1"><a href="#python-1" class="headerlink" title="python"></a>python</h2><ol><li>聊天机器人视频课程【完整资料】<br>链接: <a href="https://pan.baidu.com/s/1PYlJo8bos_peM9Uq5LBWrQ">https://pan.baidu.com/s/1PYlJo8bos_peM9Uq5LBWrQ</a> 提取码: 9892</li><li>Java企业级项目 对标阿里P7 P8《锋迷商城》项目实战（完结 资料完整）<br>链接: <a href="https://pan.baidu.com/s/10jNU6SbLswkN28kNACUeAA">https://pan.baidu.com/s/10jNU6SbLswkN28kNACUeAA</a> 提取码: x406</li></ol><h2 id="Go-1"><a href="#Go-1" class="headerlink" title="Go"></a>Go</h2><ol><li>2020年最新 Go语言零基础微服务项目<br>链接: <a href="https://pan.baidu.com/s/156qMNvpXSvQObz_H_QKG2g">https://pan.baidu.com/s/156qMNvpXSvQObz_H_QKG2g</a> 提取码: h10k</li><li>Go语言实战班1期<br>链接: <a href="https://pan.baidu.com/s/1-L62OqrD4a4M5gMeNABupw">https://pan.baidu.com/s/1-L62OqrD4a4M5gMeNABupw</a> 提取码: 795k</li><li>Golang语言企业级项目 仿百度网盘（完整资料）<br>链接: <a href="https://pan.baidu.com/s/14Vl791uMDaSjbZHaxPAoDw">https://pan.baidu.com/s/14Vl791uMDaSjbZHaxPAoDw</a> 提取码: 4t6z</li></ol><h2 id="毕设"><a href="#毕设" class="headerlink" title="毕设"></a>毕设</h2><ol><li>程序员毕设全流程课程<br>链接: <a href="https://pan.baidu.com/s/1kSQwZq5eAGQA88Q3_nGQtA">https://pan.baidu.com/s/1kSQwZq5eAGQA88Q3_nGQtA</a> 提取码: 4851</li><li>人工智能顶级实战工程师就业课程 链接: <a href="https://pan.baidu.com/s/16Kx3pLw2Hwta-Ft4MzQMYg">https://pan.baidu.com/s/16Kx3pLw2Hwta-Ft4MzQMYg</a> 提取码: v1ez</li></ol><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><ol><li>从0打造微前端框架，实战汽车资讯平台<br>链接: <a href="https://pan.baidu.com/s/1y2x00EAvFFbkhzMhGj24Dg">https://pan.baidu.com/s/1y2x00EAvFFbkhzMhGj24Dg</a> 提取码: ex9i</li><li>React 实战简书项目（完整资料）<br>链接: <a href="https://pan.baidu.com/s/1--PZ49anJ_drz67e6owfIA">https://pan.baidu.com/s/1--PZ49anJ_drz67e6owfIA</a> 提取码: 816g</li><li>大型Vue项目实战-尚品汇（完整资料） 链接: <a href="https://pan.baidu.com/s/1JI1F6QOSaIbhfmGDa0rY8w">https://pan.baidu.com/s/1JI1F6QOSaIbhfmGDa0rY8w</a> 提取码: 45pb</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习资料 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习资料 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划刷题入门</title>
      <link href="/posts/33655.html"/>
      <url>/posts/33655.html</url>
      
        <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><blockquote><p>动态规划常常适用于有重叠子问题和最优子结构性质的问题，并且记录所有子问题的结果，因此动态规划方法所耗时间往往远少于朴素解法。 </p><p>动态规划有自底向上和自顶向下两种解决问题的方式。自顶向下即记忆化递归，自底向上就是递推。 </p><p>使用动态规划解决的问题有个明显的特点，一旦一个子问题的求解得到结果，以后的计算过程就不会修改它，这样的特点叫做无后效性，求解问题的过程形成了一张有向无环图。动态规划只解决每个子问题一次，具有天然剪枝的功能，从而减少计算量。</p></blockquote><h1 id="入门题"><a href="#入门题" class="headerlink" title="入门题"></a>入门题</h1><h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><p><a href="https://leetcode-cn.com/problems/fibonacci-number/">509. 斐波那契数 - 力扣（LeetCode） (leetcode-cn.com)</a></p><blockquote><p>斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：</p><p>F(0) = 0，F(1) = 1<br>F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1<br>给你 n ，请计算 F(n) 。</p><p><strong>示例 1：</strong></p><p>输入：2<br>输出：1<br>解释：F(2) = F(1) + F(0) = 1 + 0 = 1</p><p><strong>示例 2：</strong></p><p>输入：3<br>输出：2<br>解释：F(3) = F(2) + F(1) = 1 + 1 = 2</p><p><strong>示例 3：</strong></p><p>输入：4<br>输出：3<br>解释：F(4) = F(3) + F(2) = 2 + 1 = 3</p><p><strong>提示：</strong></p><p>0 &lt;= n &lt;= 30</p></blockquote><p>斐波那契数列的特点是：$ f(n)=f(n-1)+f(n-2) $，也是此题的 dp 方程。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {    public int fib(int n) {        if (n == 0 || n == 1){            return n;        }        return fib(n - 1) + fib(n - 2);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/sehowyoung/images/raw/master/202108262041283.png" alt="提交"></p><h2 id="第N个泰波纳契数"><a href="#第N个泰波纳契数" class="headerlink" title="第N个泰波纳契数"></a>第N个泰波纳契数</h2><p><a href="https://leetcode-cn.com/problems/n-th-tribonacci-number/">1137. 第 N 个泰波那契数 - 力扣（LeetCode） (leetcode-cn.com)</a></p><blockquote><p>泰波那契序列 $T_{n}$ 定义如下： </p><p>$T_{0} =0$, </p><p>$T_{1} = 1$, </p><p>$T_{2}=1$, </p><p>且在 n &gt;= 0 的条件下 </p><p>$T<em>{n + 3}=T</em>{n}+T<em>{n+1}+T</em>{n+2}$</p><p>给你整数 <code>n</code>，请返回第 n 个泰波那契数 $T_{n}$ 的值。</p><p><strong>示例 1：</strong></p><p>输入：n = 4<br>输出：4<br>解释：<br>T_3 = 0 + 1 + 1 = 2<br>T_4 = 1 + 1 + 2 = 4</p><p><strong>示例 2：</strong></p><p>输入：n = 25<br>输出：1389537</p><p><strong>提示：</strong></p><ul><li>0 &lt;= n &lt;= 37</li><li>答案保证是一个 32 位整数，即 answer &lt;= 2^31 - 1。</li></ul></blockquote><p>这道题其实和上面的有点类似，但如果我们还用上面那道题的递归来做（代码如下），就会发现超出时间限制，其实就是因为使用递归会进行大量的重复计算。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {    public int tribonacci(int n) {        if (n &lt; 2){            return n;        } else if (n == 2){            return 1;        }        return tribonacci(n - 1) + tribonacci(n - 2) + tribonacci(n - 3);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/sehowyoung/images/raw/master/202108280833786.png" alt="image-20210828083349599"></p><p>但如果创造一个数组来存储值，将会大大减少重复计算的数据量。</p><p>动归方程：$dp[n] = dp[n-1] + dp[n-2] + dp[n-3]$</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {    public int tribonacci(int n) {        int[] dp = new int[3];        dp[1] = 1;        dp[2] = 1;        for (int i = 3; i &lt;= n; i++) {            dp[i % 3] = dp[0] + dp[1] + dp[2];        }        return dp[n % 3];    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/sehowyoung/images/raw/master/202108280835450.png" alt="image-20210828083543424"></p><h2 id="使用最小花费爬楼梯"><a href="#使用最小花费爬楼梯" class="headerlink" title="使用最小花费爬楼梯"></a>使用最小花费爬楼梯</h2><p><a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/">746. 使用最小花费爬楼梯 - 力扣（LeetCode） (leetcode-cn.com)</a></p><blockquote><p>数组的每个下标作为一个阶梯，第 <code>i</code> 个阶梯对应着一个非负数的体力花费值 <code>cost[i]</code>（下标从 0 开始）。</p><p>每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。</p><p>请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。</p><p><strong>示例 1：</strong></p><p>输入：cost = [10, 15, 20]<br>输出：15<br>解释：最低花费是从 cost[1] 开始，然后走两步即可到阶梯顶，一共花费 15 。</p><p><strong>示例 2：</strong></p><p>输入：cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]<br>输出：6<br>解释：最低花费方式是从 cost[0] 开始，逐个经过那些 1 ，跳过 cost[3] ，一共花费 6 。</p><p><strong>提示：</strong></p><ul><li>cost 的长度范围是 [2, 1000]。</li><li>cost[i] 将会是一个整型数据，范围为 [0, 999] 。</li></ul></blockquote><p>本题其实就是计算达到下标<code>n</code>的最小花费，因此要通过动态规划来求解。</p><p>创建数组长度为<code>n + 1</code>的数组<code>dp</code>，其中<code>dp[i]</code>表示到下标<code>i</code>的最小花费，因此<code>dp</code>方程为：</p><p>$dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])$</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {    public int minCostClimbingStairs(int[] cost) {        int[] dp = new int[cost.length + 1];        for (int i = 2; i &lt; dp.length; i++) {            dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i -2] + cost[i - 2]);        }        return dp[dp.length - 1];    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/sehowyoung/images/raw/master/202108280919406.png" alt="image-20210828091940372"></p><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(n)$</li></ul><p>但是其实使用的空间是可以压缩的，我们这里只需要获取<code>dp[i - 1]</code>和<code>dp[i-2]</code>的值，因此，我们只需要2个变量来存储就可以了。其中<code>pre</code>代表前一个值，相当于<code>dp[i - 2]</code>，<code>curr</code>代表当前值，相当于<code>dp[i - 1]</code>。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {    public int minCostClimbingStairs(int[] cost) {        int pre = 0;        int curr = 0;        for (int i = 2; i &lt; cost.length + 1; i++){            int next = Math.min(pre + cost[i - 2], curr + cost[i - 1]);            pre = curr;            curr = next;        }        return curr;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><h1 id="中等题"><a href="#中等题" class="headerlink" title="中等题"></a>中等题</h1><h2 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h2><p><a href="https://leetcode-cn.com/problems/house-robber/">198. 打家劫舍 - 力扣（LeetCode） (leetcode-cn.com)</a></p><blockquote><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><p><strong>示例 1：</strong></p><p>输入：[1,2,3,1]<br>输出：4<br>解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。<br>    偷窃到的最高金额 = 1 + 3 = 4 。</p><p><strong>示例 2：</strong></p><p>输入：[2,7,9,3,1]<br>输出：12<br>解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。<br>    偷窃到的最高金额 = 2 + 9 + 1 = 12 。</p><p><strong>提示：</strong></p><ul><li>1 &lt;= nums.length &lt;= 100</li><li>0 &lt;= nums[i] &lt;= 400</li></ul></blockquote><p>创建长度为<code>nums.length</code>的dp数组，<code>dp[i]</code>表示在前<code>i</code>家内偷到的最大金额，因为小偷总共有两种偷盗方式：</p><ul><li>偷第<code>i</code>家，那么<code>dp[i] = dp[i - 2] + nums[i]</code></li><li>不偷第<code>i</code>家，那就是偷第<code>i - 1</code>家，那么<code>dp[i] = dp[i - 1]</code></li></ul><p>因此其dp方程为：</p><p>$dp[i] = Math.max(dp[i - 1], dp[i - 2] + cost[i])$</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {    public int rob(int[] nums) {        if (nums.length == 1){            return nums[0];        }        int[] dp = new int[nums.length];        dp[0] = nums[0];        dp[1] = Math.max(nums[0], nums[1]);        for (int i = 2; i &lt; nums.length; i++) {            dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);        }        return dp[dp.length - 1];    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/sehowyoung/images/raw/master/202108281016477.png" alt="image-20210828101606441"></p><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(n)$</li></ul><p>此外，也可以进行滚动数组优化，采用两个变量来完成，同<a href="https://blog.howyoung.work/posts/33655.html#使用最小花费爬楼梯">使用最小花费爬楼梯</a>一样。</p><h2 id="打家劫舍II"><a href="#打家劫舍II" class="headerlink" title="打家劫舍II"></a>打家劫舍II</h2><p><a href="https://leetcode-cn.com/problems/house-robber-ii/">213. 打家劫舍 II - 力扣（LeetCode） (leetcode-cn.com)</a></p><blockquote><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。</p><p><strong>示例 1：</strong></p><p>输入：nums = [2,3,2]<br>输出：3<br>解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。</p><p><strong>示例 2：</strong></p><p>输入：nums = [1,2,3,1]<br>输出：4<br>解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。<br>    偷窃到的最高金额 = 1 + 3 = 4 。</p><p><strong>示例 3：</strong></p><p>输入：nums = [0]<br>输出：0</p><p><strong>提示：</strong></p><ul><li>1 &lt;= nums.length &lt;= 100</li><li>0 &lt;= nums[i] &lt;= 1000</li></ul></blockquote><p>创建长度为<code>nums.length</code>的数组<code>dp</code>，其中<code>dp[i]</code>表示前i家的最大偷盗金额。那么在上一道的条件上，分为两种情况：</p><ul><li>如果偷盗最后一家，就可以将数组剪切掉第一个数，使用上一题的方法进行判断</li><li>如果不偷盗最后一家，就可以剪掉数组最后一个数，使用上一题的方法进行判断</li></ul><p>返回结果就是这两者的最大值。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {    public int rob(int[] nums) {        if (nums.length == 1){            return nums[0];        } else if (nums.length == 2){            return Math.max(nums[0], nums[1]);        }        return Math.max(myrob(Arrays.copyOfRange(nums, 1, nums.length)),                         myrob(Arrays.copyOfRange(nums, 0, nums.length - 1)));    }    public int myrob(int[] nums){        int pre = nums[0];        int cur = Math.max(pre, nums[1]);        for (int i = 2; i &lt; nums.length; i++) {            int next = Math.max(pre + nums[i], cur);            pre = cur;            cur = next;        }        return cur;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/sehowyoung/images/raw/master/202108281117366.png" alt="image-20210828111706324"></p><h2 id="删除并获得点数"><a href="#删除并获得点数" class="headerlink" title="删除并获得点数"></a>删除并获得点数</h2><p><a href="https://leetcode-cn.com/problems/delete-and-earn/">740. 删除并获得点数 - 力扣（LeetCode） (leetcode-cn.com)</a></p><blockquote><p>给你一个整数数组 nums ，你可以对它进行一些操作。</p><p>每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后，你必须删除 所有 等于 nums[i] - 1 和 nums[i] + 1 的元素。</p><p>开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。</p><p><strong>示例 1：</strong></p><p>输入：nums = [3,4,2]<br>输出：6<br>解释：<br>删除 4 获得 4 个点数，因此 3 也被删除。<br>之后，删除 2 获得 2 个点数。总共获得 6 个点数。</p><p><strong>示例 2：</strong></p><p>输入：nums = [2,2,3,3,3,4]<br>输出：9<br>解释：<br>删除 3 获得 3 个点数，接着要删除两个 2 和 4 。<br>之后，再次删除 3 获得 3 个点数，再次删除 3 获得 3 个点数。<br>总共获得 9 个点数。</p><p><strong>提示：</strong></p><ul><li>1 &lt;= nums.length &lt;= 2 * 104</li><li>1 &lt;= nums[i] &lt;= 104</li></ul></blockquote><h3 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h3><p>根据题意，在选择了元素<code>x</code>后，该元素以及所有等于<code>x-1</code>或<code>x+1</code>的元素会从数组中删去。若还有多个值为<code>x</code>的元素，由于所有等于<code>x-1</code>或<code>x+1</code>的元素已经被删除，我们可以直接删除<code>x</code>并获得其点数。因此若选择了<code>x</code>，所有等于<code>x</code>的元素也应一同被选择，以尽可能多地获得点数。</p><p>记元素<code>x</code>在数组中出现的次数为$c_{x}$，我们可以用一个数组<code>sum</code>录数组<code>nums</code>中所有相同元素之和，即 \textit{sum}</p><p>$sum[x] = x * c_{x}$</p><p>若选择了<code>x</code>，则可以获取<code>sum[x]</code>的点数，且无法再选择<code>x−1</code>和<code>x+1</code>。这与「打家劫舍」是一样的，在统计出 <code>sum</code>数组后，读者可参考<a href="https://blog.howyoung.work/posts/33655.html#打家劫舍">打家劫舍</a>中的动态规划过程计算出答案。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {    public int deleteAndEarn(int[] nums) {        int max = nums[0];        for (int num : nums){            max = Math.max(num, max);        }        int[] sum = new int[max + 1];        for (int num : nums) {            sum[num] += num;        }        return rob(sum);    }    public int rob(int[] nums){        if (nums.length == 2){            return nums[1];        }        int pre = nums[1];        int cur = Math.max(pre, nums[2]);        for (int i = 3; i &lt; nums.length; i++) {            int next = Math.max(pre + nums[i], cur);            pre = cur;            cur = next;        }        return cur;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/sehowyoung/images/raw/master/202108282303984.png" alt="image-20210828230334936"></p><ul><li>时间复杂度：$O(N+M)$，<code>N</code>为nums数组的长度，<code>M</code>为nuns数组中最大的值</li><li>空间复杂度：$O(M)$</li></ul><h3 id="方法二：排序-动态规划"><a href="#方法二：排序-动态规划" class="headerlink" title="方法二：排序 + 动态规划"></a>方法二：排序 + 动态规划</h3><p>注意到若<code>nums</code>中不存在某个元素<code>x</code>，则选择任一小于<code>x</code>的元素不会影响到大于<code>x</code>的元素的选择。因此我们可以将 <code>nums</code>排序后，将其划分成若干连续子数组，子数组内任意相邻元素之差不超过<code>1</code>。对每个子数组按照方法一的动态规划过程计算出结果，累加所有结果即为答案。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {    public int deleteAndEarn(int[] nums) {        int n = nums.length;        int ans = 0;        Arrays.sort(nums);        List&lt;Integer&gt; sum = new ArrayList&lt;Integer&gt;();        sum.add(nums[0]);        int size = 1;        for (int i = 1; i &lt; n; i++) {            int val = nums[i];            if (val == nums[i - 1]) {                sum.set(size - 1, sum.get(size - 1) + val);            } else if (val == nums[i - 1] + 1) {                sum.add(val);                size++;            } else {                ans += rob(sum);                sum.clear();                sum.add(val);                size = 1;            }        }        ans += rob(sum);        return ans;    }    public int rob(List&lt;Integer&gt; nums) {        int size = nums.size();        if (size == 1) {            return nums.get(0);        }        int first = nums.get(0), second = Math.max(nums.get(0), nums.get(1));        for (int i = 2; i &lt; size; i++) {            int temp = second;            second = Math.max(first + nums.get(i), second);            first = temp;        }        return second;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(NlogN)$，其中<code>N</code>是数组<code>nums</code>的长度。对<code>nums</code>排序需要花费$O(NlogN)$的时间，遍历计算需要花费$O(N)$的时间，故总的时间复杂度为$O(NlogN)$。</li><li>空间复杂度：$O(N)$。统计 <code>sum</code>至多需要花费$O(N)$的空间。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯法</title>
      <link href="/posts/58235.html"/>
      <url>/posts/58235.html</url>
      
        <content type="html"><![CDATA[<h1 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h1><p><strong>回溯法（back tracking）</strong>（探索与回溯法）是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 回溯法 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务架构学习笔记</title>
      <link href="/posts/63498.html"/>
      <url>/posts/63498.html</url>
      
        <content type="html"><![CDATA[<h1 id="微服务架构介绍"><a href="#微服务架构介绍" class="headerlink" title="微服务架构介绍"></a>微服务架构介绍</h1><h2 id="技术架构演变"><a href="#技术架构演变" class="headerlink" title="技术架构演变"></a>技术架构演变</h2><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210718200826947.png" alt="技术架构的演变" style="zoom:50%;"></p><h3 id="单体架构"><a href="#单体架构" class="headerlink" title="单体架构"></a>单体架构</h3><p>单体架构也被称为单体系统或者是单体应用，是一种把所有的功能、模块耦合在一个应用中的架构方式。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol><li>打包成一个独立的单元（一个 jar 包或者一个 war 包）</li><li>以一个进程的方式来运行</li></ol><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li>优点：<ul><li>项目易于管理</li><li>部署简单</li></ul></li><li>缺点：<ul><li>测试成本高</li><li>可伸缩性差</li><li>可靠性差</li><li>系统迭代困难</li><li>跨语言程度差</li><li>团队协作难</li></ul></li></ul><h3 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h3><p>微服务是一种架构风格，一个复杂的软件应用，有一个或多个服务组成。系统中的各个微服务可被独立部署，各个微服务之间是松耦合的。每个微服务仅仅关注并完成一个任务。</p><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ol><li>系统是由多个服务构成</li><li>每个服务可以单独部署</li><li>每个服务之间是松耦合的，服务内部是高内聚的（每个服务只关注完成一个功能），外部是低耦合的。</li></ol><h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li>优点：<ul><li>测试容易</li><li>可伸缩性强</li><li>可靠性强</li><li>跨语言成都更灵活</li><li>团队协作容易</li><li>系统迭代容易</li></ul></li><li>缺点：<ul><li>运维成本高，部署数量较多</li><li>接口兼容多版本</li><li>分布式系统的复杂性</li><li>分布式事务</li></ul></li></ul><h3 id="常见软件架构方式的区别"><a href="#常见软件架构方式的区别" class="headerlink" title="常见软件架构方式的区别"></a>常见软件架构方式的区别</h3><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210719192354021.png" alt="MVC、RPC、SOA、微服务架构区别" style="zoom:67%;"></p><p>ESB（Enterprise Service Bus）：企业服务总线，起到中介的作用，主要是提供了服务与服务之间的交互。包含了负载均衡、流量控制、加密处理、服务监控、异常处理等功能。</p><div class="table-container"><table><thead><tr><th></th><th>MVC架构</th><th>RPC架构</th><th>SOA架构</th><th>微服务架构</th></tr></thead><tbody><tr><td>介绍</td><td>单体架构</td><td>RPC（Remote Procedure Call）：远程过程调用，通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的一种技术</td><td>SOA（Service Oriented Architecture）：面向服务架构</td><td>轻量级的服务治理方案，拥有服务注册中心</td></tr><tr><td>代表技术</td><td>Structs2、Spring MVC、Spring、Mybatis</td><td>Thrift、Hession</td><td>Mule、WSO2</td><td>Spring Cloud</td></tr></tbody></table></div><h2 id="微服务的设计原则"><a href="#微服务的设计原则" class="headerlink" title="微服务的设计原则"></a>微服务的设计原则</h2><h3 id="AKF-拆分原则"><a href="#AKF-拆分原则" class="headerlink" title="AKF 拆分原则"></a>AKF 拆分原则</h3><p>业界对于可扩展的系统架构设计 有一个朴素的理念就是<strong>通过加机器就可以解决容量和可用性问题</strong>（如果一台不行，那就两台）。 </p><p>这一理念在“云计算”概念疯狂流行的今天，得到了广泛的认可！对于一个规模迅速增长的系统而言，容量和性能间题当然是首当其冲的，但是随着时间的推移，系统规模的增长，除了面对性能与容量的问题外，还需要面对功能与模块数量上的增长带来的系统复杂性问题以及业务的变化带来的提供差异化服务问题。而许多系统，在架构设计时并未充分考虑到这些间题，导政系统的重构成为常态，从而影响业务交付能力，还浪费人力财力！对此，《可扩展的艺术》一书提出了ー个更加系统的可扩展模型一一AKF 可扩展立方(Scalability Cube),这个立方体中沿着三个坐标轴设置分别为X、Y、Z</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210720175420134.png" alt="AKF 扩展立方体"></p><ul><li>X 轴：关注水平拓展，即通过加机器解决问题</li><li>Y 轴：关注应用中功能划分，基于不同业务拆分</li><li>Z 轴：关注服务和数据的优先级划分</li></ul><p>微服务拆分方式：</p><ul><li>按不同功能进行拆分</li></ul><p>微服务拆分要点：</p><ul><li>低耦合、高内聚：一个服务只完成一个独立功能</li><li>按团队结构，小规模团队维护，快速进行迭代</li></ul><h4 id="功能拆分"><a href="#功能拆分" class="headerlink" title="功能拆分"></a>功能拆分</h4><p>对于一个电商平台，有以下功能，我们可以将其拆分成不同的服务，有如下架构：</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210720180644479.png" alt="功能架构" style="zoom:50%;"></p><p>当服务数量不断增多，服务间的调用关系将变得更加复杂。因此，我们可以采用服务注册的机制形成服务网关来进行服务治理。这样看起来就会非常清晰、简洁，拓展新的服务也将变得更加容易。</p><p><img src="C:\Users\84661\AppData\Roaming\Typora\typora-user-images\image-20210720181012524.png" alt="增加服务网关的架构" style="zoom:50%;"></p><h4 id="水平拓展"><a href="#水平拓展" class="headerlink" title="水平拓展"></a>水平拓展</h4><p>Ⅹ 轴扩展与我们前面朴素理念是一致的，通过绝对平等地复制服务与数据，以解决容量和可用性的问题。其实就是将微服务运行多个实例，做集群加负载均衡的模式。</p><p>为了提升单个服务的可用性和容量，<strong>对每一个服务进行 X 轴扩展划分</strong>。</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210720181340198.png" alt="进行水平拓展后的架构" style="zoom:50%;"></p><h4 id="数据分区"><a href="#数据分区" class="headerlink" title="数据分区"></a>数据分区</h4><p>Z 轴扩展通常是指基于请求者或用户独特的需求，进行系统划分，并使得划分出来的子系统是相互隔离但又是完整的。以生产汽车的工厂来举例：福特公司为了发展在中国的业务，或者利用中国的廉价劳动力，在中国建立一个完整的子工厂，与美国工厂一样，负责完整的汽车生产。这就是一种 Z 轴扩展。</p><h3 id="前后端分离原则"><a href="#前后端分离原则" class="headerlink" title="前后端分离原则"></a>前后端分离原则</h3><p><img src="https://gitee.com/sehowyoung/images/raw/master/1394466-20180916231716242-1862208927.png" alt="前后端分离" style="zoom:50%;"></p><p>使用前后端分离的好处：</p><ol><li>前后端技术分离，可以由各自的专家来进行优化，可以是前端的用户体验更好</li><li>分离模式下，前后端交互界面更清晰，后端的接口简洁明了，更容易维护。</li><li>前端多渠道集成场景更容易实现，后端服务无需变更，采用统一的数据和模型，可以支持多个前端</li></ol><h3 id="无状态服务"><a href="#无状态服务" class="headerlink" title="无状态服务"></a>无状态服务</h3><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210720234626826.png" alt="无状态服务"></p><p>对于无状态服务，首先说一下什么是状态：如果一个数据需要被多个服务共享，才能完成一笔交易，那么这个数据被称为状态。进而依赖这个“状态”数据的服务被称为有状态服务，反之称为无状态服务。</p><p>那么这个无状态服务原则并不是说在微服务架构里就不允许存在状态，表达的真实意思是要把有状态的业务服务改变为无状态的计算类服务，那么状态数据也就相应的迁移到对应的“有状态数据服务”中。</p><p>场景说明：例如我们以前在本地内存中建立的数据缓存、 Session缓存，到现在的微服务架构中就应该把这些数据迁移到分布式缓存中存储，让业务服务变成一个无状态的计算节点。迁移后，就可以做到按需动态伸缩，微服务应用在运行时动态增删节点，就不再需要考虑缓存数据如何同步的问题。</p><h3 id="RestFul-风格"><a href="#RestFul-风格" class="headerlink" title="RestFul 风格"></a>RestFul 风格</h3><blockquote><p>**表现层状态</p><p><strong>转换</strong>（<a href="https://zh.wikipedia.org/wiki/英语">英语</a>：<strong>Representational State Transfer</strong>，<a href="https://zh.wikipedia.org/wiki/縮寫">缩写</a>：<strong>REST</strong>）是<a href="https://zh.wikipedia.org/w/index.php?title=Roy_Thomas_Fielding&amp;action=edit&amp;redlink=1">Roy Thomas Fielding</a>博士于2000年在他的博士论文中提出来的一种<a href="https://zh.wikipedia.org/wiki/万维网">万维网</a><a href="https://zh.wikipedia.org/wiki/软件架构">软件架构</a>风格，目的是便于不同软件/程序在网络（例如互联网）中互相传递信息。表现层状态转换是根基于<a href="https://zh.wikipedia.org/wiki/超文本传输协议">超文本传输协议（HTTP）</a>之上而确定的一组约束和属性，是一种设计提供万维网络服务的<a href="https://zh.wikipedia.org/wiki/軟件架構">软件构建风格</a>。符合或兼容于这种架构风格（简称为 REST 或 RESTful）的网络服务，允许客户端发出以<a href="https://zh.wikipedia.org/wiki/统一资源标志符">统一资源标识符</a>访问和操作网络资源的请求，而与预先定义好的无状态操作集一致化。因此表现层状态转换提供了在互联网络的计算系统之间，彼此资源可交互使用的协作性质（interoperability）。相对于其它种类的网络服务，例如SOAP服务，则是以本身所定义的操作集，来访问网络上的资源。</p></blockquote><p>可以看一下<a href="https://www.ruanyifeng.com/blog/2011/09/restful.html">理解RESTful架构 - 阮一峰的网络日志 (ruanyifeng.com)</a></p><h1 id="Spring-Cloud-入门"><a href="#Spring-Cloud-入门" class="headerlink" title="Spring Cloud 入门"></a>Spring Cloud 入门</h1><h2 id="什么是Spring-Cloud"><a href="#什么是Spring-Cloud" class="headerlink" title="什么是Spring Cloud"></a>什么是Spring Cloud</h2><blockquote><p>Spring Cloud 是开发分布式系统的“全家桶”，是一系列框架的有序集合。Spring Cloud 利用 <a href="http://c.biancheng.net/spring_boot/">Spring Boot</a> 的开发便利性巧妙地简化了分布式系统基础设施的开发。</p><p>Spring Cloud 对于中小型互联网公司来说是一种福音，使用 Spring Cloud 一站式解决方案能在从容应对业务发展的同时大大减少开发成本。</p><p><a href="http://c.biancheng.net/spring_cloud/">Spring Cloud</a> 是一系列框架的有序集合。它利用 <a href="http://c.biancheng.net/spring/">Spring</a> Boot 的开发便利性，巧妙地简化了分布式系统基础设施的开发，如服务注册、服务发现、配置中心、消息总线、负载均衡、断路器、数据监控等，这些都可以用 Spring Boot 的开发风格做到一键启动和部署。</p><p>通俗地讲，Spring Cloud 就是用于构建微服务开发和治理的框架集合（并不是具体的一个框架），主要贡献来自 Netflix OSS。</p></blockquote><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>Spring Cloud 模块的相关介绍如下：</p><ul><li>Eureka：服务注册中心，用于服务管理。</li><li>Ribbon：基于客户端的负载均衡组件。</li><li>Hystrix：容错框架，能够防止服务的雪崩效应。</li><li>Feign：Web 服务客户端，能够简化 HTTP 接口的调用。</li><li>Zuul：API 网关，提供路由转发、请求过滤等功能。</li><li>Config：分布式配置管理。</li><li>Sleuth：服务跟踪。</li><li>Stream：构建消息驱动的微服务应用程序的框架。</li><li>Bus：消息代理的集群消息总线。</li></ul><p>除了上述模块，还有 Cli、Task等。</p><h2 id="Spring-Cloud-和-Dubbo-的区别"><a href="#Spring-Cloud-和-Dubbo-的区别" class="headerlink" title="Spring Cloud 和 Dubbo 的区别"></a>Spring Cloud 和 Dubbo 的区别</h2>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> spring cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_JZ12_数值的整数次方题解</title>
      <link href="/posts/26957.html"/>
      <url>/posts/26957.html</url>
      
        <content type="html"><![CDATA[<h1 id="剑指offerJZ12数值的整数次方题解"><a href="#剑指offerJZ12数值的整数次方题解" class="headerlink" title="剑指offerJZ12数值的整数次方题解"></a>剑指offer<em>JZ12</em>数值的整数次方题解</h1><blockquote><p><strong>描述</strong></p><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p><p>保证base和exponent不同时为0。不得使用库函数，同时不需要考虑大数问题，也不用考虑小数点后面0的位数。</p><p><strong>示例1</strong></p><blockquote><p>输入：2.00000,3</p><p>返回值：8.00000</p></blockquote><p><strong>示例2</strong></p><blockquote><p>输入：2.10000,3</p><p>返回值：9.26100</p></blockquote><p><strong>示例3</strong></p><blockquote><p>输入：2.00000, -2</p><p>返回值：0.25000</p></blockquote></blockquote><h2 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h2><p>不断进行乘法运算即可。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Solution {    public double Power(double base, int exponent) {        double ans = 1.0;        if (exponent == 0){            return ans;        } else if (exponent &gt; 0){            ans = base;            for (int i = 0; i &lt; exponent - 1; i++) {                ans *= base;            }        } else {            ans = 1 / base;            double temp = ans;            for (int i = exponent + 1; i &lt; 0; i++){                ans *= temp;            }        }        return ans;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="递归法（快速幂）"><a href="#递归法（快速幂）" class="headerlink" title="递归法（快速幂）"></a>递归法（快速幂）</h2><p>算法思路：</p><ol><li>如果是<code>exponent</code>是负数，就先转换，然后进入递归方法</li><li>在递归方法中进行判断，如果<code>exponent</code>为 0，则返回 1.0</li><li>判断<code>exponent</code>为技术还是偶数，如果是奇数，只需将<code>base</code>留出一个，继续进入递归</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Solution {    public double Power(double base, int exponent) {        if (exponent &lt; 0){            base = 1 / base;            exponent /= -1;        }        return pow(base, exponent);    }    public double pow(double base, int exponent){        if (exponent == 1){            return base;        } else if (exponent == 0){            return 1.0;        } else if (exponent == 2){            return base * base;        }        if (exponent % 2 == 1){            return base * pow(base, exponent - 1);        } else {            return pow(pow(base, exponent / 2), 2);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="非递归法（快速幂）"><a href="#非递归法（快速幂）" class="headerlink" title="非递归法（快速幂）"></a>非递归法（快速幂）</h2><p>算法思路：</p><ul><li>$2.0^{7}=2.0^{1+2+4}$，7的二进制位为：0111</li><li>按这样的思路，我们就可以只对指数二进中为 1 的位进行运算</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Solution {    public double Power(double base, int exponent) {        if (exponent &lt; 0){            base = 1 / base;            exponent /= -1;        } else if (exponent == 0) {            return 1.0;        }        double res = 1.0;        while (exponent != 0){            if ((exponent &amp; 1) != 0){                res *= base;            }            base *= base;            exponent &gt;&gt;= 1;        }        return res;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法题解 </tag>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_JZ11_二进制中的1的个数题解</title>
      <link href="/posts/40431.html"/>
      <url>/posts/40431.html</url>
      
        <content type="html"><![CDATA[<h1 id="剑指offerJZ11二进制中的1的个数题解"><a href="#剑指offerJZ11二进制中的1的个数题解" class="headerlink" title="剑指offerJZ11二进制中的1的个数题解"></a>剑指offer<em>JZ11</em>二进制中的1的个数题解</h1><blockquote><p><strong>描述</strong></p><p>输入一个整数，输出该数32位二进制表示中1的个数。其中负数用补码表示。</p><p><strong>示例1</strong></p><blockquote><p>输入：10</p><p>返回值：2</p></blockquote></blockquote><p><strong>知识点：</strong>位运算</p><h2 id="方法一：除-2-取模法"><a href="#方法一：除-2-取模法" class="headerlink" title="方法一：除 2 取模法"></a>方法一：除 2 取模法</h2><p>使用除 2 取模法还是比较好实现的。</p><p>但是经过测试，在一些负数问题上会出现错误，比如：-2147483648</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Solution {    public int NumberOf1(int n){        int num = 0;        while (n != 0){            int temp = n % 2;            n /= 2;            if (temp == 1){                num++;            }        }        return num;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="方法二：二进制移位运算"><a href="#方法二：二进制移位运算" class="headerlink" title="方法二：二进制移位运算"></a>方法二：二进制移位运算</h2><p>我们可以让 1 从右向左做与运算</p><p>例如：10：1010</p><ul><li>1010 &amp; 0001 = 0000;</li><li>1010 &amp; 0010 = 0010;</li><li>1010 &amp; 0100 = 0000;</li><li>1010 &amp; 1000 = 1000;</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Solution {    public int NumberOf1(int n){        int num = 0;        int mark = 1;        while (mark != 0){            if ((mark &amp; n) != 0){                num++;            }            mark &lt;&lt;= 1;        }        return num;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="方法三：位运算"><a href="#方法三：位运算" class="headerlink" title="方法三：位运算"></a>方法三：位运算</h2><p>考虑二进制数：num: 10010, num - 1: 10001; num &amp; (num - 1) = 10000，这样不就消去了一个 1 吗。而且效率肯定是比前两种方法高的。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Solution {    public int NumberOf1(int n){        int val = n;        int ans = 0;        while (val != 0){            ans++;            val = val &amp; (val - 1);            System.out.println(val);        }        return ans;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法题解 </tag>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nowcoder_NC76_反转链表题解</title>
      <link href="/posts/34898.html"/>
      <url>/posts/34898.html</url>
      
        <content type="html"><![CDATA[<h1 id="nowcoderNC76反转链表题解"><a href="#nowcoderNC76反转链表题解" class="headerlink" title="nowcoderNC76反转链表题解"></a>nowcoder<em>NC76</em>反转链表题解</h1><blockquote><p><strong>描述</strong></p><p>输入一个链表，反转链表后，输出新链表的表头</p><p><strong>示例</strong></p><blockquote><p>输入：  {1,2,3}</p><p>返回值：{3,2,1}</p></blockquote></blockquote><p>这道题目一眼看过去是比较简单的，简答的做法就是创建一个新的链表，然后返回就行了。</p><h2 id="方法一：构造链表"><a href="#方法一：构造链表" class="headerlink" title="方法一：构造链表"></a>方法一：构造链表</h2><p>做法就是先遍历链表，获取每个节点的值，存到一个 ArrayList 中，然后根据这些值创建新的链表即可。</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">/*public class ListNode {    int val;    ListNode next = null;     ListNode(int val) {        this.val = val;    }}*/import java.util.*; public class Solution {    public ListNode ReverseList(ListNode head) {        if (head == null){            return null;        }        List list = new ArrayList&lt;Integer&gt;();        while (head.next != null){            list.add(head.val);            head = head.next;        }        list.add(head.val);        ListNode node = new ListNode((Integer)list.get(list.size() - 1));        ListNode re = node;        for (int i = list.size() - 2; i &gt;= 0; i--){            node.next = new ListNode((Integer)list.get(i));            node = node.next;        }        return re;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="方法二：使用指针反转"><a href="#方法二：使用指针反转" class="headerlink" title="方法二：使用指针反转"></a>方法二：使用指针反转</h2><p>构造新链表的方法所说简单，但是其消耗的内存是很大的，那有没有一种方法是空间复杂度为 O(1) 的呢？答案，肯定是有点，我们需要两个指针即可。</p><p>算法描述：</p><ol><li>创建指针<code>first</code>，指针指向反转好的链表的第一个节点</li><li>创建指针<code>nex</code>，指向<code>head</code>节点的下一个节点</li><li>移动<code>nex</code>指针：<code>nex = head.next</code></li><li>断开<code>head</code>和<code>nex</code>的连接，连接<code>head</code>和<code>first</code>：<code>head.next = first</code></li><li>移动<code>head</code>和<code>first</code>指针</li><li>重复 3~5</li></ol><p>举例：</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210705140359237.png" alt="初始链表"></p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210705140713984.png" alt="一次循环操作"></p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210705140822781.png" alt="循环结束后"></p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><p>Java 实现：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">/*class ListNode {    int val;    ListNode next = null;    ListNode(int val) {        this.val = val;    }}*//** * @author  howyoung */public class Solution {    public ListNode ReverseList(ListNode head) {        // 指向已经反转好的链表的第一个节点        ListNode first = null;        // 指向待反转列表的第二个节点        ListNode nex = null;        while (head != null){            nex = head.next;            head.next = first;            first = head;            head = nex;        }        return first;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Go 实现：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">package mainimport . "nc_tools"/* * type ListNode struct{ *   Val int *   Next *ListNode * } *//** *  * @param pHead ListNode类  * @return ListNode类*/func ReverseList( pHead *ListNode ) *ListNode {    // write code herevar head *ListNodevar temp *ListNodefor pHead != nil {temp = pHeadpHead = pHead.Nexttemp.Next = headhead = temp}return head}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法题解 </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络知识总结</title>
      <link href="/posts/55932.html"/>
      <url>/posts/55932.html</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络知识总结"><a href="#计算机网络知识总结" class="headerlink" title="计算机网络知识总结"></a>计算机网络知识总结</h1><p><img src="https://gitee.com/sehowyoung/images/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.png" alt="计算机网络"></p><h2 id="网络概述"><a href="#网络概述" class="headerlink" title="网络概述"></a>网络概述</h2><p><img src="https://gitee.com/sehowyoung/images/raw/master/980266035_1565787665824_1ABB2DC3D76311944FFDBE9980FBAADD" alt="网络模型及对应的协议"></p><h2 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h2><h3 id="TCP-和-UDP-的区别"><a href="#TCP-和-UDP-的区别" class="headerlink" title="TCP 和 UDP 的区别"></a>TCP 和 UDP 的区别</h3><ul><li>是否面向连接：TCP 面向连接，UDP 无连接</li><li>传输可靠性：TCP 传输可靠，UDP 传输不可靠</li><li>传输形式：TCP 字节流形式传输，UDP 数据报文段形式传输</li><li>传输效率：TCP 较慢，UDP 较快</li><li>所需资源：TCP 多，UDP 少</li><li>应用场景：TCP 主要应用于通信数据可靠的传输，例如：文件传输、邮件收发等；UDP 主要应用于要求传输速度快的传输，例如：直播等</li></ul><h3 id="TCP-可靠传输"><a href="#TCP-可靠传输" class="headerlink" title="TCP 可靠传输"></a>TCP 可靠传输</h3><ul><li>应用数据被 TCP 分割成数据块</li><li>TCP 会给发送的每一个包编号，接收方对数据包进行排序，把有序数据传给应用层</li><li>校验和：TCP 将保持它首部和数据的校验和，目的是检测传输过程中的变化。</li><li>TCP 的接收端会丢弃重复的数据</li><li>流量控制：TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。TCP 使用的流量控制协议是可变大小的滑动窗口协议。</li><li>拥塞控制：当网络拥塞时，减少数据发送</li><li>ARQ 协议：停止等待 ARQ 协议和连续 ARQ 协议</li><li>超时重传：当 TCP 发出⼀个段后，它启动⼀个定时器，等待⽬的端确认收到这个报⽂段。如果不能及时收到⼀个确认，将重发这个报⽂段。  </li></ul><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h3 id="ARP-协议和-ARP-攻击"><a href="#ARP-协议和-ARP-攻击" class="headerlink" title="ARP 协议和 ARP 攻击"></a>ARP 协议和 ARP 攻击</h3><p>地址解析协议。ARP攻击的第一步就是ARP欺骗。由上述“ARP协议的工作过程”我们知道，ARP协议基本没有对网络的安全性做任何思考，当时人们考虑的重点是如何保证网络通信能够正确和快速的完成——ARP协议工作的前提是默认了其所在的网络是一个善良的网络，每台主机在向网络中发送应答信号时都是使用的真实身份。不过后来，人们发现ARP应答中的IP地址和MAC地址中的信息是可以伪造的，并不一定是自己的真实IP地址和MAC地址，由此，ARP欺骗就产生了。</p><h3 id="ICMP-协议"><a href="#ICMP-协议" class="headerlink" title="ICMP 协议"></a>ICMP 协议</h3><p>它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。</p><h3 id="路由器和交换机的区别"><a href="#路由器和交换机的区别" class="headerlink" title="路由器和交换机的区别"></a>路由器和交换机的区别</h3>]]></content>
      
      
      <categories>
          
          <category> 常识 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程编程</title>
      <link href="/posts/31931.html"/>
      <url>/posts/31931.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java多线程编程"><a href="#Java多线程编程" class="headerlink" title="Java多线程编程"></a>Java多线程编程</h1><h2 id="使用线程"><a href="#使用线程" class="headerlink" title="使用线程"></a>使用线程</h2><p>三种使用方法：</p><ul><li>实现 Runnable 接口</li><li>实现 Callable 接口</li><li>继承 Thread 类</li></ul><p>实现 Runnable 和 Callable 接口的类只能当作一个可以在线程中运行的任务，不是真正意义上的线程，因此最好还需要 Thread 来调用。可以理解为任务是通过线程驱动从而执行的。</p><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>synchronized 保证了代码块在任意时刻最多只有一个线程能执行。</p><p>使用 synchronized：</p><ol><li>找出修改共享变量的线程代码块</li><li>选择一个共享示例作为锁</li><li>使用 synchronized 锁定示例</li></ol><p>使用 synchronized 解决了多线程同步访问共享变量的问题。但是，它的缺点是带来了性能的下降。一方面，synchronized 代码块无法并发执行，另一方面，加锁和解锁会消耗一定的时间</p><h3 id="不需要-synchronized-的操作"><a href="#不需要-synchronized-的操作" class="headerlink" title="不需要 synchronized 的操作"></a>不需要 synchronized 的操作</h3><p>JVM 规范定义了几种原子操作：</p><ul><li>基本类型（long 和 double 除外）赋值</li><li>应用类型赋值</li></ul><p>long 和 double 是 64 位数据，JVM 没有明确规定 64 位赋值操作是不是一个原子操作，不过 X64 平台的 JVM 是把 long 和 double 的赋值作为原子操作实现的。</p><p>单条原子操作的语句不需要同步，多条则需要。有时候，可以通过巧妙地转换将非原子操作变成原子操作</p><h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><p>让线程自己选择锁对象往往会使得代码逻辑混乱，也不利于封装。更好的方法是把<code>synchronized</code>逻辑封装起来。</p><p>如果一个类被设计为允许多线程正确访问，我们就说这个类就是“线程安全”的（thread-safe）</p><p>还有一些不变类，例如<code>String</code>，<code>Integer</code>，<code>LocalDate</code>，它们的所有成员变量都是<code>final</code>，多线程同时访问时只能读不能写，这些不变类也是线程安全的。</p><p>最后，类似<code>Math</code>这些只提供静态方法，没有成员变量的类，也是线程安全的。</p><blockquote><p>没有特殊说明时，一个类默认是非线程安全的。</p></blockquote><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>JVM 允许同一个线程重复获取同一个锁，这种能被同一个线程反复获取的锁就叫做<code>可重入锁</code></p><p>感觉跟操作系统的一样，都是互斥、占有并等待、非抢占式、环路等待</p><p>解决方法：保证线程获取锁的顺序一致。</p><h2 id="wait-和-notify"><a href="#wait-和-notify" class="headerlink" title="wait() 和 notify()"></a>wait() 和 notify()</h2><p>多线程协调运行的原则：当条件不满足时，线程进入等待状态；当条件满足时，被唤醒。</p><p>Thread.wait() 方法会使当前线程进入等待状态；</p><p>Thread.notify() 方法会唤醒该进程；</p><p>Thread.notifyAll() 方法会唤醒列表中的全部进程</p><p>已唤醒的线程还需要重新获得锁后才能继续执行</p><h2 id="Concurrent"><a href="#Concurrent" class="headerlink" title="Concurrent"></a>Concurrent</h2><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>位于<code>java.util.concurrent</code>包中，用于替换<code>synchronized</code>加锁。</p><p>ReentrantLock 保证了只有一个线程可以执行临界区代码</p><p>synchronized 的缺点：</p><ul><li>很重</li><li>获取时必须一直等待，没有额外的尝试机制</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Counter{    private final Lock lock = new ReentrantLock();    private int count;        public void add(int n){        lock.lock();        try{            count += n;        } finally {            lock.unlock();        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ReentrantLock 和 synchronized 一样，都是可重入锁，不同的是，ReentrantLock 可以尝试获取锁：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">if (lock.tryLock(1, TimeUnit.SECONDS)) {    try{            } finally {        lock.unlock();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码在尝试获取锁的时候，最多等待1秒。如果1秒后仍未获取到锁，<code>tryLock()</code>返回<code>false</code>，程序就可以做一些额外处理，而不是无限等待下去。</p><h3 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h3><p>synchronized 锁有 wait() 和 notify() 两个功能，而 ReentrantLock 没有，因此就需要借助 Contition 对象来实现。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class TaskQueue {    private final Lock lock = new ReentrantLock();    private final Condition condition = lock.newCondition();    private Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();    public void addTask(String s) {        lock.lock();        try {            queue.add(s);            condition.signalAll();        } finally {            lock.unlock();        }    }    public String getTask() {        lock.lock();        try {            while (queue.isEmpty()) {                condition.await();            }            return queue.remove();        } finally {            lock.unlock();        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>Condition</code>提供的<code>await()</code>、<code>signal()</code>、<code>signalAll()</code>原理和<code>synchronized</code>锁对象的<code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code>是一致的，并且其行为也是一样的：</p><ul><li><code>await()</code>会释放当前锁，进入等待状态；</li><li><code>signal()</code>会唤醒某个等待线程；</li><li><code>signalAll()</code>会唤醒所有等待线程；</li><li>唤醒线程从<code>await()</code>返回后需要重新获得锁。</li></ul><h3 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h3><p>为了实现多个线程同时读，但只允许一个线程进行写入操作，引入 ReadWriteLock：</p><ul><li>只允许一个线程写入（其他线程既不能写入也不能读取）；</li><li>没有写入时，多个线程允许同时读（提高性能）。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Counter {    private final ReadWriteLock rwlock = new ReentrantReadWriteLock();    private final Lock rlock = rwlock.readLock();    private final Lock wlock = rwlock.writeLock();    private int[] counts = new int[10];    public void inc(int index) {        wlock.lock(); // 加写锁        try {            counts[index] += 1;        } finally {            wlock.unlock(); // 释放写锁        }    }    public int[] get() {        rlock.lock(); // 加读锁        try {            return Arrays.copyOf(counts, counts.length);        } finally {            rlock.unlock(); // 释放读锁        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h3><p>ReadWriteLock 可以解决多线程同时读，但只有一个线程能写。</p><p><code>StampedLock</code>和<code>ReadWriteLock</code>相比，改进之处在于：读的过程中也允许获取写锁后写入！这样一来，我们读的数据就可能不一致，所以，需要一点额外的代码来判断读的过程中是否有写入，这种读锁是一种乐观锁。</p><p>乐观锁的意思就是乐观地估计读的过程中大概率不会有写入，因此被称为乐观锁。反过来，悲观锁则是读的过程中拒绝有写入，也就是写入必须等待。显然乐观锁的并发效率更高，但一旦有小概率的写入导致读取的数据不一致，需要能检测出来，再读一遍就行。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Point {    private final StampedLock stampedLock = new StampedLock();    private double x;    private double y;    public void move(double deltaX, double deltaY) {        long stamp = stampedLock.writeLock(); // 获取写锁        try {            x += deltaX;            y += deltaY;        } finally {            stampedLock.unlockWrite(stamp); // 释放写锁        }    }    public double distanceFromOrigin() {        long stamp = stampedLock.tryOptimisticRead(); // 获得一个乐观读锁        // 注意下面两行代码不是原子操作        // 假设x,y = (100,200)        double currentX = x;        // 此处已读取到x=100，但x,y可能被写线程修改为(300,400)        double currentY = y;        // 此处已读取到y，如果没有写入，读取是正确的(100,200)        // 如果有写入，读取是错误的(100,400)        if (!stampedLock.validate(stamp)) { // 检查乐观读锁后是否有其他写锁发生            stamp = stampedLock.readLock(); // 获取一个悲观读锁            try {                currentX = x;                currentY = y;            } finally {                stampedLock.unlockRead(stamp); // 释放悲观读锁            }        }        return Math.sqrt(currentX * currentX + currentY * currentY);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>代码更复杂</li><li>stampedLock 是不可重入锁</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 多线程编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统知识点总结</title>
      <link href="/posts/19060.html"/>
      <url>/posts/19060.html</url>
      
        <content type="html"><![CDATA[<h1 id="数据库系统"><a href="#数据库系统" class="headerlink" title="数据库系统"></a>数据库系统</h1><h2 id="SQL-和数据库管理系统"><a href="#SQL-和数据库管理系统" class="headerlink" title="SQL 和数据库管理系统"></a>SQL 和数据库管理系统</h2><h3 id="sql"><a href="#sql" class="headerlink" title="sql"></a>sql</h3><blockquote><p>结构化查询语言，实现数据的查询和更新，关系型数据通用语言</p></blockquote><p>分类：</p><ul><li>DDL：数据定义语言，结构上的操作</li><li>DML：数据操纵语言，数据上的操作（增删改操作）</li><li>DCL：数据控制语言，授权操作</li><li>DQL：数据查询语言，查询操作</li></ul><h3 id="DBMS"><a href="#DBMS" class="headerlink" title="DBMS"></a>DBMS</h3><blockquote><p>数据库管理系统，对数据实现管理和操纵</p></blockquote><ul><li>RDBMS：关系型数据库<ul><li>二元关系模型（表格形式）</li></ul></li><li>NoSQL：非关系型数据库<ul><li>弥补关系型数据库管理系统的不足（高 IO 瓶颈）</li></ul></li></ul><h2 id="SQL-语言的基本使用"><a href="#SQL-语言的基本使用" class="headerlink" title="SQL 语言的基本使用"></a>SQL 语言的基本使用</h2><ol><li><p>查询<code>emp</code>表工资在 1000 到 2000 之间的员工信息(范围查询)</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select * from emp where sal between 1000 and 2000;-- 或者 select * from emp where sal &gt;= 1000 and sal &lt;= 2000;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>查询员工编号为<code>7369</code>，<code>7788</code>，<code>7521</code>的员工信息</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- 组合查询select * from emp where empno = 7369 or mpno = 7788 or mpno = 7521;-- 集合查询select &amp; from emp where empno in (7369,7788,7521);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>查询<code>emp</code>中所有的职位信息</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- 使用distinct对结果去重select distinct job from emp;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>模糊查询</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"># 查询员工名称包含L的select * from emp where ename like '%L%';# 查询员工名称第二个字是L的select * from emp where ename like '_L%';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>排序</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"># 升序select * from emp order by sal;# 降序select * from emp order by sal desc;# 工资升序，如果一样，按empno降序排序select * from emp order by sal, empno desc;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>限制结果查询</p><p>limit index, length;</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">#select * from emp limit 5;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>查询每个部门的部门编号和平均工资</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select deptno, avg(sal) avg from emp group by deptno;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>查询部门平均工资 &gt;2000 的部门编号及其平均工资</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select deptno, avg(sal) avg from emp group by deptno having avg &gt; 2000 ;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>having 和 where 的区别？</p><ol><li>where 和 having 都是实现条件过滤</li><li>where 使用在过滤之前，having 在过滤之后，为了能够在分组之后再次对结果进行过滤</li><li>where 不能使用聚合函数，having 可以使用聚合函数</li></ol></li></ol><h2 id="高级查询"><a href="#高级查询" class="headerlink" title="高级查询"></a>高级查询</h2><p><a href="https://blog.csdn.net/plg17/article/details/78758593">图解MySQL 内连接、外连接、左连接、右连接、全连接的区别</a></p><h3 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h3><blockquote><p>连接表都匹配的记录才会出现在最终的结果里</p><p>与连接顺序无关</p></blockquote><p>查询所有的员工的名称、薪水以及他们部门的名称</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select * from emp, dept where emp.deptno = dept.deptno;# 或者使用inner join ... on ..select * from emp inner join dept on emp.deptno = dept.deptno;# 或者使用inner join ... using ...# using注意事项：两张表需要进行关联的字段名称一致select * from emp inner join dept using(deptno)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><blockquote><p>左外连接：left join … on ..</p><p>右外连接：right join .. on ..</p><p>以其中一张表为驱动表，与另外一张表的每条记录进行匹配，如果能够匹配则进行关联并展示，如果匹配不到，以 null 填充</p><p>与连接顺序有关</p></blockquote><h2 id="SQL-语句的执行原理"><a href="#SQL-语句的执行原理" class="headerlink" title="SQL 语句的执行原理"></a>SQL 语句的执行原理</h2><p><a href="https://database.51cto.com/art/202101/639231.htm">说说MySQL的架构体系 - 51CTO.COM</a></p><p><img src="https://gitee.com/sehowyoung/images/raw/master/202108020804965.jpeg" alt="MySQL体系架构"></p><h3 id="MySQL-的基本架构和执行流程"><a href="#MySQL-的基本架构和执行流程" class="headerlink" title="MySQL 的基本架构和执行流程"></a>MySQL 的基本架构和执行流程</h3><p><img src="https://gitee.com/sehowyoung/images/raw/master/202108021046987.png" alt="MySQL 5.X 的基础架构"></p><ul><li><p>连接器：建立客户端和服务端的连接，权限获取，维持管理链接</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql -h$ip -P$port -u$user -p<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>mysql 客户端连接工具，tcp握手成功，需要进行身份认证</p><p>查询连接状态：</p><ul><li><p>短连接：执行少数几次查询就会断开，浪费大量资源</p></li><li><p>长连接：连接成功之后一直保持连接，wait_timeout 默认连接时长</p></li><li><p>```sql<br>show variables like ‘wait_timeout’;</p><pre class="line-numbers language-none"><code class="language-none">```sqlshow processlist;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><p>长连接驻留内存的解决办法：</p><ol><li>固定时间自动重新连接</li><li><code>mysql_reset_connection</code>重置连接</li></ol></li><li><p>查询缓存</p><p>query_cache_type：查询缓存类型，默认关闭，如果要使用，需要将值设为<code>DEMAND</code></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select SQL_CACHE * from emp where empno = 7788;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>适用于大量查询操作。</p><p><strong>注意：</strong>只有在 MySQL 5.X 中还存在，MySQL 8.X 中已移除</p></li><li><p>分析器</p><p>词法分析：检测每个单词的含义</p><p>语法分析：语法规则校验，语法是否正确</p></li><li><p>优化器</p><p>选择最优解</p><p>索引选择或执行顺序会影响执行效率，因此需要最优选择。</p></li><li><p>执行器</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select * from emp where deptno = 10;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>对表操作权限进行验证</li><li>innodb 存储引擎安行查询 deptno </li><li>将结果返回</li></ol></li></ul><h3 id="行列转换"><a href="#行列转换" class="headerlink" title="行列转换"></a>行列转换</h3><ul><li><p>纵表转横表</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select username sum(case course when 'mysql' then score else 0 end) mysql from stu group by username;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">create view vstu as select username,sum(case course when 'mysql' then score else 0 end)mysql,sum(case course when 'hive' then score else 0 end) hive,sum(case course when 'python' then score else 0 end) pythonfrom stu group by username<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>横表转纵表</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select username, 'mysql' course, mysql score from vstuunion allselect sername, 'hive' course, hive score from vstuunion allselect sername, 'python' course, p score from vstu<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>数据库存储引擎是数据库底层软件组织，数据库管理系统(DBMS)使用数据引擎进行创建、查询、更新和删除数据。不同的存储引提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引，还可以获得特定的功能，Mysq的核心就是存储引擎。</p><p>MySQL 底层设计采用可插拔是的存储引擎用户可以根据需求，选挥或自定义存储引擎。MySQL5 之后默认存储引为 Innodb</p><p>查看 MySQL 支持的存储引擎：<code>show engines;</code></p><h3 id="存储引擎的对比"><a href="#存储引擎的对比" class="headerlink" title="存储引擎的对比"></a>存储引擎的对比</h3><div class="table-container"><table><thead><tr><th>特点</th><th>Myisam</th><th>BDB</th><th>Memory</th><th>InnoDB</th><th>Archive</th></tr></thead><tbody><tr><td>存储限制</td><td>无</td><td>无</td><td>有</td><td>64TB</td><td>无</td></tr><tr><td>事务安全</td><td></td><td>支持</td><td></td><td>支持</td><td></td></tr><tr><td>锁机制</td><td>表锁</td><td>页锁</td><td>表锁</td><td>支持</td><td>行锁</td></tr><tr><td>B树索引</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td><td></td></tr><tr><td>哈希索引</td><td></td><td></td><td>支持</td><td>支持</td><td></td></tr><tr><td>全文索引</td><td>支持</td><td></td><td></td><td></td><td></td></tr><tr><td>集群索引</td><td></td><td></td><td></td><td>支持</td><td></td></tr><tr><td>数据缓存</td><td></td><td></td><td>支持</td><td>支持</td><td></td></tr><tr><td>索引缓存</td><td>支持</td><td></td><td>支持</td><td>支持</td><td></td></tr><tr><td>数据可压缩</td><td>支持</td><td></td><td></td><td></td><td>支持</td></tr><tr><td>空间使用</td><td>低</td><td>低</td><td>N/A</td><td>高</td><td>非常低</td></tr><tr><td>内存使用</td><td>低</td><td>低</td><td>中等</td><td>高</td><td>低</td></tr><tr><td>批量插入速度</td><td>高</td><td>高</td><td>高</td><td>低</td><td>非常高</td></tr><tr><td>支持外键</td><td></td><td></td><td></td><td>支持</td></tr></tbody></table></div><ul><li><p>InnoDB</p><p>MySQL 默认存储引擎。事务型数据库</p><ol><li>数据底层存储：数据表文件 —&gt; .frm（表结构）文件和 .ibd（数据和索引）文件</li><li>事务：支持热备份，对事物完整性要求比较高时使用</li><li>锁的粒度：采用 MVVC 支持高并发操作，支持四种事务隔离级别，行锁</li><li>存储索引特点：采用聚簇索引</li><li>场景<ol><li>更新查找频繁，高并发</li><li>要求事务</li><li>外键约束</li></ol></li></ol></li><li><p>Myisam</p><ol><li>存储形式：数据表文件 —&gt; .frm .MYD .MYI （数据和索引分离）</li><li>事务：不支持</li><li>存储特点：非聚簇索引</li><li>其他：全文检索、压缩，延迟更新索引</li><li>场景<ol><li>count 计算</li><li>查询</li></ol></li></ol></li><li><p>Memory</p><p>数据保存在内存中，增删改查效率高，但不能持久化</p><p>不支持事务，表级锁</p></li></ul><h3 id="如何设置存储引擎"><a href="#如何设置存储引擎" class="headerlink" title="如何设置存储引擎"></a>如何设置存储引擎</h3><p>创建表时修改存储引擎：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">create table t_name() engine = INNODB;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看某张表的基本信息：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">show tables status from [database] where name = '[name]' \G<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>为了提升查询效率创建数据结构</p><h3 id="常见索引模型"><a href="#常见索引模型" class="headerlink" title="常见索引模型"></a>常见索引模型</h3><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>key —— value 方式存储</p><p>key 经过 hash 计算获取到一个值，区该位置寻找数据（值）。</p><p>哈希碰撞，利用“拉链法”解决</p><p>适合等值查询，不适合范围查询</p><h4 id="有序数组"><a href="#有序数组" class="headerlink" title="有序数组"></a>有序数组</h4><p>整个数组中排列是有序的，查找方便。</p><p>等职查询和范围查询都比较适合，当时插入、删除困难。</p><h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><p>二叉树的结构进行存储</p><p>树最影响效率的是树的深度，尽可能平衡</p><p>真正存储采用多叉树  </p><h3 id="InnoDB-索引模式"><a href="#InnoDB-索引模式" class="headerlink" title="InnoDB 索引模式"></a>InnoDB 索引模式</h3><p>InnoDB 根据主键的顺序以索引的方式进行存储</p><p>InnoDB 中默认采用 B+ 树索引模型，数据组织存储到 B+ 树中。</p><p>索引类型分为主键索引和非主键索引</p><ul><li>主键索引：叶子节点中存储的整行数据，称为聚簇索引</li><li>非主键索引：叶子节点中存储的主键的值，称为二级索引</li></ul><p>主键索引与非主键索引的区别：</p><ul><li>主键索引只需要查找一次 B+ 树就可以定位数据</li><li>非主键索引第一次只能查找到主键索引，需要根据主键索引再次查找整条记录</li></ul><p>索引是需要维护的。</p><ul><li>添加索引避免在增删操作较多的表</li><li>索引自身也需要占用空间存储</li></ul><p>索引的选择</p><ul><li>优先选择主键索引</li><li>逐渐长度越小越好</li><li>尽量不要选择业务字段作为主键</li><li>表数据量较多</li><li>尽可能选择高基数列</li></ul><h3 id="添加索引"><a href="#添加索引" class="headerlink" title="添加索引"></a>添加索引</h3><ol><li><p>查看索引</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">show index from emp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>普通索引</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">create index index_name on [table]([col])create table [name](col ...     ...    index index_name(col))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>删除索引</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">drop index index_name on [table]([col])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>唯一索引</p><p>索引列必须唯一</p><ul><li><p>添加索引</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">create unique index index_name on [table]([col])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>删除索引</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">alter table name drop index index_name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul></li><li><p>主键索引</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">alter table name add constraint PK_ID primary key (id)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>组合索引</p><p>可以在多个字段添加索引，但是查询索引必须使用第一个字段索引</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">create index index_name on [table](col1, col2, ...)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h2 id="SQL-优化"><a href="#SQL-优化" class="headerlink" title="SQL 优化"></a>SQL 优化</h2><h3 id="使用-explain-分析查询"><a href="#使用-explain-分析查询" class="headerlink" title="使用 explain 分析查询"></a>使用 explain 分析查询</h3><ol><li>type：连接类型<ul><li>ALL：表示全表扫，若表中数据有百万乃至千万，必须要优化，否则性很慢</li><li>Index: full index scan, Index 与 ALL 的区別为 index 只历引，这通常比 ALL 快，因为引文件通常比数据文件小（也就是说 ALL 和 index 都是读全表，但是 index 是从索引中读取的，而ALL 是从硬盘中读取的)</li><li>range：只检索给定范围的行，使用一个索引来选择行，key 列显示使用了那个索引，一般是在你的 where 语句中出现了 between、&gt;、&lt;、in 等的音询，这种范围扫描比全表行要好，因为它只需要开始索引的某一点，而结束语另一点，不用扫描全部索引。</li><li>ref：非唯一性索引扫描，返回匹配某个单独值得所有行，本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，它可能会找到多个符合条件的行，所以它应该属于查找和扫描的混合体</li><li>eq_ref：唯一索引扫描，对于每个索引键，表中只有一条记录与之匹配，常见于主键或唯一索引扫描</li><li>const：表示通过索引一次就找到了，const 用户比 primary key 或者 unique 黑引，因为只匹配一行数据，所以很快；如将逐新置于 where 列表中，Mysql 就将改查询转换为一个常量</li><li>system：表示只有一行记（等于系统表），这是 const 类的特列，平时不会出现，可以忽路不记</li></ul></li><li>possiable_keys：可能用到的索引</li><li>key：真正用到的索引</li><li>key_len：索引的长度，越短越好</li><li>ref：索引的哪一列被使用了</li><li>rows：索引的函数</li></ol><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">explain select * from stu where id = 1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="profilling-分析语句执行时间"><a href="#profilling-分析语句执行时间" class="headerlink" title="profilling 分析语句执行时间"></a>profilling 分析语句执行时间</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"># 打开统计分析set profilling;# 查看执行时间show profile;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="sql-基本优化原则"><a href="#sql-基本优化原则" class="headerlink" title="sql 基本优化原则"></a>sql 基本优化原则</h3><ol><li>字段维护在 B 树上，数据类型有要求（设计 3NF）<ol><li>尽可能使用较小类型</li><li>尽量使用简单类型</li><li>尽可能设置合理的长度，固定长度比变化的长度快</li><li>not null 约束</li></ol></li><li>sql 优化<ol><li>尽量不要使用 select *</li><li>sql 尽量减少嵌套</li><li>尽量用 limit 限制字段</li></ol></li><li>索引失效的状况<ol><li>索引列使用函数</li><li>使用模糊查询</li><li>索引列不要运用计算</li><li>索引列尽量不要使用 (!\=&lt;&gt;)</li></ol></li><li>in 和 exists<ol><li>in 把内表和外表进行 hash 连接，exists 把外表 loop</li><li>内表和外表数据量差距不大，性能基本相同</li><li>内表小使用 in，外表比较小 exists</li></ol></li></ol><h2 id="数据库系统原理"><a href="#数据库系统原理" class="headerlink" title="数据库系统原理"></a>数据库系统原理</h2><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>事务是指满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。</p><p>ACID：</p><ul><li>原子性（Atomicity）：事务被视为不可分割的最小单元，事务的所有操作要么全部成功，要么全部失败</li><li>一致性（Consistency）：数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。</li><li>隔离性（Isolation）：一个事务所做的修改在最终提交前，对其它事务不可见</li><li>持久性（Durability）：一旦事务提交，其所作的修改将会永远保存在数据库中。</li></ul><p>AUTOCOMMIT：MySQL 默认采用自动提交模式。</p><h3 id="并发一致性问题"><a href="#并发一致性问题" class="headerlink" title="并发一致性问题"></a>并发一致性问题</h3><p>在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题</p><h4 id="丢失修改"><a href="#丢失修改" class="headerlink" title="丢失修改"></a>丢失修改</h4><p>丢失修改指一个事务的更新操作被另外一个事务的更新操作替换。一般在现实生活中常会遇到，例如：$T<em>{1}$和$T</em>{2}$两个事务都对一个数据进行修改，$T<em>{1}$先修改并提交生效，$T</em>{2}$随后修改，$T<em>{2}$的修改覆盖了$T</em>{1}$的修改</p><h4 id="读脏数据"><a href="#读脏数据" class="headerlink" title="读脏数据"></a>读脏数据</h4><p>读脏数据指在不同的事务下，当前事务可以读到另外事务未提交的数据。例如：$T<em>{!}$修改一个数据但未提交，$T</em>{2}$随后读取这个数据。如果$T<em>{1}$撤销了这次修改，那么$T</em>{2}$读取的数据是脏数据。</p><h4 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h4><p>不可重复读指在一个事务内多次读取同一数据集合。在这一事务还未结束前，另一事务也访问了该同一数据集合并做了修改，由于第二个事务的修改，第一次事务的两次读取的数据可能不一致。例如：$T<em>{2}$读取一个数据，$T</em>{1}$对该数据做了修改。如果$T_{2}$再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p><h4 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h4><p>幻读本质上也属于不可重复读的情况，$T<em>{1}$读取某个范围的数据，$T</em>{2}$在这个范围内插入新的数据，$T_{1}$再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</p><p>产生并发不一致性问题的主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。</p><h3 id="封锁"><a href="#封锁" class="headerlink" title="封锁"></a>封锁</h3><h4 id="封锁粒度"><a href="#封锁粒度" class="headerlink" title="封锁粒度"></a>封锁粒度</h4><ul><li>MySQL提供了两种封锁粒度：行级锁以及表级锁</li><li>应该尽量之锁定需要修改的那部分数据，而不是所有资源。锁定的数据量越少，发生锁争的可能就越小，系统的并发程度就越高</li><li>加锁需要消耗资源，锁的各种行为都会增加系统开销。因此锁的粒度越小，系统开销越大</li><li>在选择粒度时，需要在锁开销和并发程度之间做一个权衡</li></ul><h4 id="封锁类型"><a href="#封锁类型" class="headerlink" title="封锁类型"></a>封锁类型</h4><ul><li><p>读写锁</p><ul><li>互斥锁：简写为 X 锁，又称写锁</li><li>共享锁：简写为 S 锁，又称读锁</li></ul><p>两个规定：</p><ul><li>一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。枷锁期间其他事务不能对 A 加任何锁</li><li>一个事务对数据对象 A 加了 S 锁，只可以对 A 进行读取操作，无法进行更新操作。加锁期间其他事务能对 A 加 S 锁，但是不能加 X 锁</li></ul></li><li><p>意向锁</p><p>使用意向锁可以更容易地支持多粒度封锁</p><p>在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。</p><p>意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：</p><ul><li><p>一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；</p></li><li><p>一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。</p></li></ul><p>通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207214442687.png" alt="意向锁兼容关系"></p></li></ul><h4 id="封锁协议"><a href="#封锁协议" class="headerlink" title="封锁协议"></a>封锁协议</h4><ol><li><p>三级封锁协议</p><ol><li><p>一级封锁协议</p><p>事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁</p><p>可以解决丢失修改问题。</p></li><li><p>耳机封锁协议</p><p>在一级的基础上，要求读取数据 A 时必须加 S 锁，读完马上释放 S 锁。</p><p>可以解决读脏数据。</p></li><li><p>三级封锁协议</p><p>在二级的基础上，要求读取数据 A 时必须加 S 锁，指导事务结束才能释放</p><p>可以解决不可重复读问题</p></li></ol></li><li><p>两段封锁协议</p><p>加锁和解锁分为两个阶段进行。</p><p>可串行化调度是指：通过并发控制，使得并发执行的事务结果与某个串行执行的书屋结果相同，串行执行的事务互不干扰，不会出现并发一致性问题。</p><p>事务遵循两段封锁协议是保证可串行化调度的充分条件。</p></li></ol><h4 id="MySQL-隐式与显示锁定"><a href="#MySQL-隐式与显示锁定" class="headerlink" title="MySQL 隐式与显示锁定"></a>MySQL 隐式与显示锁定</h4><p>MySQL 的 InnoDB 存储引擎采用两段封锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻释放，这被称为隐式锁定</p><p>InnoDB 也可以使用特定的语句进行显示锁定：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT ... LOCK In SHARE MODE;SELECT ... FOR UPDATE;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="索引-1"><a href="#索引-1" class="headerlink" title="索引"></a>索引</h3><h4 id="B-Tree原理"><a href="#B-Tree原理" class="headerlink" title="B+ Tree原理"></a>B+ Tree原理</h4><p>B+ Tree 是基于 B Tree（Balance Tree，平衡树） 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。</p><p>在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 $key<em>{i}$ 和 $key</em>{i+1}$，且不为 null，则该指针指向节点的所有 key 大于等于 $key<em>{i}$ 且小于等于 $key</em>{i+1}$</p><h2 id="学习视频"><a href="#学习视频" class="headerlink" title="学习视频"></a>学习视频</h2><ol><li><a href="https://www.aliyundrive.com/s/ZBsgyhbhZ4N">https://www.aliyundrive.com/s/ZBsgyhbhZ4N</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 常识 </category>
          
          <category> 数据库系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
            <tag> 数据库系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http知识总结</title>
      <link href="/posts/24206.html"/>
      <url>/posts/24206.html</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP总结"><a href="#HTTP总结" class="headerlink" title="HTTP总结"></a>HTTP总结</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="HHTP-基本概念"><a href="#HHTP-基本概念" class="headerlink" title="HHTP 基本概念"></a>HHTP 基本概念</h3><p>客户端发送一个请求报文给服务器，服务器根据请求报文中的信息进行处理，并将处理结果放入响应报文中返回给客户端。</p><p><strong>请求报文：</strong></p><ul><li><p>第一行请求方法、URL、协议版本；</p></li><li><p>多行请求首部 header，每个首部都有一个名称，以及对应的值</p></li><li><p>空行分隔首部与主体</p></li><li><p>请求内容主体</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">GET http://www.example.com/ HTTP/1.1Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9,en;q=0.8Cache-Control: max-age=0Host: www.example.comIf-Modified-Since: Thu, 17 Oct 2019 07:18:26 GMTIf-None-Match: "3147526947+gzip"Proxy-Connection: keep-aliveUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 xxxparam1=1&amp;param2=2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p><strong>响应报文：</strong></p><ul><li><p>第一行包含协议版本、状态码以及描述</p></li><li><p>多行是首部内容</p></li><li><p>空行分隔首部与主体</p></li><li><p>响应的主体</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">HTTP/1.1 200 OKAge: 529651Cache-Control: max-age=604800Connection: keep-aliveContent-Encoding: gzipContent-Length: 648Content-Type: text/html; charset=UTF-8Date: Mon, 02 Nov 2020 17:53:39 GMTEtag: "3147526947+ident+gzip"Expires: Mon, 09 Nov 2020 17:53:39 GMTKeep-Alive: timeout=4Last-Modified: Thu, 17 Oct 2019 07:18:26 GMTProxy-Connection: keep-aliveServer: ECS (sjc/16DF)Vary: Accept-EncodingX-Cache: HIT<span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token name">doctype</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Example Domain<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>// 省略... <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p><strong>URL与URI</strong></p><p>HTTP 使用 URL（ Uniform Resource Locator，统一资源定位符）来定位资源，它是 URI（Uniform Resource Identifier，统一资源标识符）的子集，URL 在 URI 的基础上增加了定位能力。</p><h3 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h3><ol><li><strong>GET</strong>：获取资源</li><li><strong>HEAD</strong>：获取报文头部</li><li><strong>POST</strong>：传输实体主体</li><li><strong>PUT</strong>：上传文件</li><li><strong>PATCH</strong>：对资源进行部分修改</li><li><strong>DELETE</strong>：删除文件</li><li><strong>OPTIONS</strong>：查询支持的方法</li><li><strong>CONNECT</strong>：要求在与代理服务器通信时建立隧道</li><li><strong>TRACE</strong>：追踪路径</li></ol><h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h3><div class="table-container"><table><thead><tr><th>响应码</th><th>类别</th><th>含义</th></tr></thead><tbody><tr><td>1XX</td><td>信息性状态码</td><td>接收的请求正在处理</td></tr><tr><td>2XX</td><td>成功状态码</td><td>请求正常处理完毕</td></tr><tr><td>3XX</td><td>重定向状态码</td><td>需要进行附加操作以完成请求</td></tr><tr><td>4XX</td><td>客户端错误状态吗</td><td>服务器无法处理请求</td></tr><tr><td>5XX</td><td>服务器错误状态码</td><td>服务器处理请求出错</td></tr></tbody></table></div><h3 id="HTTP-长连接，短连接"><a href="#HTTP-长连接，短连接" class="headerlink" title="HTTP 长连接，短连接"></a>HTTP 长连接，短连接</h3><ul><li>HTTP/1.0 默认使用短连接，HTTP/1.1默认使用长连接</li><li>短连接：客户端和服务器每进行一次 HTTP 操作就建立一次连接，任务结束就中断连接；长连接：当一个网页打开后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，客户端再次访问服务器时，会继续使用这一条连接。</li><li>HTTP 协议的长连接和短连接实质上是 TCP 协议的长连接和短连接</li></ul><h3 id="HTTP-1-0-和-HTTP-1-1-的区别"><a href="#HTTP-1-0-和-HTTP-1-1-的区别" class="headerlink" title="HTTP/1.0 和 HTTP/1.1 的区别"></a>HTTP/1.0 和 HTTP/1.1 的区别</h3><ul><li>长连接与短连接</li><li>状态码：HTTP/1.1 增加了一些状态码</li><li>缓存处理：HTTP/1.0 中主要使用 if-Modified-Since，HTTP/1.1 引入了更多的缓存控制策略，如：if-None-Match等</li><li>带宽优化及网络连接的使用：HTTP/1.0 中存在一些浪费带宽的现象，不支持断点续传；HTTP/1.1 在请求头中引入了 range 头域，允许只请求资源的某个部分，可以充分利用带宽</li></ul><h3 id="HTTP-2-0-和-HTTP-1-X-的区别"><a href="#HTTP-2-0-和-HTTP-1-X-的区别" class="headerlink" title="HTTP/2.0 和 HTTP/1.X 的区别"></a>HTTP/2.0 和 HTTP/1.X 的区别</h3><ul><li>新的二进制格式：HTTP/1.x 的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认 0 和 1 的组合。基于这种考虑 HTTP/2.0 的协议解析决定采用二进制格式，实现方便且健壮。</li><li>多路复用：即连接共享，即每一个request都是是用作连接共享机制的。一个 request 对应一个 id，这样一个连接上可以有多个 request，每个连接的 request 可以随机的混杂在一起，接收方可以根据 request 的 id 将 request 再归属到各自不同的服务端请求里面。</li><li>header 压缩：HTTP/1.x 的 header 带有大量信息，而且每次都要重复发送，HTTP/2.0 使用 encoder 来减少需要传输的 header 大小，通讯双方各自 cache 一份 header fields 表，既避免了重复 header 的传输，又减小了需要传输的大小。</li><li>服务端推送：例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了。</li></ul><h2 id="cookies"><a href="#cookies" class="headerlink" title="cookies"></a>cookies</h2><p>HTTP协议是无状态的，为了让HTTP协议尽可能简单，使它能够处理大量事务。HTTP/1.1 引入了Cookies来保存状态信息。</p><p>Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。</p><p>Cookie 曾一度用于客户端数据的存储，因为当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API（本地存储和会话存储）或 IndexedDB。</p><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><ul><li>会话状态管理（如用户登陆状态、购物车、游戏分数或其他需要记录的信息）</li><li>个性化设置（如用户自定义设置、主题等）</li><li>浏览器行为跟踪（如跟踪分析用户行为等）</li></ul><h3 id="创建过程"><a href="#创建过程" class="headerlink" title="创建过程"></a>创建过程</h3><ol><li>服务器发送的响应报文包含 Set-Cookie 首部字段，客户端得到响应报文后把Cookie 内容保存到浏览器中</li><li>客户端之后对同一服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 Cookie 请求首部字段发送给服务器</li></ol><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li>会话期 Cookie：浏览器关闭以后会被自动删除</li><li>持久性 Cookie：指定过期时间或有效期之后就成为了持久性的 Cookie</li></ul><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>Domain 标识指定了哪些主机可以接受 Cookie。如果不指定，默认为当前文档的主机（不包含子域名）。如果指定了 Domain，则一般包含子域名。</p><p>Path 标识指定了主机下的哪些路径可以接受 Cookie（该路径必须存在于请求 URL 中）</p><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><p>在 JavaScript 中通过 <code>document.cookie</code> 属性，你可以创建、维护和删除 cookie。创建 cookie 时该属性等同于 <code>Set-Cookie</code> 消息头，而在读取 cookie 时则等同于 <code>Cookie</code> 消息头。在创建一个 cookie 时，你需要使用和 <code>Set-Cookie</code> 期望格式相同的字符串：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">document<span class="token punctuation">.</span>cookie<span class="token operator">=</span><span class="token string">"name=Nicholas;domain=nczonline.net;path=/"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>设置 <code>document.cookie</code> 属性的值并不会删除存储在页面中的所有 cookie。它只简单的创建或修改字符串中指定的 cookie。下次发送一个请求到服务器时，通过 <code>document.cookie</code> 设置的 cookie 会和其它通过 <code>Set-Cookie</code> 消息头设置的 cookie 一并发送至服务器。这些 cookie 并没有什么明确的不同之处。</p><h3 id="HttpOnly"><a href="#HttpOnly" class="headerlink" title="HttpOnly"></a>HttpOnly</h3><p>标记为 HttpOnly 的 Cookie 不能被 JavaScript 脚本调用。跨站脚本攻击(XSS)常常使用 JavaScript 的<code>document.cookie</code>API 窃取用户的 Cookie 信息，因此使用 HttpOnly 标记可以在一定程度上避免 XSS 攻击</p><h3 id="Secure"><a href="#Secure" class="headerlink" title="Secure"></a>Secure</h3><p>标记为 Secure 的 Cookie 只能通过被 HTTPS 协议加密过的请求发送给服务端。但即使设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确实的安全保障。</p><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。</p><p>Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。</p><p>使用 Session 维护用户登录状态的过程如下：</p><ol><li><p>用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中</p></li><li><p>服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID</p></li><li><p>服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中</p></li><li><p>客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。</p></li></ol><p>应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。</p><h3 id="浏览器禁用-Cookie"><a href="#浏览器禁用-Cookie" class="headerlink" title="浏览器禁用 Cookie"></a>浏览器禁用 Cookie</h3><p>此时无法使用 Cookie 来保存用户信息，只能使用 Session。除此之外，不能再将 Session ID 存放到 Cookie 中，而是使用 URL 重写技术，将 Session ID 作为 URL 的参数进行传递。</p><h3 id="Cookie-和-Session-选择"><a href="#Cookie-和-Session-选择" class="headerlink" title="Cookie 和 Session 选择"></a>Cookie 和 Session 选择</h3><ul><li>Cookie 只能存储 ASCII 码字符串；Session 可以存储任何类型的字符串</li><li>Cookie 存储在浏览器中，容易被恶意查看。如果是隐私数据，建议加密</li><li>对于大型网站，如果用户所有信息全部存储在 Session 中，那么开销会很大</li></ul><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>缓解服务器压力</li><li>降低客户端获取资源的延迟：缓存通常放在内存中，读取缓存速度快</li></ul><h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><ul><li>让代理服务进行缓存</li><li>让客户端浏览器进行缓存</li></ul><h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p>HTTP/1.1 通过 Cache-Control 首部字段来控制缓存</p><ol><li><p>进制进行缓存</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">Cache-Control: no-store<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>no-store 指令规定不能对请求或响应的任何一部分进行缓存</p></li><li><p>强制确认缓存</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">Cache-Control: no-cache<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>no-cache 指令规定缓存服务器需要先向源服务器验证资源的有效性，只有当缓存资源有效时才能使用该缓存对客户端的请求进行响应。</p></li><li><p>私有缓存和公共缓存</p><p>private 指令规定了将资源作为私有缓存，只能被单独用户使用，一般存储在用户浏览器</p><p>public 指令规定了将资源作为公共缓存，可以被多个用户使用，一般存储在代理服务器中</p></li><li><p>缓存过期机制</p><p>max-age 指令出现在请求报文中，并且缓存资源的缓存时间小于该指令指定的时间，那么就接受该缓存</p><p>max-age 指令出现在响应报文中，表示缓存资源在缓存服务器中保存的时间</p></li></ol><h3 id="缓存验证"><a href="#缓存验证" class="headerlink" title="缓存验证"></a>缓存验证</h3><p>需要先了解 ETag 首部字段的含义，它是资源的唯一标识。URL 不能唯一表示资源，例如 <a href="http://www.google.com/">http://www.google.com/</a> 有中文和英文两个资源，只有 ETag 才能对这两个资源进行唯一标识。</p><p>可以将缓存资源的 ETag 值放入 If-None-Match 首部，服务器收到该请求后，判断缓存资源的 ETag 值和资源的最新 ETag 值是否一致，如果一致则表示缓存资源有效，返回 304 Not Modified。</p><p>Last-Modified 首部字段也可以用于缓存验证，它包含在源服务器发送的响应报文中，指示源服务器对资源的最后修改时间。但是它是一种弱校验器，因为只能精确到一秒，所以它通常作为 ETag 的备用方案。如果响应首部字段里含有这个信息，客户端可以在后续的请求中带上 If-Modified-Since 来验证缓存。服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 200 OK。如果请求的资源从那时起未经修改，那么返回一个不带有实体主体的 304 Not Modified 响应报文。</p><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>HTTP 有以下安全性问题：</p><p>使用明文进行通信，内容可能会被窃听；<br>不验证通信方的身份，通信方的身份有可能遭遇伪装；<br>无法证明报文的完整性，报文有可能遭篡改。<br>HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。</p><p>通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p><img src="https://www.runoob.com/wp-content/uploads/2018/09/https-intro.png" alt="HTTPS工作原理" style="zoom: 67%;"></p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>HTTPS 协议多次握手，导致页面加载时间延长50%</li><li>HTTPS 链接缓存不如 HTTP 高效，会增加开销和功耗</li><li>申请 SSL 需要钱，功能越强大，证书费用越高</li><li>SSL 设计安全算法会消耗 CPU 资源，对服务器资源消耗较大</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://leetcode-cn.com/leetbook/read/tech-interview-cookbook/op9epv/">https://leetcode-cn.com/leetbook/read/tech-interview-cookbook/op9epv/</a></li><li><a href="https://www.kancloud.cn/kancloud/http-cookies-explained/48333">https://www.kancloud.cn/kancloud/http-cookies-explained/48333</a></li><li><a href="https://www.runoob.com/w3cnote/http-vs-https.html">https://www.runoob.com/w3cnote/http-vs-https.html</a></li><li><a href="https://zhuanlan.zhihu.com/p/72616216">https://zhuanlan.zhihu.com/p/72616216</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 常识 </category>
          
          <category> http </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统知识点总结</title>
      <link href="/posts/29583.html"/>
      <url>/posts/29583.html</url>
      
        <content type="html"><![CDATA[<h1 id="计算机操作系统"><a href="#计算机操作系统" class="headerlink" title="计算机操作系统"></a>计算机操作系统</h1><p><img src="https://gitee.com/sehowyoung/images/raw/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.png" alt="操作系统"></p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h3><ul><li><p>并发：</p><ul><li><p>并发：在一段时间内可以运行多个程序。关键是：有处理多个任务的能力</p></li><li><p>并行：有多个任务执行单元，从物理上就可以多个任务一起执行。关键是：同时处理多个任务</p></li><li><p>举例：</p><blockquote><p>你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。<br>你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。<br>你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。</p></blockquote></li></ul></li><li><p>共享：</p><ul><li>共享是指系统中的资源可以被多个并发进程共同使用。</li><li>有两种共享方式：互斥共享和同时共享。</li><li>互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。</li></ul></li><li>虚拟<ul><li>虚拟技术将一个物理实体转换为多个逻辑实体</li><li>两种虚拟技术：<ul><li>时分复用技术：多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。</li><li>空分复用技术：虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。</li></ul></li></ul></li><li>异步：<ul><li>同步交互：指发送一个请求,需要等待返回,然后才能够发送下一个请求，有个等待过程；</li><li>异步交互：指发送一个请求,不需要等待返回,随时可以再发送下一个请求，即不需要等待。 </li><li>区别：一个需要等待，一个不需要等待，在部分情况下，我们的项目开发中都会优先选择不需要等待的异步交互方式。</li></ul></li></ul><h3 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h3><ol><li>进程管理：进程控制、进程通信、进程同步、死锁处理等</li><li>内存管理：内存分配、地址映射、虚拟内存等</li><li>文件管理：存储空间管理、目录管理、文件读写管理等</li><li>设备管理：缓冲管理、设备分配等</li></ol><h3 id="宏内核与微内核"><a href="#宏内核与微内核" class="headerlink" title="宏内核与微内核"></a>宏内核与微内核</h3><ol><li>宏内核：<ol><li>宏内核将操作系统功能作为一个紧密结合的整体放到内核</li><li>由于模块共享信息，性能很高</li></ol></li><li>微内核：<ol><li>由于操作系统不断复杂，因此将一部分系统功能移除内核，降低复杂性。移除的部分会根据分层原则划分成若干服务，相互独立。</li><li>在微内核结构下，操作系统被划分成小的、定义良好的模块，只有微内核这一个模块运行在内核态、其余模块运行在用户态。</li><li>因为需要频繁地在用户态和核心态之间进行切换，所以会有一定的性能损失。</li></ol></li></ol><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2_14_microkernelArchitecture.jpg" alt="微内核" style="zoom: 80%;"></p><h3 id="中断分类"><a href="#中断分类" class="headerlink" title="中断分类"></a>中断分类</h3><ol><li>外中断：由CPU执行指令意外的事件引起，如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。</li><li>异常：由CPU执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。</li><li>陷入：在用户程序中使用系统调用</li></ol><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><ul><li>进程：<ul><li>进程是资源分配的基本单位</li><li>进程控制块(Process Control Block)描述了进程的基本信息和运行状态</li></ul></li><li>线程：<ul><li>线程是独立调用的基本单位</li><li>一个进程可以有多个线程，他们共享进程资源</li></ul></li><li>区别：<ul><li>拥有资源：进程是资源分配的基本单位；线程不拥有资源，当可以访问资源</li><li>调度：线程是调度的基本单位。同一进程中，线程的切换不会引起进程的切换；从一个进程的线程中切换到另一个进程的线程中会引起进程的切换</li><li>系统开销：由于创建或撤销进程时，系统会分配或回收资源，因此所付出的开销远大于创建或撤销进程的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。</li><li>通信方面：线程间可以通过直接读写同一进程中的数据进行通信，当进程通信需要借助 IPC（进程通信） 。</li></ul></li></ul><h3 id="进程状态的切换"><a href="#进程状态的切换" class="headerlink" title="进程状态的切换"></a>进程状态的切换</h3><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ProcessState.png" alt="进程状态切换图" style="zoom:50%;"></p><p><strong>进程五大状态</strong>：</p><ul><li>新建状态(new/created)</li><li>就绪状态(ready)：等待被调度</li><li>运行状态(running)</li><li>阻塞状态(waiting)：等待资源</li><li>终止状态(terminated)</li></ul><p><strong>注意：</strong></p><ul><li>只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。</li><li>阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。</li></ul><h3 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h3><ol><li><p>先来先服务(FCFS)</p><ul><li>非抢占式调度算法，按请求的顺序进行调度</li><li>有利于长作业，不利于短作业</li></ul></li><li><p>短作业优先(SJF)</p><ul><li>非抢占式调度算法，按预估时间最短排序</li><li>长作业可能会饿死</li></ul></li><li><p>最短剩余时间优先(shortest remaining time next, SRTN)</p><ul><li>最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</li></ul></li><li><p>时间片轮转</p><ul><li>将所有就绪进程按FCFS排队，每次调度时，将CPU时间分配给队首进程，该进程执行一个时间片，当时间片用完，放置队尾，继续分配给队首进程，不断循环</li><li>时间片轮转算法的效率与时间片的大小有关</li></ul></li><li><p>优先级调度</p><ul><li>为每个进程分配一个优先级，按优先级进行调度</li><li>为防止低优先级的进程等不到调度，可以随着时间推移增加等待进程的优先级</li></ul></li><li><p>多级反馈队列</p><ul><li><p>多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。</p></li><li><p>每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。</p></li><li><p>可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/042cf928-3c8e-4815-ae9c-f2780202c68f.png" alt="多级反馈队列调度算法"></p></li></ul></li></ol><h3 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h3><ul><li>临界区：<ul><li>对临界资源进行访问的那段代码成为<code>临界区</code></li><li>为了互斥访问临界资源，每个资源在进入临界区之前，都需要进行检查</li></ul></li><li>同步与互斥<ul><li>同步：多个进程因为合作产生的直接制约关系，使的进程有一定的先后执行关系</li><li>互斥：多个进程在同一时刻只有一个进程能进入临界区</li></ul></li><li>信号量<ul><li>信号量(Semaphore)是一个整型变量，可以对其执行 down 和 up 操作，即 P 和 V 操作<ul><li><strong>down</strong>：如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0 ，进程睡眠，等待信号大于 0 </li><li><strong>up</strong>：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作</li></ul></li><li>down 和 up 被设计成原语，不可分割，通常的做法使在执行这些操作的时候屏蔽中断</li><li>如果信号量的取值只能为 0 或者 1，那么就成为了 <strong>互斥量（Mutex）</strong>，0 表示临界区已经加锁，1 表示临界区解锁。</li></ul></li><li>管程<ul><li>使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。</li><li>管程有一个重要特性：<strong>在一个时刻只能有一个进程使用管程</strong>。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。</li><li>管程引入了 条件变量 以及相关的操作：wait() 和 signal() 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程</li></ul></li></ul><h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p>进程同步与进程通信的区别：</p><ul><li>进程同步：控制多个进程按一定的顺序执行</li><li>进程通信：进程间传输信息</li></ul><p>进程同步的方式：</p><ol><li><p>管道（匿名管道）</p><p>管道通过调用 pipe 函数创建，fd[0] 用于读，fd[1] 用于写</p><pre class="line-numbers language-C" data-language="C"><code class="language-C"># include &lt;unistd.h&gt;int pipe(int fd[2]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>限制：</p><ul><li>只支持半双工通道(单项交替传输)</li><li>只能在父子进程或者兄弟进程中使用</li></ul><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/53cd9ade-b0a6-4399-b4de-7f1fbd06cdfb.png" alt="匿名管道" style="zoom:50%;"></p></li><li><p>有名管道 (FIFO)</p><p>匿名管道，由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道(FIFO)。</p><p>有名管道不同于匿名管道之处在于它提供了一个路径名与之关联，<strong>以有名管道的文件形式存在于文件系统中</strong>，这样，<strong>即使与有名管道的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过有名管道相互通信</strong>，因此，通过有名管道不相关的进程也能交换数据。值的注意的是，有名管道严格遵循<strong>先进先出(first in first out)</strong>,对匿名管道及有名管道的读总是从开始处返回数据，对它们的写则把数据添加到末尾。它们不支持诸如lseek()等文件定位操作。<strong>有名管道的名字存在于文件系统中，内容存放在内存中。</strong></p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2ac50b81-d92a-4401-b9ec-f2113ecc3076.png" alt="有名管道" style="zoom:50%;"></p></li><li><p>消息队列</p><p>消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示。</p><p>相比于 FIFO ，消息队列具有以下优点：</p><ul><li>消息队列可独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难</li><li>避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法</li><li>读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认的接收</li></ul></li><li><p>信号量</p><p>它是一个计数器，用于为多个进程提供对共享数据对象的访问</p></li><li><p>共享存储</p><p>允许多个进程共享以一个给定的存储区。因为数据不需要在进程间复制，所以这是最快的一种<strong>IPC</strong></p><p>需要使用信号量用来同步对共享存储的访问</p><p>多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存，另外 XSI 共享内存不是使用文件，而是使用内存的匿名段</p></li><li><p>套接字</p><p>与其他通信机制不同的是，它可以用于不同机器间的进程通信。</p></li></ol><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h3><ol><li>互斥：每个资源要么已经分配给了一个进程，要么就是可用的</li><li>占有并等待：已经得了某个资源的进程可以再请求新的资源</li><li>不可抢占：已经等配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显示释放</li><li>环路等待：有两个或两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源</li></ol><h3 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h3><h4 id="鸵鸟策略"><a href="#鸵鸟策略" class="headerlink" title="鸵鸟策略"></a>鸵鸟策略</h4><ul><li>措施：把头埋在沙子里，假装根本没发生。</li><li>原因：因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。</li><li>适用条件：死锁不会对用户造成多大影响或发生死锁概率很低</li><li>大部分操作系统处理死锁使用的就是鸵鸟策略</li></ul><h4 id="死锁检测与死锁恢复"><a href="#死锁检测与死锁恢复" class="headerlink" title="死锁检测与死锁恢复"></a>死锁检测与死锁恢复</h4><ul><li>措施：不试图阻止死锁，而是当死锁发生时，采取措施进行恢复</li><li>算法：<ul><li>每种类型一个资源的死锁检测：通过检测有向图是否存在环来实现，从一个接待你出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。</li><li>每种类型多个资源的死锁检测：每个进程最开始都不被标记，执行过程有可能被标记。但算法结束时，任何没有被标记的进程都是死锁进程。<ol><li>寻找一个没有标记的进程 $P_{i}$，它所请求的资源小于等于资源剩余量</li><li>如果找到这样一个进程，那么将该进程所拥有的资源数量加到资源剩余量中，标记该进程并返回1</li><li>如果没有这样一个进程，算法终止</li></ol></li></ul></li><li>死锁恢复<ul><li>利用抢占资源</li><li>利用回滚回复</li><li>通过杀死进程恢复</li></ul></li></ul><h4 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h4><ul><li>描述：在程序运行之前预防发生死锁</li><li>措施：<ul><li>破坏互斥条件</li><li>破坏占有并等待条件：规定所有进程在开始执行前请求所需要的全部资源</li><li>破坏不可抢占条件、</li><li>破坏环路并等待：给资源编号，进程只能按编号顺序来请求资源</li></ul></li></ul><h4 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h4><ul><li>安全状态：<ul><li>定义：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序使得每一个进程都能运行完毕，则称改状态是安全的</li><li>安全状态的检测与死锁检测类似，因为安全状态必须要求不能发生死锁</li></ul></li><li>银行家算法</li></ul><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><ul><li>目的：让物理内存扩大成更大的逻辑内存，从而让程序获得更多的可用内存</li><li>为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但<strong>不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中</strong>。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。</li><li>虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，即一个程序不需要全部调入内存就可以运行。例如：一个内存为32KB的计算机允许运行64KB的程序</li></ul><h3 id="分页系统地址映射"><a href="#分页系统地址映射" class="headerlink" title="分页系统地址映射"></a>分页系统地址映射</h3><ul><li><p>内存管理单元(MMU)管理着地址空间和物理内存的转换，其中的页表(Page Table)存储着页（程序地址空间）和页框（物理内存空间）的映射表。</p></li><li><p>一个虚拟地址分为两部分，一部分存储页面号，一部分存储偏移量</p></li><li><p>例如：下图的页表存放着 16 个页，这 16 个页需要用 4 个比特位来进行索引定位。例如对于虚拟地址（0010 000000000100），前 4 位是存储页面号 2，读取表项内容为（110 1），页表项最后一位表示是否存在于内存中，1 表示存在。后 12 位存储偏移量。这个页对应的页框的地址为 （110 000000000100）。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/cf4386a1-58c9-4eca-a17f-e12b1e9770eb.png" alt="虚拟地址"></p></li></ul><h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><p>在程序运行过程中，如果要访问的页面不在内存中，就会发生缺页中断从而将该页调入内存中。如果内存没有闲置空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。</p><p>页面置换算法和缓存淘汰策略类似，可以将内存堪称磁盘的缓存。在缓存系统中，缓存大小有限，当有新的缓存到达时，需要淘汰一部分已经存在的缓存，这样才有空间存放新的缓存数据。</p><p>目标：使页面置换频率最低</p><h4 id="最佳-OPT-Optimal-replacement-algorithm"><a href="#最佳-OPT-Optimal-replacement-algorithm" class="headerlink" title="最佳 OPT(Optimal replacement algorithm)"></a>最佳 OPT(Optimal replacement algorithm)</h4><ul><li>算法描述：所选择的被置换出的页面是最长时间内不在被访问，通常可以保证获得最低的缺页率。</li><li>是一种理论上的算法，因为无法知道一个页面多长时间内不在被访问</li></ul><h4 id="最近最久未使用-LRU-Leastest-Recently-Used"><a href="#最近最久未使用-LRU-Leastest-Recently-Used" class="headerlink" title="最近最久未使用 LRU(Leastest Recently Used)"></a>最近最久未使用 LRU(Leastest Recently Used)</h4><ul><li>算法描述：为了实现 LRU ，需要在内存中维护一个所有页面的表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面时最近最久未访问的。</li><li>每次访问都需要更新链表，因此代价很高</li></ul><h4 id="先进先出-FIFO-First-in-First-out"><a href="#先进先出-FIFO-First-in-First-out" class="headerlink" title="先进先出 FIFO(First in First out)"></a>先进先出 FIFO(First in First out)</h4><ul><li>算法描述：选择最先进入的页面进行置换</li><li>该算法会将那些经常被访问的页面置换出去，导致缺页率升高</li></ul><h3 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h3><p>虚拟内存采用分页技术，也就是将地址空间划分成固定大小的页，每一个再与物理内存进行映射。但是在某些需要动态增长的程序中，分页技术会导致覆盖问题的出现，因此采用分段技术。</p><p>分段技术：将表分成段，一个段构成一个独立的地址空间。每个段的长度可以不同，并且动态增长。</p><h3 id="段页式"><a href="#段页式" class="headerlink" title="段页式"></a>段页式</h3><p>程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样即拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能</p><h3 id="分页和分段的比较"><a href="#分页和分段的比较" class="headerlink" title="分页和分段的比较"></a>分页和分段的比较</h3><ul><li>对程序员的透明性：分页透明，但是分段需要程序员显性划分</li><li>地址空间的维度：分页一维，分段二维</li><li>大小是否可变：页的大小不可变，段的大小可动态改变</li><li>出现原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有利于共享和保护</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.jianshu.com/p/c1015f5ffa74">https://www.jianshu.com/p/c1015f5ffa74</a></li><li><a href="https://leetcode-cn.com/leetbook/read/tech-interview-cookbook/">https://leetcode-cn.com/leetbook/read/tech-interview-cookbook/</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 常识 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList扩容机制分析</title>
      <link href="/posts/55582.html"/>
      <url>/posts/55582.html</url>
      
        <content type="html"><![CDATA[<h1 id="ArrayList扩容机制分析"><a href="#ArrayList扩容机制分析" class="headerlink" title="ArrayList扩容机制分析"></a>ArrayList扩容机制分析</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>ArrayList</code>是动态数组，它的底层是数组队列，它的前身是<code>Vector</code>，和Java中的数组相比，他最大的优势就是能动态增长。</p><p><code>ArrayList</code>继承于<code>AbstractList</code>类，实现了<code>List</code>，<code>RandomAccess</code>，<code>Cloneable</code>，<code>java.io.Serializable</code>类。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable{    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>其中：</p><ul><li><code>RandomAccess</code>：这个接口里面什么都没有，是一个标志接口，表明实现这个接口的List集合支持快速访问。</li><li><code>Cloneable</code>：一个类实现了Cloneable接口，以向Object.clone()方法指示该方法制作该类实例的字段对字段副本是合法的。即表示<code>ArrayList</code>可以被克隆。</li><li><code>Serializable</code>：<code>ArrayList</code>实现了这个接口，表明<code>ArrayList</code>支持序列化，可以通过序列化传输内容</li></ul><h2 id="ArrayList扩容机制分析（jdk8）"><a href="#ArrayList扩容机制分析（jdk8）" class="headerlink" title="ArrayList扩容机制分析（jdk8）"></a>ArrayList扩容机制分析（jdk8）</h2><h3 id="ArrayList的构造函数"><a href="#ArrayList的构造函数" class="headerlink" title="ArrayList的构造函数"></a>ArrayList的构造函数</h3><p>ArrayList提供了三种构造函数，分别是无参构造函数、初始容量构造函数、容器构造函数。<strong>以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"> /**  * 默认初始容量大小  */ private static final int DEFAULT_CAPACITY = 10; /**  * 空数组（用于空实例）。  */ private static final Object[] EMPTY_ELEMENTDATA = {}; //用于默认大小空实例的共享空数组实例。 //我们把它从EMPTY_ELEMENTDATA数组中区分出来，以知道在添加第一个元素时容量需要增加多少。 private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; /**  * 默认构造函数，使用初始容量10构造一个空列表(无参数构造)  */ public ArrayList() {     this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; } /**  * 带初始容量参数的构造函数。（用户自己指定容量）  */ public ArrayList(int initialCapacity) {     if (initialCapacity &gt; 0) {//初始容量大于0         //创建initialCapacity大小的数组         this.elementData = new Object[initialCapacity];     } else if (initialCapacity == 0) {//初始容量等于0         //创建空数组         this.elementData = EMPTY_ELEMENTDATA;     } else {//初始容量小于0，抛出异常         throw new IllegalArgumentException("Illegal Capacity: "+                                            initialCapacity);     } }/** * 构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回 * 如果指定的集合为null，throws NullPointerException。 */  public ArrayList(Collection&lt;? extends E&gt; c) {     elementData = c.toArray();     if ((size = elementData.length) != 0) {         // c.toArray might (incorrectly) not return Object[] (see 6260652)         if (elementData.getClass() != Object[].class)             elementData = Arrays.copyOf(elementData, size, Object[].class);     } else {         // replace with empty array.         this.elementData = EMPTY_ELEMENTDATA;     } }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="扩容分析"><a href="#扩容分析" class="headerlink" title="扩容分析"></a>扩容分析</h3><p>我们首先创造一个无参的<code>ArrauList</code>，然后调用<code>ArrayList.add()</code>方法</p><h4 id="ArrayList-add"><a href="#ArrayList-add" class="headerlink" title="ArrayList.add()"></a>ArrayList.add()</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * 将指定的元素追加到此列表的末尾。 */public boolean add(E e) {    //添加元素之前，先调用ensureCapacityInternal方法，得到最小扩容量    ensureCapacityInternal(size + 1);  // Increments modCount!!    //这里看到ArrayList添加元素的实质就相当于为数组赋值    elementData[size++] = e;    return true;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="ArrayList-ensureCapacityInternal"><a href="#ArrayList-ensureCapacityInternal" class="headerlink" title="ArrayList.ensureCapacityInternal()"></a>ArrayList.ensureCapacityInternal()</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">//得到最小扩容量private void ensureCapacityInternal(int minCapacity) {    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {        // 获取默认的容量和传入参数的较大值        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);    }//判断是否需要扩容    ensureExplicitCapacity(minCapacity);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当要add第一个元素时，<code>minCapacity</code>为1，通过<code>Math.max()</code>比较后，<code>minCapacity</code>为10。</p><h4 id="ArrayList-ensureExplicitCapacity"><a href="#ArrayList-ensureExplicitCapacity" class="headerlink" title="ArrayList.ensureExplicitCapacity()"></a>ArrayList.ensureExplicitCapacity()</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">//判断是否需要扩容private void ensureExplicitCapacity(int minCapacity) {    modCount++;    // overflow-conscious code    if (minCapacity - elementData.length &gt; 0)        //调用grow方法进行扩容，调用此方法代表已经开始扩容了        grow(minCapacity);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当调用<code>ArrayList.ensureCapacityInternal()</code>的方法时，一定会调用<code>ArrayList.ensureExplicitCapacity()</code>来判断是否需要进行扩容。</p><p>我们来看一下添加元素的过程：</p><ul><li>当我们添加第一个元素时，<code>elementData.length</code>为0，执行<code>ArrayList.ensureCapacityInternal()</code>方法，得到结果<code>minCapacity</code>为10，此刻进入<code>ArrayList.ensureExplicitCapacity()</code>后，<code>inCapacity - elementData.length &gt; 0</code>成立，然后调用<code>ArrayList.grow()</code>方法进行扩容。</li><li>然而当我们添加第二、三、…、十个元素时，因为<code>inCapacity - elementData.length &gt; 0</code>不成立，不会执行<code>ArrayList.grow()</code>方法进行扩容。</li></ul><h4 id="ArrayList-grow"><a href="#ArrayList-grow" class="headerlink" title="ArrayList.grow()"></a>ArrayList.grow()</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * 要分配的最大数组大小 */private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;/** * ArrayList扩容的核心方法。 */private void grow(int minCapacity) {    // oldCapacity为旧容量，newCapacity为新容量    int oldCapacity = elementData.length;    //将oldCapacity 右移一位，其效果相当于oldCapacity /2，    //我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);    //然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，    if (newCapacity - minCapacity &lt; 0)        newCapacity = minCapacity;   // 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，   //如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)        newCapacity = hugeCapacity(minCapacity);    // minCapacity is usually close to size, so this is a win:    elementData = Arrays.copyOf(elementData, newCapacity);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们再来看一下添加元素的过程：</p><ul><li>当我们添加第一个元素时，<code>elementData.length</code>为0，即<code>oldCapacity</code>为0，<code>newCapacity</code>为<code>oldCapacity</code>的1.5倍，因此也为0，<code>minCapacity</code>为10，第一个条件判断成立，第二个条件判断不成立，因此数组容量为10，size 为1，添加成功，返回 true。</li><li>当我们添加第11个元素时，<code>newCapacity</code>为 15，比 <code>minCapacity</code>（为 11）大，第一个 if 判断不成立。新容量没有大于数组最大 size，不会进入 <code>hugeCapacity</code>方法。数组容量扩为 15，size 变为11，添加元素成功，返回 true。</li><li>以此规则往复即可。</li></ul><h4 id="ArrayList-hugeCapacity"><a href="#ArrayList-hugeCapacity" class="headerlink" title="ArrayList.hugeCapacity()"></a>ArrayList.hugeCapacity()</h4><p>从上面的代码我们知道<code>MAX_ARRAY_SIZE</code>大小是有限的，那如果<code>newCapacity</code>大于<code>MAX_ARRAY_SIZE</code>怎么办？这就用到了<code>ArrayList.hugeCapacity()</code>方法了。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">private static int hugeCapacity(int minCapacity) {    if (minCapacity &lt; 0) // overflow        throw new OutOfMemoryError();    //对minCapacity和MAX_ARRAY_SIZE进行比较    //若minCapacity大，将Integer.MAX_VALUE作为新数组的大小    //若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小    //MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;    return (minCapacity &gt; MAX_ARRAY_SIZE) ?        Integer.MAX_VALUE :        MAX_ARRAY_SIZE;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="复制数组的方法"><a href="#复制数组的方法" class="headerlink" title="复制数组的方法"></a>复制数组的方法</h3><p>由上面的代码我们可以知道，添加元素实质上就是不断复制原数组、不断扩容的过程，对于复制数组用到了<code>System.arraycopy()</code> 和 <code>Arrays.copyOf()</code>方法。</p><h4 id="System-arraycopy"><a href="#System-arraycopy" class="headerlink" title="System.arraycopy()"></a>System.arraycopy()</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">// 我们发现 arraycopy 是一个 native 方法,接下来我们解释一下各个参数的具体意义/***   复制数组* @param src 源数组* @param srcPos 源数组中的起始位置* @param dest 目标数组* @param destPos 目标数组中的起始位置* @param length 要复制的数组元素的数量*/public static native void arraycopy(Object src,  int  srcPos,                                    Object dest, int destPos,                                    int length);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * 在此列表中的指定位置插入指定的元素。 * 先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大； * 再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。 */public void add(int index, E element) {    rangeCheckForAdd(index);    ensureCapacityInternal(size + 1);  // Increments modCount!!    //arraycopy()方法实现数组自己复制自己    //elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量；    System.arraycopy(elementData, index, elementData, index + 1, size - index);    elementData[index] = element;    size++;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Arrays;/** * @Author How-Young * @ClassName Test * @Time 16:34 */public class Test {    public static void main(String[] args) {        int[] a = {0,1,2,3,4,0,0,0,0,0};        System.arraycopy(a, 2, a, 3, 3);        a[2] = 33;        System.out.println(Arrays.toString(a));    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">[0, 1, 33, 2, 3, 4, 0, 0, 0, 0]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="Arrays-copyOf"><a href="#Arrays-copyOf" class="headerlink" title="Arrays.copyOf()"></a>Arrays.copyOf()</h4><p>源码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static int[] copyOf(int[] original, int newLength) {    // 申请一个新的数组    int[] copy = new int[newLength];// 调用System.arraycopy,将源数组中的数据进行拷贝,并返回新的数组    System.arraycopy(original, 0, copy, 0,                     Math.min(original.length, newLength));    return copy;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">/**  以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; 返回的数组的运行时类型是指定数组的运行时类型。  */ public Object[] toArray() { //elementData：要复制的数组；size：要复制的长度     return Arrays.copyOf(elementData, size); }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="区别与联系"><a href="#区别与联系" class="headerlink" title="区别与联系"></a>区别与联系</h4><p>联系：</p><p><code>Arrays.copyOf()</code>实际上就是调用了<code>System.arraycopy()</code></p><p>区别：</p><ul><li><code>arraycopy()</code> 需要目标数组，将原数组拷贝到你自己定义的数组里或者原数组，而且可以选择拷贝的起点和长度以及放入新数组中的位置 </li><li><code>copyOf()</code> 是系统自动在内部新建一个数组，并返回该数组。</li></ul><h3 id="ArrayList-ensureCapacity"><a href="#ArrayList-ensureCapacity" class="headerlink" title="ArrayList.ensureCapacity()"></a>ArrayList.ensureCapacity()</h3><p>在源码中，这个方法始终没有被调用过，因此这个方法肯定是留给咱们用户使用的，它的作用主要是：在有必要的情况下，增加此 ArrayList 实例的容量，以确保它至少可以容纳由minimum capacity参数指定的元素数。</p><p>其实说白了，就是在大量增加元素之前，调用这个方法，更改<code>minCapacity</code>的值，减少运行时间。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入了解深克隆与浅克隆</title>
      <link href="/posts/18234.html"/>
      <url>/posts/18234.html</url>
      
        <content type="html"><![CDATA[<h1 id="深入了解深克隆与浅克隆"><a href="#深入了解深克隆与浅克隆" class="headerlink" title="深入了解深克隆与浅克隆"></a>深入了解深克隆与浅克隆</h1><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><blockquote><p>原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。</p></blockquote><p>原型模式依靠 clone 来实现，在Java中 clone 的方式有两种——深克隆与浅克隆，本文将详细的讲解深克隆与浅克隆。</p><h2 id="浅克隆"><a href="#浅克隆" class="headerlink" title="浅克隆"></a>浅克隆</h2><p>浅克隆比较好实现，只需实现<code>Cloneable</code>接口即可，我们通过一个示例来详细的了解一下浅克隆机制。</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210628130300273.png" alt="浅克隆类图"></p><p>Student类：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package DeepCloneAndSimpleClone.Simple;/** * @Author How-Young * @ClassName Student * @Time 10:34 */public class Student{    private int age;    private String name;    private int num;    public Student() {    }    public Student(int age, String name, int num) {        this.age = age;        this.name = name;        this.num = num;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getNum() {        return num;    }    public void setNum(int num) {        this.num = num;    }    @Override    public String toString() {        return "Student{" +                "age=" + age +                ", name='" + name + '\'' +                ", num=" + num +                '}';    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Teacher类：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package DeepCloneAndSimpleClone.Simple;/** * @Author How-Young * @ClassName Teacher * @Time 10:40 */public class Teacher implements Cloneable {    private String name;    private int age;    private Student student;    public Teacher() {    }    public Teacher(String name, int age, Student student) {        this.name = name;        this.age = age;        this.student = student;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    public Student getStudent() {        return student;    }    public void setStudent(Student student) {        this.student = student;    }    @Override    public String toString() {        return "Teacher{" +                "name='" + name + '\'' +                ", age=" + age +                ", student=" + student +                '}';    }    @Override    protected Object clone() throws CloneNotSupportedException {        return super.clone();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试类：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package DeepCloneAndSimpleClone.Simple;/** * @Author How-Young * @ClassName Main * @Time 10:36 */public class Simple {    public static void main(String[] args) {        Student student = new Student(18, "张三", 1203123);        try {            Teacher teacher1 = new Teacher("李芳", 38, student);            Teacher teacher2 = (Teacher) teacher1.clone();            System.out.println(teacher1.equals(teacher2));            System.out.println(teacher1.getStudent().equals(teacher2.getStudent()));            student.setAge(36);            System.out.println(teacher1.getStudent().toString());            System.out.println(teacher2.getStudent().toString());        } catch (CloneNotSupportedException e) {            e.printStackTrace();        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果：</p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">falsetrueStudent{age=36, name='张三', num=1203123}Student{age=36, name='张三', num=1203123}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>由输出结果我们可以试着分析一下：</p><ul><li>首先，我们创建了一个Stundet的实例<code>student</code></li><li>然后我们又创建了一个Teacher的实例<code>teacher1</code></li><li>之后我们clone了t1生成了<code>teacher2</code></li><li>之后我们判断<code>teacher1</code>和<code>teacher2</code>以及这两个对象的<code>student</code>属性是否相同</li></ul><p>由输出结果我们可以看到<code>clone</code>是在内存中又开辟了一块空间，分配给了<code>teacher2</code>，但是两个对象的<code>student</code>属性还是指向同一个地址。因此，当我们尝试改变<code>student</code>的时候，两个值全部都改变了。<img src="https://gitee.com/sehowyoung/images/raw/master/image-20210628114406213.png" alt="浅克隆内存分析图" style="zoom: 50%;"></p><h2 id="深克隆"><a href="#深克隆" class="headerlink" title="深克隆"></a>深克隆</h2><p>深克隆与浅克隆最大的不同就是在于：将其所引用的对象也全部复制了一遍。话不多说，直接上代码。</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210628132114613.png" alt="深克隆类图"></p><p>Student类：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package DeepCloneAndSimpleClone.deep;import java.io.Serializable;/** * @Author How-Young * @ClassName Student * @Time 10:34 */public class Student implements Serializable {    private final static long serialVersionUID = 3838472827384L;    private int age;    private String name;    private int num;    public Student() {    }    public Student(int age, String name, int num) {        this.age = age;        this.name = name;        this.num = num;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getNum() {        return num;    }    public void setNum(int num) {        this.num = num;    }    @Override    public String toString() {        return "Student{" +                "age=" + age +                ", name='" + name + '\'' +                ", num=" + num +                '}';    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Teacher类：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package DeepCloneAndSimpleClone.deep;import java.io.*;/** * @Author How-Young * @ClassName Teacher * @Time 10:40 */public class Teacher implements Serializable {    private final static long serialVersionUID = 3838472827384L;    private String name;    private int age;    private Student student;    public Teacher() {    }    public Teacher(String name, int age, Student student) {        this.name = name;        this.age = age;        this.student = student;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    public Student getStudent() {        return student;    }    public void setStudent(Student student) {        this.student = student;    }    @Override    public String toString() {        return "Teacher{" +                "name='" + name + '\'' +                ", age=" + age +                ", student=" + student +                '}';    }    @Override    protected Teacher clone(){        try {            ByteArrayOutputStream bao = new ByteArrayOutputStream();            ObjectOutputStream objectOutputStream = new ObjectOutputStream(bao);            objectOutputStream.writeObject(this);            ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bao.toByteArray());            ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);            return (Teacher) objectInputStream.readObject();        } catch (IOException | ClassNotFoundException e) {            e.printStackTrace();        }        return null;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示例类：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package DeepCloneAndSimpleClone.deep;/** * @Author How-Young * @ClassName Deep * @Time 10:46 */public class Deep {    public static void main(String[] args) {        Student student = new Student(18, "张三", 2390239);        Teacher teacher1 = new Teacher("李芳", 36, student);        Teacher teacher2 = teacher1.clone();        System.out.println(teacher1.equals(teacher2));        System.out.println(teacher1.getStudent().equals(teacher2.getStudent()));    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">falsefalse<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>我们首先创建了一个Student的实例<code>student</code></li><li>然后我们创建了一个Teacher类的实例<code>teacher1</code></li><li>之后我们克隆了<code>teacher1</code>生成了<code>teacher2</code></li><li>最后我们分别对这两个实例以及实例的<code>student</code>属性是否相同进行了判断</li></ul><p>由结果我们可以看出：不仅这两个对象不同，而且这两个对象的<code>student</code>属性也不同。</p><p>大致克隆的过程就是：对<code>teacher1</code>和<code>student</code>进行克隆，并在内存中为它们开辟一块空间，因此当我们尝试改变原来的<code>student</code>的数据时，克隆的<code>student</code>不受影响。</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210628133440520.png" alt="深克隆内存分析图"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目管理课后题</title>
      <link href="/posts/38171.html"/>
      <url>/posts/38171.html</url>
      
        <content type="html"><![CDATA[<h1 id="课堂习题"><a href="#课堂习题" class="headerlink" title="课堂习题"></a>课堂习题</h1><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><ol><li>==项目==是为创造一种产品、服务或者结构而进行的临时性努力。</li><li>全球生产总值中大概有==25%==花费在项目上。</li><li>项目组合管理强调达到==战略==目标，项目管理专注于==战术==目标</li><li>==项目管理==是将知识、技能、工具和技术应用到项目活动，以达到组织的要求。</li><li>为相同的功能组合而实施的一系列应用开发项目，作为==项目群==的一部分，或许能够得到更好的管理</li><li>项目的三约束包括==范围==、==时间==、==费用==</li><li>PMI提供的认证项目叫==Project Management Professional（PMP）==</li></ol><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><ol><li>==可交付成果==是作为项目的一部分所提供的一件产品或者服务。</li><li>阶段出口又叫做==终止点==</li><li>人员在==矩阵型==组织结构中通常向两个或更多的上级报告</li><li>组织4个框架中，==标志框架==涉及如何举行会议、员工衣着样式和预期工作时间。</li><li>系统管理的三维模型有==业务==、==技术==、==组织==</li><li>项目工作通常在这样的组织文化中最易成功，该文化具有很高的特性，除了==控制==</li><li>==系统开发生命周期==是用来描述系统开发不同阶段的框架</li><li>IT项目的性质不同于许多其他行业的项目，因为他们是很==多样的==</li><li>==离岸外包==可以用来描述组织从国外寻找外部资源以获得需要的产品或原材料。</li></ol><h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><ol><li>==过程==是针对某一特定结果的一系列活动。</li><li>==实施==过程包括协调人及其他资源，以全面观测落实项目计划，输出项目或项目阶段的产品、服务</li><li>==实施==过程组通常是最需要资源和时间。 </li><li>工作分解结构、项目进度表、成本预算是==计划==过程的结果。</li><li>==监控==包括根据项目目标来衡量项目进度，并采取纠正措施。</li><li>==计划==过程涉及九个知识领域</li><li>==方法论==描述了事情应该怎样去做，并且不同的组织通常采用不同的方式</li><li>启动过程包括制定一个项目章程和项目初步范围说明书，这涉及项目==集成==管理知识。</li><li>项目小组做==经验总结报告==来总结项目对在哪里、错在哪里</li><li>很多人在编制各种项目管理文件时都是用==模板==作为标准格式</li></ol><h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><ol><li>在选择IT项目时，4个阶段规划过程的最后一步是==资源分配==</li><li>==项目章程==是一份正式认可项目存在的文件，并为项目目标和管理提供方向。</li><li>项目产生的文档清单、终止项目文件以及历史资料都是==过程资产==的例子</li><li>如果一个项目总的折现后的收益是120000美元，总的折现后的费用是100000美元，则回报率（ROI）是==20%==</li><li>项目经理通过==配置管理==来在整个项目生命周期内识别、估计和管理变更。</li><li>一项新的政府法令要求组织以新的方式报告数据。一个提供这种数据的新的信息系统项目应归为==指令==</li></ol><h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><ol><li>==范围==指包括生产项目产品及用于生产产品的过程中的所有工作</li><li>在需求收集阶段，==访谈==成本最高且耗时最长</li><li>==WBS==是一个项目中以可交付成果为导向的涉及所有工作的一种分组，它定义了项目的整体范围</li><li>创建WBS时，==心智图法==是以非线条格式将想法写出或画出</li><li>假设你有一个项目，该项目的主要条目为计划、分析、设计和测试，那么这些事项处于WBS中的层级是==2==</li><li>范围说明书是作为==范围规划==部分的产物</li><li>范围==验证==通常是通过客户检查来完成，然后以关键的可交付成果收尾。</li><li>项目管理软件可帮助构建==WBS==，它可为制作甘特图、分配资源以及分摊成本打下基础</li></ol><h2 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h2><ol><li>编制项目进度的第一个过程是==活动定义==</li><li>紧前活动、紧后活动、逻辑关系、提前和滞后、资源需求、约束条件、强制日期和活动相关的假设都是==活动属性==中的内容</li><li>在其他人拟定完糟糕之前，你不能开始编辑一项技术报告，这个关系模型是==完成—开始==</li><li>==追踪甘特图==显示了计划和实际的项目进度信息</li><li>==计划评审技术==是一种网络图技术，用于预测整个项目的工期</li><li>一般用甘特图中的==白钻石==符号表示延误的里程碑</li><li>==关键链进度编制法==是一种进度编制方法。当指定项目进度是，该方法考虑了资源的有限性，并设置了时间缓冲以保证项目按时完成。</li></ol><h2 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h2><ol><li>==成本==是为了达到一个具体的目标而牺牲或用过的资源，或为了交换而放弃的一些事情</li><li>==在允许的预算内完成一个项目==是成本管理的主要目标</li><li>如果一家公司因为某一个产品，再每100美元的收入中损失5美元，这个产品的利润率是==-5%==</li><li>你正基于一个房子的地点、目的、平米数和其它特点来进行成本估计，那你使用的是==参数==估计技术。</li><li>==项目成本预算==涉及将项目成本估计分配给单个工作条目</li><li>==挣值分析==项目绩效衡量方法包括了范围、时间和成本数据</li><li>如果一个项目完成了一半，并且它的进度绩效指数是110%，成本绩效指数95%，它的进展状况是==它提前于进度，超出了预算==。</li><li>==管理==储备主要考虑的是将来不可预期的情况</li></ol><h2 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h2><ol><li>==质量==是指满足一定系列内在特征的程度</li><li>==标杆管理==是通过与组织内或组织外的项目进行对比，对比它们的项目实践或者产品特性，未知量改进提供想法和建议的一种技术</li><li>你可以使用==散点图==来看两个变量值之间存在某种关系</li><li>你可以使用==控制图==判断一个过程处于控制中还是失控了</li><li>$6\sigma$追求的完美目标是每百万个机会中有不超过==3.4==个缺陷、误差或错误</li><li>七点运行定律是指，如果在一个质量控制图的一行上有7个数据点都低于平均值或高于平均值，或者都是上升的或都是下降的，这个过程就需要因为==飞随机==问题而接受检查</li><li>IT项目实施测试的首选顺序是==单元测试、集成测试、系统测试、用户验收测试==</li><li>PMI的OPM3是一个==成熟度==模型或框架的例子，用以帮助组织改进其过程和系统</li></ol><h2 id="第九章"><a href="#第九章" class="headerlink" title="第九章"></a>第九章</h2><ol><li>==内在动机==驱使人们为了自身的兴趣参与一项活动</li><li>马斯洛需求层次理论金子岩的最底层的需求是==生理==需求</li><li>根据麦克利兰的获取需求理论，那些渴望与他人建立和睦关系并被周围的人所接受的人是高==亲和==需求的人</li><li>==参照==权利建立在个人魄力和榜样的基础之上</li><li>==责任分配矩阵==可用来图解表示</li></ol><h2 id="知识补充"><a href="#知识补充" class="headerlink" title="知识补充"></a>知识补充</h2><h3 id="项目生命周期"><a href="#项目生命周期" class="headerlink" title="项目生命周期"></a>项目生命周期</h3><ul><li>概念阶段：制定项目总体计划</li><li>开发阶段：制定更详细的项目计划</li><li>实施阶段：执行项目计划，并对其进行监督与控制</li><li>收尾阶段：项目验收与工作总结</li></ul><h3 id="继承变更控制生命周期"><a href="#继承变更控制生命周期" class="headerlink" title="继承变更控制生命周期"></a>继承变更控制生命周期</h3><p>集成变更控制( integrated change control) 涉及在整个项目的生命周期中==识别、估计和管理变更== 。</p><h3 id="项目管理过程组全过程"><a href="#项目管理过程组全过程" class="headerlink" title="项目管理过程组全过程"></a>项目管理过程组全过程</h3><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210624091847432.png" alt="image-20210624091847432"></p><ul><li>启动过程：定义一个新项目或现有项目的一个新阶段，授权开始该项目或阶段的一组过程<ul><li>概念阶段成果：形成一个项目章程和选择一位项目经理</li><li>新阶段成果：对阶段进入条件的评估与确认</li></ul></li><li>计划过程：包括制订和维护一个可执行的计划，以保证项目满足组织的要求。<ul><li>成果：工作分解结构和范围说明书、项目进度和项目成本估计</li></ul></li><li>执行过程：包括协调人力和其他资源来执行项目的计划，以产生项目或者项目阶段的产品、服务或者结果。<ul><li>成果：按计划完成项目工作</li></ul></li><li>监控过程：包括有规律地测量和监视项目进程以保证项目团队能够满足项目目标。<ul><li>理想成果：通过交付满足时间、成本和质量约束的项目来成功地完成项目。</li></ul></li><li>收尾过程：包括对项目或者项目阶段的正式验收，并有效地终止，使项目或项目阶段任务有序、圆满的完成。<ul><li>关键结果：工作的正式验收和以及项目审计和项目经验总结报告等一些总结性文件的编写、提交、审定和归档。</li></ul></li></ul><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210624100236676.png" alt="九大知识领域与五大过程"></p><h3 id="九大知识领域"><a href="#九大知识领域" class="headerlink" title="九大知识领域"></a>九大知识领域</h3><h4 id="项目集成管理"><a href="#项目集成管理" class="headerlink" title="项目集成管理"></a>项目集成管理</h4><ul><li>项目集成管理：为确保项目各项工作能够有机地协调和配合所开展的综合性和全局性的项目管理工作和过程。</li><li>主要工作：<ul><li>制定项目章程：正式批准项目的文件——项目章程</li><li>创建初步的项目规范说明书</li><li>制定项目管理计划：用来协调所有项目计划文件和帮助引导项目的执行与控制。</li><li>指导和管理项目实施</li><li>监控项目工作</li><li>整体变更控制</li><li>项目收尾</li></ul></li><li>筛选信息技术项目过程：<ul><li>IT战略计划</li><li>业务分析</li><li>项目计划</li><li>资源分配</li></ul></li><li>SWOT：优劣机遇挑战</li></ul><p>净现值（NPV）：未来资金流入和资金流出的差额</p><h4 id="项目范围管理"><a href="#项目范围管理" class="headerlink" title="项目范围管理"></a>项目范围管理</h4><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210624143340158.png" alt="image-20210624143340158"></p><ul><li><p>项目范围管理：指对项目包括什么与不包括什么的定义与控制过程。</p></li><li><p>五阶段：</p><ul><li>范围规划：范围说明书、详细依据、范围管理计划</li><li>范围定义：工作分解结构、范围说明书更新</li><li>工作结构分解</li><li>范围验证：正式接受</li><li>范围控制</li></ul></li></ul><h4 id="项目时间管理"><a href="#项目时间管理" class="headerlink" title="项目时间管理"></a>项目时间管理</h4><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210624164540182.png" alt="image-20210624164540182"></p><ul><li>项目计划：指导项目实施和控制的一系列文件</li><li>进度计划：表达项目中各项工作的开展顺序、开始及完成时间及相互衔接关系的计划</li><li>活动或任务：是项目进行期间</li><li>活动排序：<ul><li>ADM箭线图法</li><li>AOA双代号网络图法</li><li>PDM-AON前导图法——单代号网络</li></ul></li><li>进度安排：<ul><li>甘特图</li><li>关键路径法</li><li>计划评审技术</li></ul></li></ul><h4 id="项目成本管理"><a href="#项目成本管理" class="headerlink" title="项目成本管理"></a>项目成本管理</h4><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210624183646937.png" alt="image-20210624183646937"></p><ul><li>成本：未达到一个特定的目标而花费或者用掉的资源</li><li>项目成本：实现项目目标所消耗资源的资源形成的费用</li><li>学习曲线理论：当重复生产许多产品时，那些生产产品的单位成本随着数量的增多成规律性递减。</li><li>储备金：包含于成本估算中的、为减轻未来难以预测轻型带来的成本风险而准备的那部分资金</li><li>项目成本管理：包括保障项目实际发生成本不超过预算而开展的项目成本估算、成本预算和成本控制等方面的管理需求</li><li>挣值方法：对项目范围、进度和成本进行综合控制的一种有效方法</li></ul><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210624192334583.png" alt="image-20210624192334583"></p><ul><li><p>两个偏差：</p><ul><li>CV：$CV=EV-AC$</li><li>SV： $SV=EV-PV$</li></ul></li><li><p>两个绩效指标：</p><ul><li><p>CPI：$CPI=\frac {EV} {AC}$</p></li><li><p>SPI：$SPI=\frac {EV} {PV}$</p></li></ul></li><li><p>三个基本参数：</p><ul><li>实际成本：$ACWP=AC$</li><li>预算成本：$BCWS=$</li><li>已完成的预算成本：$BCWP=$</li></ul></li></ul><h4 id="项目质量管理"><a href="#项目质量管理" class="headerlink" title="项目质量管理"></a>项目质量管理</h4><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210624213303648.png" alt=""></p><ul><li>质量管理：在质量方面指挥和控制组织的协调活动</li><li>项目质量管理：为了保障产物能够满足客户以及各相关利益者的需要所开展的对于项目产物的质量和项目工作质量的全面管理工作</li><li>软件质量特性：功能性、可靠性、易用性、效率、可维护性、可移植性</li><li>质量发展四个阶段：<ul><li>传统质量管理阶段</li><li>统计质量管理阶段</li><li>全面质量管理阶段</li><li>现代质量管理阶段</li></ul></li><li>PDCA：plan、do、check、act</li><li>质量控制——5M1E：<ul><li>materials材料</li><li>machine机器设备</li><li>man人</li><li>method方法</li><li>environment环境</li></ul></li></ul><h4 id="项目人力资源管理"><a href="#项目人力资源管理" class="headerlink" title="项目人力资源管理"></a>项目人力资源管理</h4><h4 id="项目沟通管理"><a href="#项目沟通管理" class="headerlink" title="项目沟通管理"></a>项目沟通管理</h4><h4 id="项目风险管理"><a href="#项目风险管理" class="headerlink" title="项目风险管理"></a>项目风险管理</h4><h4 id="项目采购管理"><a href="#项目采购管理" class="headerlink" title="项目采购管理"></a>项目采购管理</h4>]]></content>
      
      
      <categories>
          
          <category> 资料总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSU </tag>
            
            <tag> 软件项目组织管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>github加速访问的几种方法</title>
      <link href="/posts/14750.html"/>
      <url>/posts/14750.html</url>
      
        <content type="html"><![CDATA[<h1 id="github加速访问的几种方法"><a href="#github加速访问的几种方法" class="headerlink" title="github加速访问的几种方法"></a>github加速访问的几种方法</h1><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>有些同学在做实验时需要在github上下载一些文件，但是github又被墙了，因此老是询问我如何去github上下载，本文我就记述了几种加速访问github的方法。</p><h2 id="github镜像访问"><a href="#github镜像访问" class="headerlink" title="github镜像访问"></a>github镜像访问</h2><p>下面是两个github的镜像网站，网站是跟github完全同步的，可以在这些网站里面进行下载克隆等操作：</p><ul><li><a href="https://github.com.cnpmjs.org/">https://github.com.cnpmjs.org/</a></li><li><a href="https://hub.fastgit.org/">https://hub.fastgit.org/</a></li></ul><h2 id="CDN文件访问加速"><a href="#CDN文件访问加速" class="headerlink" title="CDN文件访问加速"></a>CDN文件访问加速</h2><p>利用 Cloudflare Workers 对 github release 、archive 以及项目文件进行加速，部署无需服务器且自带CDN：</p><ul><li><a href="https://gh.api.99988866.xyz/">https://gh.api.99988866.xyz/</a></li><li><a href="https://ghproxy.com/">https://ghproxy.com/</a></li></ul><p>我们可以复制某个github页面的URL，然后粘贴到这些网站里面，即可实现访问下载。</p><p>虽说二者皆可实现下载，但是第一个大小限制为20MB，第二个暂不清楚。</p><h2 id="github加速下载"><a href="#github加速下载" class="headerlink" title="github加速下载"></a>github加速下载</h2><p>除了上述的方式，还可以使用下面这个链接进行加速下载：</p><ul><li><a href="http://toolwa.com/github/">http://toolwa.com/github/</a></li></ul><h5 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h5><ol><li>打开你要下载的 <a href="https://github.com/">GitHub</a> 仓库页面</li><li>点击右侧的绿色按钮 “Code” &gt; “Download ZIP”</li><li>等浏览器弹出下载框后复制下载框中的链接地址并粘贴到以上输入框</li><li>点击加速下载</li></ol><h2 id="加速你的Github"><a href="#加速你的Github" class="headerlink" title="加速你的Github"></a>加速你的Github</h2><p><a href="https://github.zhlh6.cn/">https://github.zhlh6.cn/</a></p><p>输入 Github 仓库地址，使用生成的地址进行 git ssh 等操作.</p><h2 id="github加速插件"><a href="#github加速插件" class="headerlink" title="github加速插件"></a>github加速插件</h2><p>可以在浏览器的插件市场里面搜索<code>Enhanced GitHub</code>，打开就可以很快的访问github</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210621151756506.png" alt="Enhanced GitHub"></p><p>也可以点击我这个链接直接进行下载，然后打开浏览器拓展—&gt;<code>开发者模式</code>—&gt;将改文件拖进去进行安装。<a href="https://cdn.jsdelivr.net/gh/sehowyoung/DataRepository@main/Enhanced%20GitHub.crx">https://cdn.jsdelivr.net/gh/sehowyoung/DataRepository@main/Enhanced%20GitHub.crx</a></p><h2 id="github-raw-加速"><a href="#github-raw-加速" class="headerlink" title="github raw 加速"></a>github raw 加速</h2><p>GitHub raw 域名并非 github.com 而是 raw.githubusercontent.com，上方的 GitHub 加速如果不能加速这个域名，那么可以使用 Static CDN 提供的反代服务。</p><p>将 raw.githubusercontent.com 替换为 raw.staticdn.net 即可加速。</p><h2 id="jsdeliver-加速"><a href="#jsdeliver-加速" class="headerlink" title="jsdeliver 加速"></a>jsdeliver 加速</h2><p>jsdelivr 唯一美中不足的就是它不能获取 exe 文件以及 Release 处附加的 exe 和 dmg 文件，同时也不能下载超过20MB的文件。</p><p>也就是说如果 exe 文件是附加在 Release 处但是没有在 code 里面的话是无法获取的。所以只能当作静态文件 cdn 用途，而不能作为 Release 加速下载的用途。</p><h3 id="使用方法：-1"><a href="#使用方法：-1" class="headerlink" title="使用方法："></a>使用方法：</h3><p><a href="https://cdn.jsdelivr.net/gh/你的用户名/你的仓库名@发布的版本号/文件路径">https://cdn.jsdelivr.net/gh/你的用户名/你的仓库名@发布的版本号/文件路径</a></p><p>例如：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">https://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@1.0/images/trhx.pnghttps://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@2.0.1/css/style.css  https://cdn.jsdelivr.net/gh/moezx/cdn@3.1.3//The%20Pet%20Girl%20of%20Sakurasou.mp4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>注意：版本号不是必需的，是为了区分新旧资源，如果不使用版本号，将会直接引用最新资源，除此之外还可以使用某个范围内的版本，查看所有资源等，具体使用方法如下：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">// 加载任何Github发布、提交或分支https://cdn.jsdelivr.net/gh/user/repo@version/file// 加载 jQuery v3.2.1https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/dist/jquery.min.js// 使用版本范围而不是特定版本https://cdn.jsdelivr.net/gh/jquery/jquery@3.2/dist/jquery.min.js   https://cdn.jsdelivr.net/gh/jquery/jquery@3/dist/jquery.min.js // 完全省略该版本以获取最新版本https://cdn.jsdelivr.net/gh/jquery/jquery/dist/jquery.min.js // 将“.min”添加到任何JS/CSS文件中以获取缩小版本，如果不存在，将为会自动生成https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/src/core.min.js // 在末尾添加 / 以获取资源目录列表https://cdn.jsdelivr.net/gh/jquery/jquery/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Gitee进行仓库迁移"><a href="#Gitee进行仓库迁移" class="headerlink" title="Gitee进行仓库迁移"></a>Gitee进行仓库迁移</h2><p>访问 gitee 网站：<a href="https://gitee.com/">https://gitee.com/</a> 并登录，在顶部选择“从 GitHub/GitLab 导入仓库”</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210610194849360.png" alt="从GitHub/GitLab导入仓库"></p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210610194922761.png" alt="选择仓库进行导入"></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://segmentfault.com/a/1190000038298623">提高国内访问 github 速度的 9 种方法！</a></li><li><a href="https://zhuanlan.zhihu.com/p/76951130">免费CDN：jsDelivr+Github 使用方法</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件项目组织管理资料总结—CSU</title>
      <link href="/posts/13116.html"/>
      <url>/posts/13116.html</url>
      
        <content type="html"><![CDATA[<h1 id="软件项目管理"><a href="#软件项目管理" class="headerlink" title="软件项目管理"></a>软件项目管理</h1><p>PDF版下载地址：<a href="https://cdn.jsdelivr.net/gh/sehowyoung/DataRepository@main/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%BB%84%E7%BB%87%E7%AE%A1%E7%90%86%E8%B5%84%E6%96%99%E6%80%BB%E7%BB%93%E2%80%94CSU.pdf">点此下载</a></p><h2 id="走进项目管理"><a href="#走进项目管理" class="headerlink" title="走进项目管理"></a>走进项目管理</h2><h3 id="项目的基本概念"><a href="#项目的基本概念" class="headerlink" title="项目的基本概念"></a>项目的基本概念</h3><p>活动的三个基本特点：</p><ul><li>目的性：为了达到预期的目的而活动</li><li>依存性：分工越来越细，依存越来越紧密</li><li>知识性：在实践与经验中学习，形成知识体系</li></ul><p>两种人类有组织的活动：</p><ul><li>作业（Operations 运行 运营）：连续不断、周而复始的活动，例：企业日常的生产产品的活动、财务人员的日常记账工作等</li><li>项目（Projects）：临时性的、一次性的活动，例：企业开发新产品、企业的技术改造活动等</li></ul><p>项目是实现价值、成就事业的载体；项目管理既是项目成功的要素，也是项目失败的根源。</p><p>项目是为完成某一独特的产品或服务而进行的一次性努力。</p><p>项目的特征：</p><ul><li>项目有一个独特的目的(功能指标、产出物指标、项目工作指标、范围、时间、成本、质量目标)</li><li>一次性：不存在完全相同的项目</li><li>项目需要来自不同领域的各种各样的资源</li><li>整体性：不是一项项孤立活动的堆积</li><li>临时性：有规定的时间段</li><li>不确定性：目标的复杂性和可变性</li><li>多变性：资源需求动态、多变、不确定</li><li>随着发展逐渐进行细化,渐进明晰(过程性)</li><li>具有发起人：提供目标和资金</li></ul><p>项目的组成要素：</p><ul><li>时间：完成该项目需要多长时间?项目进度应该怎样安排？</li><li>范围：项目的任务是什么?顾客或发起人要通过项目获得什么样的产品或服务？</li><li>费用：完成该项目需要花费多少？</li></ul><p>项目管理是指在项目活动中运用相关的知识、技能、工具和方法，以实现或超过项目干系人的需要和期望。</p><p>IT项目的定义：利用有限资源、在一定的时间内，完成满足一系列特定的IT信息化目标的多项相关工作。</p><p>软件项目管理：为了使软件项目能够按照预定的范围、成本、进度、质量顺利完成，而对范围、费用、时间、质量、人力资源、风险、采购等进行分析和管理的活动。</p><p>软件项目失败的原因：一是软件项目的复杂性，二是缺乏合格的软件项目管理人才。缺乏有效的项目管理是导致软件项目失控的直接原因。</p><p>项目的利益相关者：</p><ul><li>参与项目或受项目影响的个人或组织——项目 <code>干系人</code></li><li>主要的 <code>项目利益相关者</code> ：<ul><li>项目经理</li><li>客户</li><li>项目执行组织</li><li>项目团队成员</li><li>项目发起人、出资方</li></ul></li><li><code>管理工具与方法</code><ul><li>识别各干系人，确定项目干系人需求和渴望</li><li>管理和影响项目干系人的期望以确保项目成功。</li></ul></li></ul><p>项目管理和作业管理的区别：</p><ul><li><p>| 项目管理             | 作业管理                       | 项目组合管理         |<br>| —————————— | ——————————————— | —————————— |<br>| 充满不确定性         | 注重对效率和质量的考核         | 战略目标             |<br>| 有严格的时间期限要求 | 注重当前执行情况与前期进行比较 | 项目组合的投资回报   |<br>| 跨越部门的界限       |                                | 资源约束下的项目选择 |</p></li><li><p>项目管理：通过不完全确定的过程，在确定的期限内生产出不完全确定的产品。</p></li><li><p>作业管理：管理结构须以任务（活动）定义为基础来建立，以便进行时间、费用和人力的预算控制，并对技术、风险进行管理。</p></li></ul><h3 id="项目管理知识体系"><a href="#项目管理知识体系" class="headerlink" title="项目管理知识体系"></a>项目管理知识体系</h3><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210621105545697.png" alt="基于PMBOK的项目管理框架" style="zoom:67%;"></p><h3 id="项目管理九大知识领域"><a href="#项目管理九大知识领域" class="headerlink" title="项目管理九大知识领域"></a>项目管理九大知识领域</h3><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210621105433640.png" alt="项目管理九大知识领域" style="zoom:50%;"></p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210621105943730.png" alt="项目管理九大知识领域" style="zoom: 67%;"></p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210621105450557.png" alt="项目管理工具和技术" style="zoom:67%;"></p><h3 id="IT项目管理知识体系"><a href="#IT项目管理知识体系" class="headerlink" title="IT项目管理知识体系"></a>IT项目管理知识体系</h3><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210621110916272.png" alt="iPMBOK三维结构模型" style="zoom:50%;"></p><h3 id="项目群和项目组合管理"><a href="#项目群和项目组合管理" class="headerlink" title="项目群和项目组合管理"></a>项目群和项目组合管理</h3><p>项目群（program）：多个相互关联项目的集合，且多个项目间有如下两大基本特征：</p><ul><li>相互关联</li><li>每个项目相互间有一定的相似性</li></ul><p>项目群管理（program Management）：一组相互关联的项目，使用协同方法进行管理来获得收益和进行控制，而这种收益和控制在单独管理这些项目时是不易获得的。</p><p>项目群管理强调：</p><ul><li>集成（如IT项目的弱电集成项目）</li><li>协同与资源优化</li></ul><p>项目组合管理——对由项目和项目群有机组合的整体所开展的管理。</p><p>项目组合的目的——实现组织战略和愿景，也称战略项目组合。</p><p>项目管理和项目组合管理的不同之处：最主要的区别在各自致力于达到的目标上，战术目标还是战略目标。（战术目标更具体,时间短；战略目标重点强调一组织的长期目标），如下图所示：</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210621111556738.png" alt="项目管理和项目组合管理的不同之处" style="zoom:50%;"></p><h3 id="项目经理"><a href="#项目经理" class="headerlink" title="项目经理"></a>项目经理</h3><p>项目群经理对项目组内的项目进行领导并指明方向。协调项目团队，职能部门，供应商和运营员，以支持项目达到产品和过程的最大收益。</p><p>项目经理首要职责是在预算范围内按时优质地领导项目小组完成全部项目工作内容，并使客户满意。</p><p>项目经理应掌握的技能：</p><ul><li>领导技能：在激励人们达到目标时专注于长期以及整体的目标。</li><li>管理技能：常关注为达到具体目标所需要的日常细节。</li></ul><h3 id="项目管理发展阶段"><a href="#项目管理发展阶段" class="headerlink" title="项目管理发展阶段"></a>项目管理发展阶段</h3><p>项目管理大致经历了潜意识阶段、传统项目管理阶段、项目管理的传播阶段和现代项目管理的发展阶段。</p><h2 id="项目管理与信息技术环境"><a href="#项目管理与信息技术环境" class="headerlink" title="项目管理与信息技术环境"></a>项目管理与信息技术环境</h2><h3 id="项目管理的系统观点"><a href="#项目管理的系统观点" class="headerlink" title="项目管理的系统观点"></a>项目管理的系统观点</h3><p>系统方法：产生于20世纪50年代, 描述一种在解决复杂问题时所需的整体性和分析性的方法。</p><p>包括三部分：</p><ul><li>系统哲学 — 将事情作为系统考虑的整体模型</li><li>系统分析 — 解决问题的方法</li><li>系统管理 — 解决与系统的创建、维持和变更相关的业务上、技术上和组织上的问题</li></ul><h3 id="组织"><a href="#组织" class="headerlink" title="组织"></a>组织</h3><p>环境：组织外不存在的一切客观因素和条件</p><p>组织：按照一定目的、任务和刑事加以编制的群体</p><p>组织环境：存在于组织外部，和组织密切联系，决定组织存在和发展的自然、经济、技术、政治、社会的各种因素和条件的总和。任何一个组织都离不开外部因素和条件而独立存在。</p><p>组织的四个框架：</p><ol><li>结构框架：用来解决组织结构化的问题着眼于不同部门的角色、责任，以满足最高管理层设定的目标和政策（重点用于协调、控制）</li><li>人力资源框架：重点在于促成组织需求和个人需求之间的平衡与协调</li><li>政治框架：处理组织和人的政治问题；假定组织是由各种人和利益集团组成的联合体；冲突和权力是中心问题</li><li>标志框架：主要指与事件相关的符号和含义；文化很重要</li></ol><p>三种组织结构：</p><ul><li><p>职能型：职能经理向CEO汇报</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210621163317917.png" alt="职能型组织" style="zoom:50%;"></p></li><li><p>项目型：项目经理对CEO负责</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210621163338089.png" alt="项目型组织" style="zoom:50%;"></p></li><li><p>矩阵型：介于职能型组织和项目型组织之间，需要向两个或多个上级汇报，分为弱矩阵、平衡矩阵和强矩阵</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210621163404898.png" alt="弱矩阵型组织" style="zoom:50%;"></p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210621163549393.png" alt="平衡矩阵型组织" style="zoom:50%;"></p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210621163618317.png" alt="强矩阵型组织" style="zoom:50%;"></p></li></ul><h3 id="项目阶段和项目生命周期"><a href="#项目阶段和项目生命周期" class="headerlink" title="项目阶段和项目生命周期"></a>项目阶段和项目生命周期</h3><p>项目生命周期是项目阶段的集合，负责定义</p><ul><li>每个阶段要完成哪些工作</li><li>制造哪些可交付的成果, 及何时提交</li><li>每个阶段有哪些参与人员</li><li>每个阶段如何控制管理和批准已制造的工作</li></ul><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210621164235571.png" alt="项目生命周期基本框架" style="zoom:50%;"></p><p>四个阶段主要任务：</p><ul><li>概念阶段：主要任务是制定高水平的总体计划/总体方案/项目建议书</li><li>开发阶段：主要任务是规划项目怎么做？谁来做？项目组要根据总体计划/总体方案，制定出更为详细的项目计划/项目规划。</li><li>实施阶段：主要工作是执行项目计划，并进行项目的监督和控制。其目的就是把计划/规划中的内容完成。</li><li>收尾阶段：主要任务完成项目的验收与工作总结，为后续的项目提供经验、教训和帮助。 </li></ul><p>管理评审被称为阶段出口或终止点：</p><ul><li>在每个项目阶段结束后发生</li><li>评估项目进度、成功可能性以及项目与商业目标持续的兼容性</li></ul><p>项目管理评审的目的是要判断项目是否应该继续、重新定位或终止。每个阶段的管理评审，对后阶段的工作起指导性的作用，务必严格执行。</p><h3 id="IT项目环境"><a href="#IT项目环境" class="headerlink" title="IT项目环境"></a>IT项目环境</h3><p>虚拟团队是虚拟组织中一种新型的工作组织形式，是一些人由于具有共同理想、共同目标或共同利益，结合在一起所组成的团队。从狭义上说，虚拟团队仅仅存在于虚拟的网络世界中；广义来说，虚拟团队早已应用在真实的团队建设世界里。虚拟团队只要通过电话、网络、传真或可视图文来沟通、协调，甚至共同讨论、交换文档，便可以分工完成一份事先拟定好的工作。</p><p>换句话说，虚拟团队就是在虚拟的工作环境下，由进行实际工作的真实的团队人员组成，并在虚拟企业的各成员相互协作下提供更好的产品和服务。虚拟团队作为一种新型的组织形态，具有不少优于传统团队的特征。</p><h3 id="项目管理过程组"><a href="#项目管理过程组" class="headerlink" title="项目管理过程组"></a>项目管理过程组</h3><p>过程——是为实现某个特定目标而进行的一系列活动。</p><p>项目管理过程组：是从启动到计划、执行（实施）、控制（监控）和收尾的一系列活动。</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210621170831633.png" alt="项目管理过程组在活动水平、时间上的相互叠加关系" style="zoom:50%;"></p><p>各过程组的成果：</p><ul><li>启动过程成果：<ul><li>开始阶段：是形成一个项目章程和选择一位项目经理。</li><li>新阶段：是对阶段进入条件的评估与确认</li></ul></li><li>计划过程成果：包括完成工作分解结构和范围说明书、项目进度和项目成本估计</li><li>执行过程成果：按计划完成项目工作，即项目实际工作的交付。</li><li>监控过程成果：理想产出是通过交付满足时间、成本和质量约束的项目来成功地完成项目。</li><li>收尾过程成果：关键结果是工作的正式验收和以及项目审计和项目经验总结报告等一些总结性文件的编写、提交、审定和归档。</li></ul><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210621171709136.png" alt="九九归一" style="zoom: 50%;"></p><div class="table-container"><table><thead><tr><th>知识领域</th><th>启动过程</th><th>计划过程</th><th>实施过程</th><th>监控过程</th><th>收尾过程</th></tr></thead><tbody><tr><td>项目集成管理</td><td>制定项目章程</td><td>制定项目管理计划</td><td>指导和管理项目实施</td><td>监控项目工作、整体变更控制</td><td>项目收尾</td></tr><tr><td>项目范围管理</td><td></td><td>需求收集、范围定义和创建工作分解结构</td><td></td><td>范围核实、范围控制</td><td></td></tr><tr><td>项目时间管理</td><td></td><td>活动定义、活动排序、活动资源估算、活动工期估算、生成进度表</td><td></td><td>进度控制</td><td></td></tr><tr><td>项目成本管理</td><td></td><td>成本估算、成本预算</td><td></td><td>成本控制</td><td></td></tr><tr><td>项目质量管理</td><td></td><td>质量计划</td><td>实施质量保证</td><td>实施质量控制</td><td></td></tr><tr><td>项目人力资源管理</td><td></td><td>开发人力资源计划</td><td>项目团队组建、项目团队建设</td><td>项目团队管理</td><td></td></tr><tr><td>项目沟通管理</td><td>识别利益相关者</td><td>沟通计划</td><td>信息发布</td><td>绩效报、告利益相关者管理</td><td></td></tr><tr><td>项目风险管理</td><td></td><td>风险管理计划、风险识别、定型风险估计、定量风险分析、风险应对计划</td><td></td><td>风险监控</td><td></td></tr><tr><td>项目采购管理</td><td></td><td>采购与获取计划、发包计划</td><td>询价、选择卖方</td><td>采购管理</td><td>采购终止</td></tr></tbody></table></div><h2 id="项目集成管理"><a href="#项目集成管理" class="headerlink" title="项目集成管理"></a>项目集成管理</h2><p>项目集成管理是指为确保项目各项工作能够有机地协调和配合所开展的综合性和全局性的项目管理工作和过程。</p><p>七个过程：</p><ol><li>指定项目章程</li><li>创建初步的项目范围说明书</li><li>制定项目管理计划</li><li>指导和管理项目实施：这个阶段主要完成交付物、变更请求、工作绩效信息、被实施的变更请求、纠正措施、预防措施和缺陷修复。</li><li>监控项目工作：这个阶段主要完成惩治和预防措施建议、缺陷修复建议以及变更请求。</li><li>整体变更控制：这个阶段的任务包括被批准和被拒绝的变更请求、被批准的纠正和预防措施、被批准和生效的缺陷修复、交付物、项目管理计划和项目范围说明书的更新。</li><li>项目收尾：这个阶段包括最终产品、服务或者成果，行政上和合同上的终止于续，以及对组织运营资产的更新。</li></ol><p>战略计划(strategic planning) 包括通过分析组织的优势和劣势，研究在商业环境中的机会和威胁，<code>预测未来的趋势</code> ，以及预测对新产品和服务的需求来 <code>确定长期的目标</code>。</p><p>SWOT 即基于内外部竞争环境和竞争条件下的态势分析，就是将与研究对象密切相关的各种主要<code>内部优势、劣势和外部的机会和威胁</code>等，通过调查列举出来，并依照 <code>矩阵</code> 形式排列，然后用<code>系统分析</code>的思想，把各种因素相互匹配起来加以分析，从中得出一系列相应的结论，而结论通常带有一定的决策性。</p><p>运用这种方法，可以对研究对象所处的情景进行 <code>全面、系统、准确</code>的研究，从而根据研究结果制定相应的 <code>发展战略、计划以及对策</code>等。</p><h3 id="筛选信息技术项目过程"><a href="#筛选信息技术项目过程" class="headerlink" title="筛选信息技术项目过程"></a>筛选信息技术项目过程</h3><ol><li><p>关注整个组织的需求</p><ol><li>项目越能符合整个组织的需求，其成功的概率就越大。</li><li>基于整个组织的需求选择项目的方法之一是：判断它们是否符合三个重要的标准：“ <code>需求、资金和意愿</code>”。</li></ol><p>注意：随着项目的推进，组织必须重新评估每个项目的这三个标准以决定项目是否继续或重新定义或是终止。</p></li><li><p>对IT项目进行分类</p><p>以各种分类方法为基础进行项目筛选</p><ol><li>评价项目是否可以 <code>解决某个问题</code>，或是抓住 <code>某种机会</code>，或迎合 <code>某个指示要求</code>；</li><li><code>基于时间</code> 的考虑筛选项目，可能是完成项目所需的工期时间，也可能是项目必须满足的截止日期；</li><li>将待选 <code>项目按高、中、低</code>三个次序进行整体综合排序，首先进行最重要的项目。</li></ol></li><li><p>进行财务分析：</p><ol><li>净现值（NPV）：是计算项目所产生的现金净流量，以资金成本为贴现率折现后与原始投资额现值的差额。</li><li>投资收益率（ROI）：投资回报率/投资回报(retum on investment , ROI) 是项目的收益减去成本后，再除以成本的结果</li><li>投资回收期：以现金流的方式，将在项目中的总投资全部收回的时间。</li></ol></li></ol><h3 id="项目章程"><a href="#项目章程" class="headerlink" title="项目章程"></a>项目章程</h3><p>项目章程是指一份正式确认项目存在的文件。它指明了项目的目标和管理的方向，授权项目经理利用组织的资源去完成项目。</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210621185624216.png" alt="项目章程示例" style="zoom:67%;"></p><p>项目管理计划是一个用来<code>协调</code> 所有其他计划，以 <code>指导项目执行和控制</code>的可操作的文件。</p><p>一个项目计划主要包括：<code>整体介绍、组织描述、管理程序、技术程序、任务范围、时间进度、经费预算</code> 等。</p><h3 id="集成变更控制"><a href="#集成变更控制" class="headerlink" title="集成变更控制"></a>集成变更控制</h3><p>集成变更控制( integrated change control) 涉及在整个项目的生命周期中<code>识别、估计和管理变更</code>。</p><p>目的：</p><ul><li>控制可能造成变更的因素，以确保变更都是有益的。</li><li>确认变更已经发生。</li><li>管理发生的变更。</li></ul><p>变更控制系统是一个<code>正式的、文档化的</code>过程。</p><p>变更控制系统三要素：</p><ol><li>建立变更控制组织</li><li>强化配置管理</li><li>及时进行沟通</li></ol><h2 id="项目范围管理"><a href="#项目范围管理" class="headerlink" title="项目范围管理"></a>项目范围管理</h2><h3 id="项目需求与范围管理的重要性"><a href="#项目需求与范围管理的重要性" class="headerlink" title="项目需求与范围管理的重要性"></a>项目需求与范围管理的重要性</h3><p>软件企业与IT项目应用企业信息化成功的基本保证是对项目范围的确切圈定，为此必须强调：</p><ul><li>三类人的获取<ul><li>需求专家</li><li>咨询专家</li><li>概要设计专家</li></ul></li><li>三要素的把握<ul><li>企业需求</li><li>管理理论</li><li>竞争压力</li></ul></li></ul><p>软件企业对三类人（需求专家、概要设计专家、咨询专家）的获取和培养，以及项目应用企业对项目范围三要素（企业需求、管理理论、竞争压力）的有效把握，是软件企业与IT项目应用企业信息化成功的 <code>基本保证</code>！</p><h3 id="项目范围管理相关概念"><a href="#项目范围管理相关概念" class="headerlink" title="项目范围管理相关概念"></a>项目范围管理相关概念</h3><p>范围是指开展项目产品所包括的所有工作及产生这些产品经过的所有过程。</p><p>项目范围是以其组成的所有产品范围定义为基础，但又不限于产品范围，还包括为实现这些产品范围内的工作必须要做的管理工作（进度管理等）</p><p>项目范围管理是指对项目包括什么与不包括什么的定义与控制过程。</p><blockquote><p>项目范围管理中的“范围”是指产品范围和项目范围两个概念的总和。</p></blockquote><p>项目范围管理的作用：</p><ul><li>为项目实施提供任务范围的框架</li><li>对项目的实施提供有效的控制</li><li>为项目最终交付提供依据</li></ul><p>项目范围管理的作用：保证了项目干系人对项目的结果以及产生结果的过程的共同理解；同时，也为项目的控制提供的依据。</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210621191222332.png" alt="项目范围管理的过程" style="zoom:50%;"></p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210621191311571.png" alt="项目范围管理的主要工作" style="zoom:50%;"></p><p>项目范围管理五阶段：</p><ol><li><p>范围规划</p><p>包括确定如何定义、验证并控制项目范围以及如何构建工作分解结构。</p><p>输出：项目范围管理计划 </p></li><li><p>范围定义</p><p>评审启动过程编制的项目章程和初步范围说明书，并随着需求的扩展及变更请求得到批准，在规划过程中增加更多的信息。<br>输出：项目范围说明、项目变更要求、项目范围管理计划的更新</p></li><li><p>工作结构分解</p><p>将主要的项目可交付成果分解成更小和更易管理的部分。<br>输出：WBS、WBS词典、范围基线、项目管更请求、项目范围说明书和项目管理计划的更新</p></li><li><p>范围验证</p><p>将项目范围的认可正式化。关键的利益相关者进行审查，然后正式接受项目的可交付成果。如果不接受会请求作出变更，并提出采取纠正措施的建议。<br>输出：接受的可交付成果、变更要求、建议的纠正措施</p></li><li><p>范围控制</p><p>对项目范围的变化进行控制。<br>输出：变更请求，建议的纠正措施，项目范围说明书，WBS及WBS词典、范围基线、项目管理几乎及组织过程资产的更新</p></li></ol><h3 id="工作分解结构"><a href="#工作分解结构" class="headerlink" title="工作分解结构"></a>工作分解结构</h3><p>工作分解结构（WBS）是一种以结果为导向的分析方法，用于分析项目所涉及到的工作，所有这些工作构成了项目的整个范围。</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210621192109784.png" alt="WBS的作用" style="zoom: 67%;"></p><p>WBS的特点：</p><ul><li>常用于建立或确立对项目范围达成共识</li><li>通常以图表的形式表示—树型图法、列表法、气泡法等</li><li>BS中的每一项元素通常被赋予唯一的标识</li><li>WBS的最低一层元素一般被称为工作包</li><li>WBS字典：描述WBS每项条目详细信息的文件，一般包含工作包的描述+其它计划信息：预期、工期、人员安排…….</li></ul><p>建立WBS的方法：</p><ul><li>类比法（WBS模板法）：选取相似项目的WBS作为参考</li><li>分解法（项目目标→项目产出物→可交付物→WBS）：从上至下、从下至上</li></ul><p>范围基线：项目范围说明书及相关的WBS、WBS词典构成，是实现项目范围目标的绩效的依据</p><h2 id="项目时间管理"><a href="#项目时间管理" class="headerlink" title="项目时间管理"></a>项目时间管理</h2><h3 id="项目进度计划的重要性"><a href="#项目进度计划的重要性" class="headerlink" title="项目进度计划的重要性"></a>项目进度计划的重要性</h3><p>项目计划 是指导项目实施和控制的一系列纲领性文件，是经高层管理批准的项目正式文档。</p><p>进度计划 是表达项目中各项工作（活动）的开展顺序、开始及完成时间及相互衔接关系的计划。进度计划是进度控制和管理的依据；同时引导项目其他类型的计划工作。</p><p>项目时间管理包括为确保项目按时完成所需要的各个过程。主要过程：活动定义、活动排序、活动资源估算、活动历时估算、项目进度计划编制、以及进度跟踪与控制过程。</p><p>活动或任务:是项目进行期间需要完成的工作单元，它们有预期的历时、成本和资源要求。</p><hr><p>分解用于活动定义时，最后结果是Activities；分解用于范围定义时，最后结果为Deliverables。</p><h3 id="活动排序"><a href="#活动排序" class="headerlink" title="活动排序"></a>活动排序</h3><p>依赖关系或关系反映了项目活动或任务的顺序。一个没有明确活动之间关系的项目是不可能成功的。</p><ul><li>强制依赖关系（硬逻辑关系）是项目工作固有的特性(行业逻辑）。</li><li>自由依赖关系（软逻辑关系）是由项目团队来定义的(是否签字）。</li><li>外部依赖关系 涉及项目与非项目活动之间的关系（操作系统供应商）。 </li></ul><p>活动排序的工具：</p><ul><li><p>箭线图法(ADM)-双代号网络(AOA)：用箭线表示活动，用节点表示活动间的相互依赖关系</p><ul><li><p>只使用一种活动之间的逻辑关系：FS</p></li><li><p>作图要求</p><p>每一个事件必须有唯一的事件号 </p><p>每一个活动用唯一的紧前事件和紧后事件描述</p><p>紧前事件编号要小于紧后事件编号</p></li><li><p>是唯一使用虚活动的活动排序工具。</p></li></ul><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210621223139031.png" alt="箭线图法——双代号网络例图" style="zoom: 50%;"></p><ul><li>虚线表示虚活动：<ul><li>虚活动没有历时，不需要资源</li><li>箭线图网络表示活动关系的需要</li><li>用带箭头的虚线表示</li></ul></li></ul></li><li><p>前导图法（PDM）— 单代号网络（AON）：一种使用<code>节点表示活动工作、箭线表示活动间依赖关系</code> 的项目网络图。这种网络图通常称为<code>单代号网络</code> （简称AON）,这种方法是大多数项目管理软件包所使用的方法。</p><ul><li>AON使用多种活动逻辑关系，其中FS关系用得最多</li><li>没有虚活动</li></ul><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210621223512069.png" alt="前导图法——单代号网络例图" style="zoom:50%;"></p><ul><li><p>四种依赖关系：</p><ul><li>完成—开始：“A”活动必须在“B”活动开始之前完成，图1</li><li>开始—开始：“A”活动只有在“B”活动开始的时候开始，图2</li><li>完成—完成： “A”活动必须在“B”活动完成之前完成，图3</li><li>开始—完成： “A”活动必须在“B”活动完成之前开始，图4</li></ul><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210621225530606.png" alt="图1                                图2                                 图3                         图4" style="zoom:50%;"></p><p>它对加强某种类型时间关系的可视性很有帮助。</p></li><li><p>PDM法的优点：</p><ol><li>大多数项目管理软件使用PDM法</li><li>PDM法避免了使用虚活动</li><li>PDM法反映了人物之间的各种依赖关系</li></ol></li></ul></li></ul><h3 id="进度安排"><a href="#进度安排" class="headerlink" title="进度安排"></a>进度安排</h3><p>制定进度计划的最终目标是：建立一个现实的项目进度计划，为监控项目的时间进展情况提供一个基础。</p><p>进度安排的的工具:</p><ul><li><p>甘特图：显示项目信息最常用的工具；</p></li><li><p>关键路径分析：也称为关键路径分析，是预测总体项目历时的网络分析技术，是帮助我们分析与解决进度拖延的一种重要工具。</p><ul><li>关键路径：是指一系列决定项目最早完成时间的活动。它是项目网络图中最长的路径，并且有最少的浮动时间或时差。 </li><li>关键路径法（CPM）：根据制定的网络顺序逻辑关系和单一历时估算，计算每一个活动的唯一、具体的最早和最迟开始及完成日期。其核心是计算浮动时间，确定哪些活动的进度安排灵活性最小。</li><li><p>步骤：</p><ul><li>绘制网络图 AON、AOA</li><li>确定项目的开始时间和结束时间</li><li>不考虑资源约束的条件下，计算项目的工期，包括：网络的关键路径、各个活动的自由浮动时间</li><li>计算资源需求计划</li></ul></li><li><p>特点：</p><ul><li>关键路径是最长的路径。</li><li>关键路径反映了项目所花费的最短的时间。</li><li>关键路径上的活动超时，总体进度就要拖延。</li><li>关键路径只与项目的时间有关与关键活动无关。</li><li>关键路径它与选择最短的路径无关。     </li><li>一个项目可能会有超过一条的关键路径。</li><li>一个项目的关键路径可能会发生变化。</li></ul></li><li><p>应用：</p><ul><li>利用关键路径分析平衡进度计划</li><li>缩短路径上的活动历时</li><li>关注与及时更新关键路径数据</li></ul><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210621230840151.png" alt="关键路径法示例" style="zoom:67%;"></p></li></ul></li><li><p>计划评审技术分析（PERT）：评价项目进度风险的一种手段。 </p><ul><li>PERT 是项目时间管理的另一项技术。</li><li>PERT将关键路径法应用于加权平均历时估算。</li><li>PERT 采用乐观的、最可能的、悲观的活动历时估计进行项目历时估计。</li><li>$PERT加权平均=\frac {乐观时间 + 4 \times 最可能的时间+ 悲观时间} {6}$</li></ul></li></ul><p>浮动时间：反映活动的机动性，是一个活动在不影响整个项目完成时间的情况下，可以延迟的时间量。因而，也称为最大的机动时间。   <code>TF＝LS－ES＝LF-EF</code></p><p>自由浮动时间：是指可以在不推迟任何后续活动最早开始时间的情况下，本活动可以推迟的时间。一般情况下，FF＜TF。自由浮动时间的计算方法为：<code>FF＝后续活动的ES－本活动的EF</code></p><h3 id="缩短项目工期的方法"><a href="#缩短项目工期的方法" class="headerlink" title="缩短项目工期的方法"></a>缩短项目工期的方法</h3><ul><li>在进度计划制订后，可能项目结束日期不满足要求，需要进一步缩短进度计划的项目工期。</li><li>可以采用赶工（Crashing,通过增加资源）或快速跟进（Fast tracking,通过并行施工）等方法。</li></ul><h2 id="项目成本管理"><a href="#项目成本管理" class="headerlink" title="项目成本管理"></a>项目成本管理</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>成本：伟大到一个特定的目标而花费或者用掉的资源</li><li>项目成本：实现项目目标所消耗资源而形成的费用</li><li>可变成本：随生产量或工作量而变。如物料、供应品、工资等。</li><li>固定成本：不随生产的变化而变化的非重复成本。如设备费、租赁费等。</li><li>直接成本：与生产项目和服务直接相关的成本。如差旅费、工资、项目使用的物料等。</li><li>间接成本：间接地和完成的项目相关。如税金、额外福利和保卫费用等。</li><li>无形成本：很难用货币来衡量的成本和收益。</li><li>有形成本：能够容易的用货币来衡量的那些价值。</li><li>沉没成本：在过去已经发生，在未来不可能取消的成本，应该像永远不能收回的沉船一样考虑它。</li><li>机会成本：如果选择另一项目放弃这一项目的收益所引发的成本。</li><li>学习曲线理论：当重复生产许多产品时，那些产品的单位成本随着数量的增多成规律性递减。学习曲线理论用来估计生产大量产品的项目之成本。</li><li>储备金是包含于成本估算中的、为减轻未来难以预测情形带来的成本风险而准备的那部分资金。</li><li>项目成本管理 包括为保障项目实际发生成本不超过项目预算而开展的项目成本估算、成本预算和成本控制等方面的管理活动。</li><li>项目成本管理的目的：确保项目在批准的预算内完成,实现项目价值最大化。</li><li>成本估算：对完成项目各活动项目所需人员、材料、设备等资源费用的近似值。</li></ul><h3 id="成本估算"><a href="#成本估算" class="headerlink" title="成本估算"></a>成本估算</h3><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210622135349354.png" alt="项目成本管理过程" style="zoom:50%;"></p><p>成本估算工具与技术：</p><ul><li>类比估算法：也叫自上而下估算法，它是使用以前的、相似项目的实际成本作为目前项目成本估算的根据，这是一种专家判断法，该方法较其他方法更节省，但不是很精确。</li><li>自下而上估计法：估算单个工作项和汇总单个工作项成整体项目，单个工作项的大小和估算人员的经验决定估算的精度。</li><li>参数模型估算法：是在数学模型中应用项目特征(参数)以估算项目成本。 </li><li>计算机化的工具：像电子数据表和项目管理软件等计算机化工具能够进行不同的成本估算，它是一种更容易的成本估算工具。  </li></ul><p>估算类型与主要输出</p><div class="table-container"><table><thead><tr><th>估算类型</th><th>何时做</th><th>为什么做</th><th>精确度如何</th></tr></thead><tbody><tr><td>粗略的量级估算</td><td>在项目生命周期中非常早，通常是在项目完成前3 — 5年</td><td>为项目选择决策提供成本估算</td><td>-25％— +75％</td></tr><tr><td>预算估算</td><td>早，项目完成前 1 — 2年</td><td>将资金拨入预算计划</td><td>-10％— +25％</td></tr><tr><td>最终估算</td><td>项目的后期，在项目完成前不足1年</td><td>为采购提供详情,估算实际成本</td><td>-5％— +10％</td></tr></tbody></table></div><h3 id="成本预算"><a href="#成本预算" class="headerlink" title="成本预算"></a>成本预算</h3><p>成本预算：项目成本预算是给每一项独立工作分配全部费用，以获得度量项目执行的费用基线。</p><p>两个要点：</p><ul><li>把成本估算分配到项目生命期中的每一个活动（或工作包）中。</li><li>建立成本控制基准线（ＢＣＷＳ或ＰＶ）－用来度量项目执行清况。</li></ul><p>成本预算的主要工作：</p><ul><li>确定项目的总预算</li><li>确定项目各项活动的预算</li><li>确定项目各项活动预算的投入时间</li><li>给出项目成本预算的“S”曲线</li></ul><p><strong>成本估算和预算的联系</strong></p><p>运用类比估算、参数模型、自下而上等工具和技术；都是以 WBS为基础的。</p><p><strong>成本估算和预算的区别</strong></p><p>估算成本：对完成项目活动所需资金进行近似估算；估算成本输出是成本估算，这种估算并未得到管理层的批准；成本估算的精确程序以工作包为基础；</p><p>制定预算：汇总所有单个活动或工作包的估算成本，建立一个经批准的成本基准；成本预算将基于工作包的成本估算分配到每项活动及相应时间段；成本预算输出的是成本基准计划即经过批准的成本预算。</p><h3 id="成本控制——挣值分析"><a href="#成本控制——挣值分析" class="headerlink" title="成本控制——挣值分析"></a>成本控制——挣值分析</h3><ol><li><p>挣值分析是项目管理领域中一个特有的、非常有效的成本控制工具。</p></li><li><p>挣值法实际上是一种分析目标实施与目标期望之间差异的方法。故而它又被称为偏差分析法。</p></li><li><p>挣值法通过测量和计算已完成的工作的预算费用和实际费用以及计划工作的预算费用得到计划实施的进度和费用的偏差，达到判断项目预算和进度计划执行情况。 </p></li><li><p>挣值方法是对项目范围、进度和成本进行综合控制的一种有效方法。它对于计划完成的工作、实际挣得的利益、实际花费的成本进行比较，以确定成本和进度是否按计划进行。</p></li><li><p>项目挣值：指已完成作业量的计划成本的中间变量。</p></li><li><p>挣值方法核心要素</p><ul><li>三个关键变量：PV、AC、EV</li><li>两个偏差：CV、SV</li><li>两个绩效指标：CPI、SPI</li></ul></li><li><p>挣值管理基本术语</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210622153612409.png" alt="挣值管理基本术语表" style="zoom:67%;"></p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210622154058038.png" alt="三个基本参数" style="zoom: 50%;"></p></li><li><p>挣值法的三个基本参数：</p><ol><li>计划工作量的预算成本(BCWS) ，即（Budgeted Cost for Work Scheduled) 。BCWS是指计划要求完成的工作量所需的预算工时/费用。<br>BCWS = 计划工作量 * 预算定额          PV</li><li>已完成工作的实际成本(ACWP) ，即（Actual  Cost for Work Performed)。 ACWP是指实际完成的工作量所消耗的工时/费用。      AC </li><li>已完成工作量的预算成本(BCWP) ，即（ Budgeted Cost for Work Performed)。BCWP是指实际完成的工作量按预算定额计算的工时/费用。<br>   BCWP =实际工作量 *预算定额       EV</li></ol></li><li><p>挣值法的四个评价指标</p><ol><li><p>两个偏差</p><ol><li><p>成本偏差(Cost Variance-CV) ：已完成工作的预算成本减去已完成工作的实际成本。CV是指检查期间EV与AC之间的差异，计算公式为：$CV= EV –AC$</p><p>当CV为负值时表示执行效果不佳，即实际消费人工(或费用)超过预算值即超支。反之当CV为正值时表示实际消耗人工(或费用)低于预算值，表示有节余或效率高。</p></li><li><p>进度偏差(Schedule Variance-SV)：已完成工作的预算成本减去计划工作的预算成本。<br>SV是指检查日期EV与PV之间的差异。其计算公式为：$SV= EV - PV $<br>当SV为正值时表示进度提前，SV为负值表示进度延误。</p></li></ol></li><li><p>成本执行指数：已完成工作的预算成本与已完成工作的实际成本的比值</p></li><li><p>两个绩效指标：</p><ol><li>费用绩效指标(Cost Performed Index-CPI)：CPI是指预算费用与实际费用值之比(或工时值之比)：$CPI=EV／AC$<br>当 CPI＞1表示低于预算C；PI＜1表示超出预算；CPI＝1表示实际费用与预算费用吻合</li><li>进度绩效指标(SPI －Schedule Performed Index/SCI)：SPI/SCI是指项目挣值与计划值之比，即 $SPI=EV／PV$<br>当 SPI＞1表示进度提前S；PI＜1表示进度延误S；PI＝1表示实际进度等于计划进度</li></ol></li></ol></li><li><p>| 序号 | 三参数关系                    | 分析                         | 措施                                   |<br>| —— | ——————————————- | —————————————— | ——————————————————— |<br>| 1    | ACWP&gt;BCWS&gt;BCWPSV &lt; 0  CV &lt; 0  | 效率低、进度较慢、投入超前   | 用工作效率高的人员更换工作效率低的人员 |<br>| 2    | BCWP&gt;BCWS&gt;ACWP SV &gt; 0  CV &gt; 0 | 效率高、进度较快、投入延后   | 若偏离不大，维持现状                   |<br>| 3    | BCWP&gt;ACWP&gt;BCWSSV &gt; 0  CV &gt; 0  | 效率较高、进度快、投入超前   | 抽出部分人员，放慢进度                 |<br>| 4    | ACWP&gt;BCWP&gt;BCWSSV &gt; 0  CV &lt; 0  | 效率较低、进度较快、投入超前 | 抽出部分人员，增加少量骨干人员         |<br>| 5    | BCWS&gt;ACWP&gt;BCWPSV &lt; 0  CV &lt; 0  | 效率较低、进度慢、投入延后   | 增加高效人员投入                       |<br>| 6    | BCWS&gt;BCWP&gt;ACWPSV &lt; 0  CV &gt; 0  | 效率较高、进度较慢、投入延后 | 迅速增加人员投入                       |</p></li></ol><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210622155213530.png" alt="例图" style="zoom:50%;"></p><h2 id="项目质量管理"><a href="#项目质量管理" class="headerlink" title="项目质量管理"></a>项目质量管理</h2><h3 id="软件质量"><a href="#软件质量" class="headerlink" title="软件质量"></a>软件质量</h3><ul><li><p>软件质量问题的严重性：软件质量不佳引发的事故已直接伤害到生命和社会安全。</p></li><li><p>软件质量问题的重要性：</p><ul><li>软件已深入到生活之中</li><li>软件越来越事关重大</li><li>人们对软件的期望与日俱增</li><li>软件出错的范围和可能越来越大</li><li>软件出错后没有第二次机会</li><li>合格且主动的进行质量控制的企业和员工太少</li><li>人们对软件的依赖性越来越大</li><li>软件质量问题带来的危害也越来越严重</li><li>软件产品质量正在牵动着社会的命脉</li></ul></li><li><p>质量的传统和新认识：</p><ul><li>传统：质量定义从产品延伸服务和过程时，质量是指产品、服务或过程各自对客户需求的适应性，即满足客户需求的能力。</li><li>新的认识：<ul><li>满意性质量 全面顾客满意</li></ul></li></ul></li><li><p>质量与等级：</p><ul><li>等级：相同功能用途，而技术参数不同的实体进行分类或排序。</li></ul></li><li><p>PMI定义：质量是满足双方一致同意的客户需求。</p></li><li><p>ISO定义：质量是反映实体满足明确和隐含需要的能力的特性总和。</p></li><li><p>质量管理：在质量方面指挥和控制组织的协调活动。</p></li><li><p>软件项目质量管理：是指软件企业为了使其软件产品质量能满足不断更新的市场与用户的质量要求而开展的策划、组织、计划、实施、控制、改进活动的总和。</p></li><li><p>软件质量：是将客户的隐性需求转换为明确需求,并且满足所有明确需求。</p></li><li><p>项目质量管理是指为满足项目质量目标要求所需要的管理过程；包括：质量计划 质量保证 质量控制</p></li><li><p>质量管理发展的四个阶段：</p><ul><li>传统质量管理阶段：以检验为基本内容，方式是严格把关。</li><li>统计质量控制阶段：以数理统计方法与质量管理相结合，通过对过程中影响因素的控制达到控制质量的目的。</li><li>全面质量管理阶段：以“三全为主要特征，即：管理对象是全面的、全过程的、全员的。</li><li>现代质量管理阶段：以顾客满意为中心，重视与企业职工、社会、交易伙伴、股东等顾客以外的利益相关者的关系。重视中长期预测与规划和经营管理层的领导能力。重视人及信息等经营资源，使组织充满自律、学习、速度、柔韧性和创造性。</li></ul><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210622185829346.png" alt="项目质量管理过程" style="zoom:50%;"></p></li><li><p>戴明改进质量管理</p><ul><li>高质量 —&gt; 高生产率，低成本</li><li>PDCA循环：计划、执行、检查、处理</li><li>四个特性：<ul><li>周而复始</li><li>大环带小环</li><li>阶梯式上升</li><li>统计的工具</li></ul></li></ul><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210622190150215.png" alt="PDCA循环图" style="zoom:50%;"></p></li></ul><div class="table-container"><table><thead><tr><th>阶 段</th><th>步 骤</th><th>备 注</th></tr></thead><tbody><tr><td>计划阶段</td><td>1.分析现状，找出问题3.找出造成问题的原因3.找出其中的主要原因4.针对主要原因，制定措施计划表</td><td>本阶段要明确六个问题，简称5W1H:.为何制定此计划？（WHY）.计划的目标是什么？（WHAT）.何处执行此计划？（WHERE）.何时执行此计划？（WHEN）.何人执行此计划？（WHO）.如何执行此计划？（HOW）</td></tr><tr><td>执行阶段</td><td>5.按措施计划执行</td><td></td></tr><tr><td>检查阶段</td><td>6.检查计划执行情况</td><td></td></tr><tr><td>处理阶段</td><td>7.对检查结果座标准化处理8.不能座标准化处理的，转入下一轮循环</td></tr></tbody></table></div><h3 id="质量规划"><a href="#质量规划" class="headerlink" title="质量规划"></a>质量规划</h3><ol><li>项目质量计划是指为确定项目应该达到的质量标准（项目质量的规定指标）和如何达到这些项目质量标准而做的项目质量的计划与安排工作。</li><li>项目质量计划编制方法（工具与技术）<ul><li>成本收益分析法</li><li>项目质量标杆法</li><li>项目质量图表法</li><li>项目实验设计法</li></ul></li></ol><h3 id="质量控制"><a href="#质量控制" class="headerlink" title="质量控制"></a>质量控制</h3><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210622190935964.png" alt="影响项目质量因素的控制"></p><p>质量控制的工具和方法：</p><ul><li><p>排列图：</p><ul><li><p>帕累托图（排列图）是“根据优先次序表达信息的一种图形，能够突出关键因素，以引起必要的关注”</p></li><li><p>步骤：</p><ol><li>将要处置的事，以状况（现象）或原因加以区别</li><li>纵轴可以表示件数，但最好以金额表示</li><li>决定搜集资料的期间，自何时至何时，作为帕拉图资料的依据。期间尽可能定期</li><li>各项目依照事件之大小顺位自左至右排列在横轴上</li><li>绘上柱状图</li><li>连接累计曲线  </li></ol></li><li><p>Pareto 图应用方法</p><ol><li>选择和确定用于分析问题的排列项目</li><li>选择用于分析的度量单位</li><li>选择用于分析的数据的时间周期</li><li>按度量单位的量值，以递减的顺序从左至右在横坐标上列出排列项目、</li><li>在横坐标两端画两个纵坐标</li><li>在每个项目上画长方形，表示该项目的量值</li><li>自左向右累加每一项的量值，画累计频数线</li><li>图形分析</li></ol></li><li><p>Pareto 图的作用</p><ol><li>为决定改善目标而使用</li><li>确认改善效果时使用</li><li>调查不良原因及故障原因时使用</li><li>对整理报告和记录时有帮助</li></ol></li></ul><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210622191351492.png" alt="排列图示例" style="zoom:67%;"></p></li><li><p><code>控制图</code> </p><ul><li><p>用来确认项目过程和结果是否处于受控状态用来确认项目过程和结果是否处于受控状态</p></li><li><p>控制图实施程序：</p><ol><li>定时定量随机抽取样本</li><li>抽取样本做特性的测量</li><li>将结果绘制于控制图上</li><li>判别有无工程异常或偶发性事件</li><li>对偶发性事故或工程异常采取措施<ol><li>找寻原因</li><li>改善对策、应急对策</li><li>防止再发根本对策</li></ol></li></ol><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210622191949334.png" alt="控制图实施程序" style="zoom: 67%;"></p></li></ul><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210622191808877.png" alt="控制图例图" style="zoom:50%;"></p></li><li><p>因果图</p><ul><li>因果图揭示造成问题的多种原因与结果之间的关系<ul><li>一种有创意的方法来揭示问题的原因或其潜在原因</li><li>鼓励组织内部的思考和讨论</li></ul></li></ul><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210622192125715.png" alt="因果图" style="zoom:67%;"></p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210622192213785.png" alt="因果图示例" style="zoom: 67%;"></p></li><li><p>关联图</p><ul><li>用于原因—结果关系分析</li><li>分析复杂因素交织在一起的问题</li><li>抓住关键问题</li><li>便于成员取得一致意见</li></ul><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210622192555700.png" alt="关联图示例"></p></li><li><p><code>散布图</code> </p><ul><li>散点图（Scatter Plot or Scatter Chart)，也叫散布图，顾名思义就是由一些散乱的点组成的图表，这些点在哪个位置，是由其X值和Y值确定的。所以也叫做XY散点图。它将所有的数据以点的形式展现在直角坐标系上，以显示变量之间的相互影响程度，点的位置由变量的数值决定。</li><li>可以显示两个变量之间是否有关系。一条斜线上的数据点距离越近，两个变量之间的相关性就越密切。</li></ul><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210622192710413.png" alt="散点图示例"></p></li><li><p><code>6西格玛（$6 \sigma$）</code></p><ul><li><p>理解$6 \sigma$</p><ul><li>6σ是一种哲理，它运用结构化的，系统化的方法来表达几乎零缺陷的优异营运结果。</li><li>6σ是管理系统，可将对公司影响最大的问题和机会，交给最优秀的人，通过专案团队的运作方式获得突破性的成果。当然，管理层要给予适时的支援，同时允诺协助其排除障碍。</li><li>6σ是一个积极的目标，从长期目标而言，每百万产品或服务或工作，只有3.4个瑕疵，当然，短期要追求零缺陷的完美表现。</li><li>6σ是一系列的工具组，在不同的阶段有不同的工具可应用（关于工具的使用，有很多软件可以辅助）。</li><li>6σ是以顾客为尊，是一种聚焦于顾客的策略性工具，不是倾听顾客的声音，满足顾客的要求。还要让顾客获到惊喜。</li></ul></li><li><p>三个目的</p><ul><li><p>为了彻底解决现有问题</p><p>企业现有的服务或产品质量水准不高，成本不具竞争力，周期较长，流程效能或效率不佳，缺乏弹性与应变能力，个人或整体生产力未达理想等。这部分约占总体的70%左右。</p></li><li><p>希望通过6σ系统能有效地执行企业策略，以进一步提升获利能力，降低营运风险，快速回应市场与客户需求，增强产品或服务之附加价值，提升市场占有率，以及强化公司整体竞争力与顾客满意度。这部分约占总体的20%左右。</p></li><li><p>由6σ系统成功以改变企业变化，包括建立共通语言（面对问题的思考逻辑与解决式）与世界级企业同步，建立愿景共识，增强员工同心力；构建企业知识库，提升顾客忠诚度，追求企业公民的社会价值及典范。</p></li></ul></li><li><p>$6 \sigma$核心方法论——DMAIC</p><p>6σ管理着重<code>从流程的角度来看待企业绩效和改进绩效</code> ，当然，对流程的描述和管理就成为改进提高的基础。建立企业的核心流程及鉴别，顾客是企业改进的第一步。</p><p>所有的流程系统都是5部分组成的：供应商、输入、加工、输出、顾客。</p></li></ul></li><li><p>测试：</p><ul><li>广义上：软件测试是对软件需求分析、设计说明和编码进行复审等的软件质量保证工作。</li><li>狭义上：软件测试是根据软件开发各个阶段的规格说明和程序的内部结构而精心设计的一些测试用例，并利用这些测试用例去运行程序，发现错误。</li><li>根本目的：一是发现错误；二是通过测试的错误来改进软件开发过程中存在的缺陷。</li><li>测试原则</li><li>软件测试应尽早执行。<ul><li>开发和测试小组分立。</li><li>测试用例应由测试输入数据和预期输出结果这两部分组成，要兼顾有效输入与无效输入。</li><li>在对程序修改之后，要进行回归测试。</li><li>妥善保存测试计划、测试用例、出错统计和最终分析报告，为维护提供方便。</li></ul></li></ul></li></ul><h3 id="提升项目质量的方法"><a href="#提升项目质量的方法" class="headerlink" title="提升项目质量的方法"></a>提升项目质量的方法</h3><p>IT项目质量提高空间非常大，包括强有力的领导、提供好的工作环境、选用具体的规范、标准、模型都是提高项目质量的有效方法。  </p><h2 id="项目人力资源管理"><a href="#项目人力资源管理" class="headerlink" title="项目人力资源管理"></a>项目人力资源管理</h2><ul><li><p>人力资源的含义：人类可用于生产产品或提供各种服务的活力、技能、知识和可提供的商誉价值。</p></li><li><p>人力资源具有的特征：</p><ul><li>可再生的生物性资源：它以人身为天然载体，是一种“活”的资源，并与人的自然生理特征相联系。</li><li>居于主导地位的动能性资源：人类不同于自然界其他生物之处在于人具有目的性、主观能动性和社会意识。</li><li>具有时效性的资源：人力资源的形成、开发、使用都具有时间方面的制约。</li></ul></li><li><p>项目人力资源管理可以定义为根据项目目标，采用科学的方法，对项目组织成员进行合理的选拔、培训、考核、激励，使其融合到组织之中，并充分发挥其潜能，从而保证高效实现项目目标的过程。</p></li><li><p>项目人力资源管理是通过不断的获得人力资源，把得到的人力整合到项目中并融为一体，保持和激励他们对项目的忠诚和积极性，控制他们的工作绩效并作出相应的调整，尽量发挥他们的潜能，以支持项目目标的实现，这样的一些活动、职能、责任和过程叫项目人力资源管理。</p></li><li><p>管理员工的关键所在：</p><ul><li><p>激励理论</p><ul><li><p>内在动机：驱使人们为满足自身的乐趣而参与某项活动。</p></li><li><p>外在动机：驱使人们为获得利益或者避免惩罚而参加一些活动。</p></li><li><p>马斯洛的需求层次理论：</p><ul><li>人类的行为是由一系列的需求引起或者驱动的。</li><li>认为最独特的性质是：爱、自尊、归属感、自我表现以及创造力。这些独一无二的性质使人们做出独立的选择，从而使他们能自己掌握自己的命运。</li></ul><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210622204036446.png" alt="马斯洛的需求层次" style="zoom:67%;"></p></li><li><p>赫茨伯格的双因素理论：</p><ul><li>在考虑工作激励时区别了激励因素和保健因素，把影响工作满意的因素称为激励因素，把导致不满的因素称为保健因素。</li><li>他发现人们工作的主要激励因素来自于个人成绩表现以及由此获得的认可度。赫茨伯格总结出激励因素包括工作成就、认可度、工作本身、责任、晋升和发展。</li></ul><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210622204234952.png" alt="赫茨伯格的双因素理论" style="zoom: 67%;"></p></li></ul></li><li><p>权利理论</p><ul><li>权力的5种主要类型：强制权力、合法权力、专家权力、奖励权力、参照权力。</li></ul></li><li><p>习惯</p></li></ul></li></ul><h3 id="项目人力资源管理过程"><a href="#项目人力资源管理过程" class="headerlink" title="项目人力资源管理过程"></a>项目人力资源管理过程</h3><ul><li>人力资源规划<ul><li>识别和记录项目角色、责任和汇报关系。</li><li>关键输出是：项目的角色和责任、项目的组织结构以及人员配置管理计划。</li></ul></li><li>组建项目团队<ul><li>分派好项目所需要的各种人员，让其为项目工作。</li><li>关键输出是：项目人员的分派、了解资源的可用性信息和人员配置管理计划的更新。</li></ul></li><li>建设项目团队<ul><li>通过培训个人与团队的技能来改善项目绩效。</li><li>输出是：评估团队绩效。</li></ul></li><li>管理项目团队<ul><li>通过追踪团队成员的表现、激励团队成员、及时提供反馈、解决问题和矛盾、协调变化等来提高项目绩效。</li><li>输出是：变更申请、建议的修正和预防措施、组织过程资产和项目管理计划的更新。</li></ul></li></ul><h3 id="人力资源规划"><a href="#人力资源规划" class="headerlink" title="人力资源规划"></a>人力资源规划</h3><ul><li>人力资源规划包括识别和记录项目角色、责任和汇报关系。产生项目的组织结构图和人员配置管理计划，以及在责任分配矩阵中明确各人的角色和责任。</li><li>责任分配矩阵：用矩阵表格形式表示工作分解结构中的细目，以及组织分解结构的工作绩效对应的个人责任。</li></ul><h3 id="组件项目团队"><a href="#组件项目团队" class="headerlink" title="组件项目团队"></a>组件项目团队</h3><ul><li>主要途径：<ul><li>人员预先指派：项目竞标时，已保证部分特定人员会投入项目；内部项目发起时，项目章程已明确部分成员。</li><li>谈判：将所需成员从原来的工作岗位抽调到项目中，需要项目经理同职能经理谈判，同其它项目经理谈判。</li><li>虚拟团队：不同于集中办公的方式，是地理位置离散、组织边界宽泛。</li></ul></li><li>项目经理有两种方法来最有效地使用项目人员： <ul><li>资源负荷：是指在特定时段现有进度计划所需的个体资源的数量。</li><li>资源平衡：是一种用来解决资源冲突的工具(主要通过改变进度，超负荷-延，否则-加快进度)，其主要目的是更合理地分配使用的资源。</li></ul></li></ul><h3 id="开发项目团队"><a href="#开发项目团队" class="headerlink" title="开发项目团队"></a>开发项目团队</h3><ul><li><p>定义：层次合理、分工明确、任务清晰、责任到位，能将有限资源最有效的整合的机构—团队。 </p></li><li><p>目标：团队开发的主要目标就是帮助人们更有效地一起工作来提高项目绩效。</p></li><li><p>团队发展五个阶段：</p><ul><li><p>形成阶段：团队酝酿，形成测试。 测试的目的是为了辨识团队的人际边界以及任务边界。 通过测试，建立起团队成员的相互关系、团队成员与团队领导之间的关系，以及各项团队标准等。团队成员行为具有相当大的独立性。  </p><p>指导性领导</p></li><li><p>震荡阶段：形成各种观念，激烈竞争、碰撞的局面。团队获取团队发展的信心，但是存在人际冲突、分化的问题。团队成员面对其他成员的观点、见解，更想要展现个人性格特征。 对于团队目标、期望、角色以及责任的不满和挫折感被表露出来。</p><p>影响性领导</p></li><li><p>规范阶段：规则，价值，行为，方法，工具均已建立。团队效能提高，团队开始形成自己的身份识别。团队成员调适自己的行为，以使得团队发展更加自然、流畅。 有意识地解决问题，实现组织和谐。 动机水平增加。团队领导允许团队有更大的自治性。 </p><p>参与式领导。</p></li><li><p>项目成熟阶段： 人际结构成为执行任务活动的工具， 团队角色更为灵活和功能化，团队能量积聚于一体。项目团队运作如一个整体。 工作顺利、高效完成，没有任何冲突，不需要外部监督。团队成员对于任务层面的工作职责有清晰的理解。 没有监督，自治，即便在没有监督的情况下自己也能做出决策。 随处可见“我能做”的积极工作态度。 互助协作。<br>项目领导让团队自己执行必要的决策。 委任式领导。</p></li><li><p>项目解散阶段：任务完成，团队解散。</p></li></ul></li><li><p>建设团队的工具和方法</p><ul><li>团队建设活动</li><li>一般管理技术</li><li>绩效考评与奖励系统</li><li>人员配置</li><li>培训</li></ul></li></ul><h3 id="管理项目团队"><a href="#管理项目团队" class="headerlink" title="管理项目团队"></a>管理项目团队</h3><ul><li>管理项目团队的工具和方法：<ul><li>观察和交谈</li><li>项目绩效评价</li><li>冲突管理</li><li>问题日志</li></ul></li><li>项目冲突解决方法<ul><li>回避或撤出</li><li>竞争或逼迫</li><li>缓和或调停</li><li>妥协</li><li>正视</li></ul></li></ul><h2 id="项目沟通管理"><a href="#项目沟通管理" class="headerlink" title="项目沟通管理"></a>项目沟通管理</h2><h3 id="项目沟通管理的重要性"><a href="#项目沟通管理的重要性" class="headerlink" title="项目沟通管理的重要性"></a>项目沟通管理的重要性</h3><ul><li>项目成功的三个主要因素<ul><li>用户参与</li><li>主管层的支持</li><li>需求的清晰表述</li></ul></li><li>项目沟通管理的目标：及时而适当地创建、收集、发送、储存和处理项目的信息。</li></ul><h3 id="项目沟通管理的过程"><a href="#项目沟通管理的过程" class="headerlink" title="项目沟通管理的过程"></a>项目沟通管理的过程</h3><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210622210326761.png" alt="项目沟通管理的过程" style="zoom:67%;"></p><h3 id="沟通计划"><a href="#沟通计划" class="headerlink" title="沟通计划"></a>沟通计划</h3><p>内容</p><ol><li>描述信息收集和文件归档的结构。 </li><li>描述什么信息送给谁、何时送、如何送。</li><li>传送重要项目信息的格式。 </li><li>用于创建信息的日程表。 </li><li>获得信息的方法。</li><li>更新沟通管理计划的方法。</li><li>项目干系人沟通分析。</li></ol><h3 id="信息发布"><a href="#信息发布" class="headerlink" title="信息发布"></a>信息发布</h3><p><code>沟通复杂性的确定</code>：</p><ul><li>人数：<img src="https://gitee.com/sehowyoung/images/raw/master/image-20210622210624261.png" alt="人员数目对沟通渠道的影响 " style="zoom:67%;"></li><li>公式：<ul><li>沟通渠道数目计算公式：$S=\frac {n \times(n-1)} {2}$<ul><li>S：沟通渠道数目</li><li>n：参加沟通的人员个数</li></ul></li></ul></li></ul><h3 id="绩效报告"><a href="#绩效报告" class="headerlink" title="绩效报告"></a>绩效报告</h3><ul><li>作用：绩效报告使项目干系人知晓为了达到项目的目标，是如何使用资源的，这些资源的状况和对项目的贡献。</li><li>内容：项目计划和工作成果是绩效报告输入的重要内容，绩效报告的主要输出包括<code>状态报告、进度报告、项目预测和变更请求</code>。<ul><li>状态报告：项目在某一特定时间点上所处的位置。</li><li>进展报告：项目组在某一特定期间所完成的工作。</li><li>项目预测：预测项目未来的状态和进度。</li><li>变更请求：项目变更的原因，对项目目标和资源的影响，采取的措施。 </li></ul></li></ul><h3 id="管理收尾"><a href="#管理收尾" class="headerlink" title="管理收尾"></a>管理收尾</h3><p>管理收尾的主要输出是<code>项目档案、正式接受和取得的教训</code>。</p><ul><li>项目档案包括一套整理好的项目记录，提供了一个项目准确的历史。</li><li>正式接受是项目发起人或客户签发的表明他们接受项目产品的文件。</li><li>取得的教训是项目经理和他们的项目组成员经过思考写下的经验总结。</li></ul><h3 id="改善沟通的建议"><a href="#改善沟通的建议" class="headerlink" title="改善沟通的建议"></a>改善沟通的建议</h3><ol><li>利用沟通技能解决冲突——沟通调整 <ol><li>面对：直接面对冲突，允许受到影响的各方一起沟通，以消除他们之间的分歧。</li><li>妥协：各方讨价还价、使冲突各方都能满意，达到双赢/多赢。</li><li>圆滑：项目经理不再强调或避免分歧的领域，强调一致的领域。</li><li>强制：采用非输即赢的方法来解决冲突。</li><li>撤退：从一个实际的或可能的不同意见中撤退或让步。</li></ol></li><li>学习——发展更好的沟通技能 </li><li>召开有效的会议</li><li>使用项目沟通模板</li><li>建立沟通基础结构</li><li>利用软件辅助沟通</li></ol><h2 id="项目风险管理"><a href="#项目风险管理" class="headerlink" title="项目风险管理"></a>项目风险管理</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li>风险:是可能给项目的成功带来威胁或损害的可能性。</li><li>PMI的定义：项目风险是一种不确定的事件或条件，一旦发生，将对项目目标产生某种正面或负面影响。</li><li>项目风险管理是对项目风险进行识别、评估和应对的系统的过程。它包括把对于项目目标而言正面事件的概率和影响结果最大化和把负面事件的概率和影响最小化。</li><li>项目风险管理的特点：<ul><li>活动:项目风险管理是为减轻潜在的不利事件对项目的影响而采取的一项活动。</li><li>成本：风险管理是一种投资，需要成本。</li><li>成本和收益：在任何情况下，项目风险管理的成本不应超过项目潜在的收益。</li><li>平衡：需要努力在项目的各个方面寻找风险和机会之间的平衡。</li><li>风险管理是科学与艺术的结合体 </li></ul></li><li>目标：<ul><li>项目风险管理通过<code>识别、分析和应对</code>整个项目生命周期中的<code>风险</code>来最大程度地满足项目目标。</li><li>作为在项目管理中常被忽视的一个方面，其对项目的<code>最终成功起到极大的促进作用</code>。</li><li>对项目选择、项目范围的制定、制定现实可行的进度和成本估计都有<code>积极作用</code>。</li><li>可以帮助利益相关者更好理解项目的性质，让团队成员参与<code>辨识优势和劣势</code>，并有助于把其他项目管理知识结合到一起。 </li></ul></li><li>风险承受度<ul><li>风险承受度:是从潜在回报中得到满足或快乐的程度。</li><li>表现形式：一些组织或个人对风险有一种中性的承受度，一些对风险很厌恶，而另一些则追求风险。 </li><li>风险效用或者风险容忍度：指在潜在的权衡中得到满足或者愉悦的程度。</li></ul></li></ul><h3 id="项目风险管理的过程"><a href="#项目风险管理的过程" class="headerlink" title="项目风险管理的过程"></a>项目风险管理的过程</h3><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210622212237566.png" alt="项目风险管理过程" style="zoom: 67%;"></p><p>四个应对风险的基本措施是：</p><ul><li>规避：根除某一具体的威胁或风险。</li><li>接受：如果风险发生，接受其带来的后果。</li><li>减轻：将风险结果用责任转移给第三方。</li><li>转移：通过减少风险事件发生的概率来减轻风险事件的影响。  </li></ul><h2 id="项目采购管理"><a href="#项目采购管理" class="headerlink" title="项目采购管理"></a>项目采购管理</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><ul><li><p>项目采购：通过减少风险事件发生的概率来减轻风险事件的影响。  </p></li><li><p>项目采购管理：是对整个项目采购活动所进行的计划、组织、指挥、协调、控制等一系列活动，是一项管理活动。</p></li><li><p>项目采购特点：目标的唯一性，临时的一次性，逐渐完善的周期性</p></li><li><p>项目采购管理的重要性</p><ul><li><p>确保采购经济有效。（成本）</p></li><li><p>有助于掌握市场变化趋势。 </p></li><li><p>保证项目按计划实施。 </p></li><li><p>从制度上最大限度地防止腐败现象的发生。 </p></li></ul></li><li><p>项目采购管理目标：是以最低的成本及时地为项目提供满足其需要的物料、工程和服务。—T、Q、C</p></li></ul><h3 id="项目采购管理的主要过程"><a href="#项目采购管理的主要过程" class="headerlink" title="项目采购管理的主要过程"></a>项目采购管理的主要过程</h3><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210622212836651.png" alt="项目采购管理的主要过程" style="zoom:67%;"></p><h3 id="工具和技术"><a href="#工具和技术" class="headerlink" title="工具和技术"></a>工具和技术</h3><ol><li>自制或外购分析（成本平衡点分析法）</li><li>短期租赁或长期租赁权衡</li><li>专家判断：聘请一些有经验的采购专家作为顾问或邀请他们直接参加采购过程。</li><li>合同类型权衡<ol><li>固定价合同或固定总价合同</li><li>成本补偿合同</li><li>单价合同</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 资料总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSU </tag>
            
            <tag> 软件项目组织管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在gitee和GitHub中查看原始数据</title>
      <link href="/posts/30410.html"/>
      <url>/posts/30410.html</url>
      
        <content type="html"><![CDATA[<h1 id="在gitee和GitHub中查看原始数据"><a href="#在gitee和GitHub中查看原始数据" class="headerlink" title="在gitee和GitHub中查看原始数据"></a>在gitee和GitHub中查看原始数据</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>总是在别人分享的链接中看到以“raw.githubusercontent.com”为域名，便想了解一下，本文将介绍一下在gitee和GitHub中查看原始数据。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><code>raw.githubusercontent.com</code>域用于提供存储在GitHub存储库中的文件的未处理版本。如果您浏览到GitHub上的文件，然后单击Raw链接，那么您将到达。</p><h2 id="GitHub中查看"><a href="#GitHub中查看" class="headerlink" title="GitHub中查看"></a>GitHub中查看</h2><p>在<a href="github.com">GitHub</a>的官网中随便找一个仓库，随便打开里面的一个文件，我们会发现在代码模块上面有一个<code>Row</code>按钮（如图一），点击按钮之后就可以在网页中直接查看原始数据（如图二）。</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210615142224706.png" alt="图一"></p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210615142436770.png" alt="图二"></p><p>我们仔细观察一下这两个网页的URL：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># github文件https://github.com/sehowyoung/sehowyoung.github.io/blob/master/index.html# 原始数据文件https://raw.githubusercontent.com/sehowyoung/sehowyoung.github.io/master/index.html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以发现原始数据文件和GitHub文件的差异就在：</p><ul><li>域名</li><li><code>/blob/</code></li></ul><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>要在通常的github界面中查看<code>raw.githubusercontent.com/${username}/${repo-name}/${branch-name}/${path}</code>的内容：您将<code>raw.githubusercontent.com</code>替换为普通的<code>github.com</code>，然后在仓库名称和分支名称之间插入<code>blob/</code>即可。</p><p>在这种情况下，分支名称为<code>master</code>(这是一个非常常见的分支名称)，因此您将<code>/master/</code>替换为<code>/blob/master/</code>即可。</p><p>相反，如果你知道一个GitHub文件的链接，想直接查看或直接引用，将<code>github.com</code>换成<code>raw.githubusercontent.com</code>，同时删除<code>blob/</code>即可直接查看。</p><h2 id="gitee中查看原始数据"><a href="#gitee中查看原始数据" class="headerlink" title="gitee中查看原始数据"></a>gitee中查看原始数据</h2><p>在了解完GitHub查看原始数据之后，我总是在想gitee会不会有类似的操作，果不其然。</p><p>同样，打开gitee仓库的任意一个文件（如图二），发现就有<code>原始数据</code>这个按钮，直接点击就可以查看原始数据（如图四）。</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210615143445564.png" alt="图三"></p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210615143613405.png" alt="图四"></p><p>我们来分析一下二者的URL：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># gitee文件https://gitee.com/sehowyoung/Sort/blob/main/java/src/sort/Insertion.java# 原始数据文件https://gitee.com/sehowyoung/Sort/raw/main/java/src/sort/Insertion.java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这个想必GitHub就简单许多了，只是把<code>blob</code>换成<code>raw</code>即可。通过这样的切换，我们就可以直接查看、引用文件数据。</p><h3 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h3><p>要在通常的gitee界面中查看<code>gitee.com/${username}/${repo-name}/${branch-name}/${path}</code>的内容：您需要在仓库名称和分支名称之间插入<code>blob/</code>即可。</p><p>在这种情况下，分支名称为<code>master</code>(这是一个非常常见的分支名称)，因此您将<code>/master/</code>替换为<code>/blob/master/</code>即可。</p><p>相反，如果你知道一个gitee文件的链接，想直接查看或直接引用，删除<code>blob/</code>即可直接查看。</p>]]></content>
      
      
      <categories>
          
          <category> 常识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> 原始数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪心算法学习笔记</title>
      <link href="/posts/32604.html"/>
      <url>/posts/32604.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>贪心法：遵循某种规律，不断<strong>贪心</strong>的选取当前<strong>最优</strong>策略的算法设计方法。</p></blockquote><h2 id="引例"><a href="#引例" class="headerlink" title="引例"></a>引例</h2><p>有1元、5元、10元、20元、100元、200元的钞票无穷多张。现使用这些钞票支付ⅹ元，<strong>最少</strong>需要多少张？<br>例如,X=628<br>最佳支付方法：<br>3张200块的,1张20块的,1张5块的,3张1块的<br>共需要3+1+1+3=8张<br>直觉告诉我们：<strong>尽可能多</strong>的使用<strong>面值较大</strong>的钞票</p><p>那么为何这么做一定是对的?<br>面额为1元、5元、10元、20元、100元、200元，任意面额是比自己小的面额的倍数关系，所以当使用一张较大面额钞票时，若用较小面额钞票替换，一定需要更多的其他面额的钞票。<br>例如：<br>5=1+1+1+1+1<br>10=5+5<br>20=10+10<br>100=20+20+20+20+20<br>200=100+100<br>故,<strong>当前最优解</strong>即为<strong>全局最优解</strong>,贪心成立</p><blockquote><p>思考：如果增加7元面额，贪心还成立吗?</p></blockquote><h2 id="例1：分发饼干"><a href="#例1：分发饼干" class="headerlink" title="例1：分发饼干"></a>例1：分发饼干</h2><blockquote><p>来源：<a href="https://leetcode-cn.com/problems/assign-cookies/">LeetCode 455.分发饼干</a></p><p>题目描述：</p><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p><p>对每个孩子 <code>i</code>，都有一个胃口值 <code>g[i]</code><sub>，</sub>这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 <code>j</code>，都有一个尺寸 <code>s[j]</code><sub> </sub>。如果 <code>s[j] &gt;= g[i]</code>，我们可以将这个饼干 <code>j</code> 分配给孩子 <code>i</code> ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><p><strong>示例 1:</strong></p><pre class="line-numbers language-none"><code class="language-none">输入: g = [1,2,3], s = [1,1]输出: 1解释:你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。所以你应该输出1。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入: g = [1,2], s = [1,2,3]输出: 2解释:你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。你拥有的饼干数量和尺寸都足以让所有孩子满足。所以你应该输出2.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示：</strong></p><ul><li>1 &lt;= g.length &lt;= 3 * 10^4^</li><li>0 &lt;= s.length &lt;= 3 * 10^4^</li><li>1 &lt;= g[i], s[j] &lt;= 2^31^ - 1</li></ul></blockquote><p><strong>核心目标：</strong>让更多孩子得到满足,有如下规律:</p><ol><li>某个饼干如果不能满足某个孩子,则该饼干也一定不能满足需求因子更大的孩子。<br>如：饼干1(s=1)不能满足孩子1(g=2)，则不能满足孩子2、孩子3、…、孩子n<pre><code>   饼干2(s=3)不能满足孩子2(g=5)，则不能满足孩子3、孩子4、...、孩子n</code></pre></li><li>某个孩子可以用更小的饼干满足，则没必要用更大饼干满足，因为可以保留更大的饼干满足需求因子更大的孩子。(贪心!)<br>如：孩子1(g=2)，可以被饼干2(s=3)满足，则没必要用饼干3、饼干4、饼干5满足；<pre><code>   孩子2(g=5)，可以被饼干3(s=6)满足，则没必要用饼干4、饼干5满足</code></pre></li><li>孩子的需求因子更小则其更容易被满足，故优先从需求因子小的孩子尝试，可以得到确的结果。因为我们追求更多的孩子被满足，所以用一个饼干满足需求因子较小的或较大的孩子<br>都是一样的)。</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Arrays;public class Solution {    public int findContentChildren(int[] g, int[] s) {        Arrays.sort(g);        Arrays.sort(s);        int index_g = 0;        int index_s = 0;        while ((index_g &lt; g.length) &amp;&amp; (index_s &lt; s.length)){            if (s[index_s] &gt;= g[index_g]){                index_g++;            }            index_s++;        }        return index_g;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="例2：摆动序列"><a href="#例2：摆动序列" class="headerlink" title="例2：摆动序列"></a>例2：摆动序列</h2><blockquote><p>来源：<a href="https://leetcode-cn.com/problems/wiggle-subsequence/">376. 摆动序列</a></p><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 <strong>摆动序列 。</strong>第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。</p><ul><li>例如， <code>[1, 7, 4, 9, 2, 5]</code> 是一个 <strong>摆动序列</strong> ，因为差值 <code>(6, -3, 5, -7, 3)</code> 是正负交替出现的。</li><li>相反，<code>[1, 4, 7, 2, 5]</code> 和 <code>[1, 7, 4, 5, 5]</code> 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</li></ul><p><strong>子序列</strong> 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。</p><p>给你一个整数数组 <code>nums</code> ，返回 <code>nums</code> 中作为 <strong>摆动序列</strong> 的 <strong>最长子序列的长度</strong> 。</p><p><strong>示例 1：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：nums = [1,7,4,9,2,5]输出：6解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>示例 2：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：nums = [1,17,5,10,13,15,10,5,16,8]输出：7解释：这个序列包含几个长度为 7 摆动序列。其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例 3：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：nums = [1,2,3,4,5,6,7,8,9]输出：2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>0 &lt;= nums[i] &lt;= 1000</code></li></ul></blockquote><p><strong>贪心规律：</strong></p><p>当序列有一段连续的递增(或递减)时，为形成摇摆子序列，我们只需要保留这段连续的递增(或递减)的首尾元素，这样更可能使得尾部的后一个元素成为摇摆子序列的下一个元素。</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210613123353118.png" alt="image-20210613123353118"></p><p><strong>算法设计：</strong></p><p>设置最长摇摆子序列长度为 max length，从头至尾扫描原始序列。这个过程中设置三种状态，即起始、上升、下降；不同的状态中,根据当前数字与前一个数字的比较结果进行累加 max length计算或者状态切换。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git学习笔记</title>
      <link href="/posts/14696.html"/>
      <url>/posts/14696.html</url>
      
        <content type="html"><![CDATA[<h1 id="Git学习笔记"><a href="#Git学习笔记" class="headerlink" title="Git学习笔记"></a>Git学习笔记</h1><h2 id="Git概述"><a href="#Git概述" class="headerlink" title="Git概述"></a>Git概述</h2><p>git官网：<a href="https://git-scm.com/">https://git-scm.com/</a></p><blockquote><p>Git 是一个<a href="https://git-scm.com/about/free-and-open-source">免费的开源</a> 分布式版本控制系统，旨在快速高效地处理从小到大的所有项目。</p><p>Git<a href="https://git-scm.com/doc">易于学习</a>， <a href="https://git-scm.com/about/small-and-fast">占用空间小，性能极快</a>。它的性能优于 Subversion、CVS、Perforce 和 ClearCase 等 SCM 工具，具有<a href="https://git-scm.com/about/branching-and-merging">便宜的本地分支</a>、方便的<a href="https://git-scm.com/about/staging-area">暂存区</a>和 <a href="https://git-scm.com/about/distributed">多个工作流等功能</a>。</p></blockquote><h3 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h3><ul><li>版本控制是一种记录文件内容变化，一边将来查阅特定版本修订情况的系统。</li><li>版本控制其实最重要的是可以记录文件修改历史记录，从而让用户能够查看历史版本，方便版本切换。</li></ul><h3 id="版本控制工具"><a href="#版本控制工具" class="headerlink" title="版本控制工具"></a>版本控制工具</h3><h4 id="分布式版本控制工具"><a href="#分布式版本控制工具" class="headerlink" title="分布式版本控制工具"></a>分布式版本控制工具</h4><ul><li>像Git这种分布式版本控制工具，客户端提取的不是最新版本的文件快照，而是把代码仓库完整地镜像下来(本地库)。这样任何一处协同工作用的文件发生故障，事后都可以用其他客户端的本地仓库进行恢复。因为每个客户端的每一次文件提取操作，实际上都是一次对整个文件仓库的完整备份。</li><li>分布式的版本控制系统出现之后解决了集中式版本控制系统的缺陷：<ul><li>服务器断网的情况下也可以进行开发(因为版本控制是在本地进行的)</li><li>每个客户端保存的也都是整个完整的项目(包含历史记录，更加安全)</li></ul></li></ul><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210610082741008.png" alt="分布式版本控制架构图"></p><h4 id="集中式版本控制工具"><a href="#集中式版本控制工具" class="headerlink" title="集中式版本控制工具"></a>集中式版本控制工具</h4><ul><li>集中化的版本控制系统诸如CVS、SWN等,都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。多年以来，这已成为版本控制系统的标准做法。把集中管理的服务器看作是图书馆，当你要修改一本书时，要先从图书馆借出来，然后修改完成之后在还回去。</li><li>这种做法带来了许多好处，每个人都可以在一定程度上看到项目中的其他人正在做些什么。而管理员也可以轻松掌控每个开发者的权限,并且管理一个集中化的版本控制系统，要远比在各个客户端上维护本地数据库来得轻松容易。</li><li>事分两面，有好有坏。这么做显而易见的缺点是中央服务器的单点故障。如果服务器宕机一小时，那么在这一小时内，谁都无法提交更新,也就无法协同工作。</li></ul><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210610082041030.png" alt="集中式版本控制架构图"></p><h3 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h3><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210610085134741.png" alt="Git工作机制"></p><p>在工作区和暂存区可以进行删除，在本地库形成历史版本后将无法删除。</p><h3 id="代码托管中心"><a href="#代码托管中心" class="headerlink" title="代码托管中心"></a>代码托管中心</h3><p>代码托管中心是基于网络服务器的远程代码仓库，一般称为远程库</p><h2 id="Git常用命令"><a href="#Git常用命令" class="headerlink" title="Git常用命令"></a>Git常用命令</h2><p>Git手册：<a href="https://git-scm.com/book/zh/v2">https://git-scm.com/book/zh/v2</a></p><p>Git常用命令及其方法大全：<a href="https://blog.csdn.net/web_csdn_share/article/details/79243308">https://blog.csdn.net/web_csdn_share/article/details/79243308</a></p><div class="table-container"><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>git init</td><td>初始化本地仓库</td></tr><tr><td>git add [file1] [file2]</td><td>添加到暂存区</td></tr><tr><td>git status</td><td>查看本地库状态</td></tr><tr><td>git commi -m “[log]”[name]</td><td>提交到本地库</td></tr><tr><td>git reflog</td><td>查看历史记录</td></tr><tr><td>git reset --hard 版本号</td><td>版本穿梭</td></tr><tr><td>git clone url</td><td>从url克隆项目</td></tr></tbody></table></div><h2 id="Git分支"><a href="#Git分支" class="headerlink" title="Git分支"></a>Git分支</h2><p>在版本控制过程中，同时推进多个任务，为每个任务，我们就可以创建每个任务的单独分支。使用分支意味着程序员可以把自己的工作从开发主线上分离开来，开发自己分支的时候，不会影响主线分支运行。对于初学者而言，分支可以简单理解为副本，一个分支就是一个单独的副本。(分支底层其实也是指针的引用)</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210610115238291.png" alt="分支示例图"></p><p>分支的好处：</p><ul><li>同时并行推进多个功能开发，提高开发效率</li><li>各个分支在开发过程中，如果某一个分支开发失败，不会对其他分支有任何影响。失败<br>的分支删除重新开始即可。  </li></ul><h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">git branch [name]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">git branch -v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">git checkout [name]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 把指定分支合并到当前分支上git merge [name]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>合并分支可能会产生冲突：</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210610115652425.png" alt="冲突"></p><p><strong>冲突产生的原因</strong>：<br>合并分支时，两个分支在同一个文件的同一个位置有两套完全不同的修改。 Git 无法替我们决定使用哪一个。所以必须人为决定新代码内容  。</p><p><strong>解决冲突</strong>：</p><ol><li><p>编辑有冲突的文件，删除特殊符号，决定要使用的内容</p><p>特殊符号：</p><p><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;HEAD</code> 当前分支的代码 <code>==========</code> 合并过来的代码 <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;XXXXX</code></p></li><li><p>添加到暂存区</p></li><li><p>执行提交（<font color="red">注意：此时使用<code>git commit</code>命令时不能带文件名</font>）</p></li></ol><h3 id="创建和切换分支图解"><a href="#创建和切换分支图解" class="headerlink" title="创建和切换分支图解"></a>创建和切换分支图解</h3><p> <img src="https://gitee.com/sehowyoung/images/raw/master/image-20210610125544172.png" alt="创建和切换分支图解"></p><ul><li>master、 hotfix 其实都是指向具体版本记录的指针。当前所在的分支，其实是由<code>head</code>决定的。所以创建分支的本质就是多创建一个指针。</li><li><code>head</code>如果指向 master，那么我们现在就在 master 分支上。<br><code>head</code> 如果执行 hotfix，那么我们现在就在 hotfix 分支上。  </li><li>所以切换分支的本质就是移动head指针</li></ul><h2 id="Git团队协作机制"><a href="#Git团队协作机制" class="headerlink" title="Git团队协作机制"></a>Git团队协作机制</h2><h3 id="团队内协作"><a href="#团队内协作" class="headerlink" title="团队内协作"></a>团队内协作</h3><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210610125755981.png" alt="团队内协作"></p><h3 id="跨团队协作"><a href="#跨团队协作" class="headerlink" title="跨团队协作"></a>跨团队协作</h3><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210610125854069.png" alt="跨团队协作"></p><h2 id="GitHub操作"><a href="#GitHub操作" class="headerlink" title="GitHub操作"></a>GitHub操作</h2><h3 id="远程仓库操作"><a href="#远程仓库操作" class="headerlink" title="远程仓库操作"></a>远程仓库操作</h3><div class="table-container"><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>git remote -v</td><td>查看当前所有远程地址别名</td></tr><tr><td>git remote add 别名 远程地址</td><td>起别名</td></tr><tr><td>git push 别名 分支</td><td>推送本地分支上的内容到远程仓库</td></tr><tr><td>git clone 远程地址</td><td>将远程仓库的内容克隆到本地</td></tr><tr><td>git pull 远程地址别名 远程分支名</td><td>将远程仓库对于分支最新内容拉下来后与当前本地分支直接合并</td></tr></tbody></table></div><h3 id="SSH免密登录"><a href="#SSH免密登录" class="headerlink" title="SSH免密登录"></a>SSH免密登录</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh-keygen -t rsa -C xxxxxx@XXXX.XXX   # 你的邮箱，下面一路回车就行<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Generating public/private rsa key pair.Enter file in which to save the key (/c/Users/Layne/.ssh/id_rsa):Created directory '/c/Users/Layne/.ssh'.Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in /c/Users/Layne/.ssh/id_rsa.Your public key has been saved in /c/Users/Layne/.ssh/id_rsa.pub.The key fingerprint is:SHA256:7CPfRLITKcYDhaqpEDeok7Atvwh2reRmpxxOC6dkY44atguiguyueyue@aliyun.comThe key's randomart image is:+---[RSA 2048]----+| .. || .. || . .. ||+ + o . . ||oO . = S . ||X . .. + = ||+@ * .. = . ||X.&amp;o+. o = ||Eo+Oo . . |+----[SHA256]-----+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cat ~/.ssh/id_rsa.pub<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>复制 id_rsa.pub 文件内容，登录 GitHub，点击用户头像→Settings→SSH and GPG keys  </p><p><img src="https://gitee.com/sehowyoung/images/raw/master/%E9%85%8D%E7%BD%AE.gif" alt="git与GitHub连接配置"></p><h2 id="IDEA集成Git"><a href="#IDEA集成Git" class="headerlink" title="IDEA集成Git"></a>IDEA集成Git</h2><h3 id="配置git忽略文件"><a href="#配置git忽略文件" class="headerlink" title="配置git忽略文件"></a>配置git忽略文件</h3><p>忽略IDEA自动生成的<code>.idea</code>和<code>xxxx.iml</code>文件</p><blockquote><ol><li><p>为什么要忽略他们？</p><p>与项目的实际功能无关，不参与服务器上部署运行。把它们忽略掉能够屏蔽 IDE 工具之<br>间的差异。  </p></li><li><p>怎么忽略？</p><ol><li><p>创建忽略规则文件 xxxx.ignore（前缀名随便起，建议是 git.ignore）这个文件的存放位置原则上在哪里都可以，为了便于让~/.gitconfig 文件引用，建议也放在用户家目录下。<br>git.ignore 文件模版内容如下：</p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">\# Compiled class file*.class  # Log file*.log# BlueJ files*.ctxt# Mobile Tools for Java (J2ME).mtj.tmp/# Package Files #*.jar*.war*.nar*.ear*.zip*.tar.gz*.rar# virtual machine crash logs, seehttp://www.java.com/en/download/help/error_hotspot.xmlhs_err_pid*.classpath.project.settingstarget.idea*.iml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>在.gitconfig文件中引用忽略配置文件</p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">[user]name = Layneemail = Layne@atguigu.com[core]excludesfile = C:/Users/asus/git.ignore<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>==注意：这里要使用“正斜线（/）”，不要使用“反斜线（\）”==</p></li></ol></li></ol></blockquote><h3 id="定位git程序"><a href="#定位git程序" class="headerlink" title="定位git程序"></a>定位git程序</h3><p><code>File</code>—&gt;<code>Settings</code>—&gt;<code>Version Control</code>—&gt;<code>Git</code>—&gt;<code>Path to Git executable：</code>选择自己的git安装目录—&gt;<code>Test</code></p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210610150457470.png" alt="IDEA定位Git"></p><h3 id="初始化本地库"><a href="#初始化本地库" class="headerlink" title="初始化本地库"></a>初始化本地库</h3><p><code>VCS</code>—&gt;<code>Import into Version Control</code>—&gt;<code>Create Git Respository</code>—&gt;选择要创建Git本地仓库的工程/项目</p><h3 id="添加到暂存区"><a href="#添加到暂存区" class="headerlink" title="添加到暂存区"></a>添加到暂存区</h3><p>右键点击项目，选择<code>Git</code>—&gt;<code>Add</code>将项目添加到暂存区</p><h3 id="提交到本地库"><a href="#提交到本地库" class="headerlink" title="提交到本地库"></a>提交到本地库</h3><p><code>Git</code>—&gt;<code>Commit Directory</code>—&gt;<code>Commit Message</code>—&gt;<code>Commit</code></p><h3 id="切换版本"><a href="#切换版本" class="headerlink" title="切换版本"></a>切换版本</h3><p>在IDEA左下角，点击<code>Version Control</code>—&gt;<code>Log</code>查看版本—&gt;右键选择要切换的版本—&gt;菜单里点击<code>Checkout Revision</code></p><h3 id="创建分支-1"><a href="#创建分支-1" class="headerlink" title="创建分支"></a>创建分支</h3><p>选择<code>Git</code>—&gt;<code>Respoitory</code>—&gt;<code>Branches</code>—&gt;<code>New Branch</code>—&gt;填写分支名称—&gt;<code>ok</code>—&gt;右下角看到分支名称，即代表创建成功，并且已切换到分支。</p><h3 id="切换分支-1"><a href="#切换分支-1" class="headerlink" title="切换分支"></a>切换分支</h3><p>IDEA右下角，切换到master分支，右下角看到分支名称，即代表已切换到分支。</p><h3 id="合并分支-1"><a href="#合并分支-1" class="headerlink" title="合并分支"></a>合并分支</h3><p>IDEA右下角，将xxx分支合并到当前master分支。</p><p>如果代码没有冲突， 分支直接合并成功，分支合并成功以后，代码自动提交，无需手动提交本地库。  </p><h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><ol><li>点击 Conflicts 框里的 Merge 按钮，进行手动合并代码。  </li><li>手动合并完代码以后，点击右下角的 Apply 按钮  </li><li>代码冲突解决，自动提交本地库  </li></ol><h2 id="IDEA集成GitHub"><a href="#IDEA集成GitHub" class="headerlink" title="IDEA集成GitHub"></a>IDEA集成GitHub</h2><h3 id="设置GitHub账号"><a href="#设置GitHub账号" class="headerlink" title="设置GitHub账号"></a>设置GitHub账号</h3><p><code>File</code>—&gt;<code>Settings</code>—&gt;<code>Version Control</code>—&gt;<code>GitHub</code>—&gt;<code>+</code>—&gt;添加GitHub账号密码</p><p>如果出现连接不上的情况，可以使用token的方式。</p><h4 id="设置token"><a href="#设置token" class="headerlink" title="设置token"></a>设置token</h4><p>打开<code>github</code>—&gt;头像—&gt;<code>Settings</code>—&gt;<code>Developer settings</code>—&gt;<code>Personal access tokens</code>—&gt;<code>Generate new token</code>—&gt;学习环境权限作用域全部勾选—&gt;<code>Generate token</code></p><p>复制 token ，返回IDEA进行登录。</p><h3 id="分享到Github"><a href="#分享到Github" class="headerlink" title="分享到Github"></a>分享到Github</h3><p><code>VCS</code>—&gt;<code>Import into Version Control</code>—&gt;<code>share Project on GitHub</code>—&gt;填写仓库名，点击分享</p><h3 id="push推送本地库到远程库"><a href="#push推送本地库到远程库" class="headerlink" title="push推送本地库到远程库"></a>push推送本地库到远程库</h3><p>右击项目—&gt;<code>Git</code>—&gt;<code>Respository</code>—&gt;<code>push</code>—&gt;在 <code>Push Commits</code>里面可以创建远程链接的别名—&gt;选择别名，将项目 push 到指定的远程仓库中。</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210610152425952.png" alt="创建远程链接的别名"></p><blockquote><p>注意：</p><p>push 是将本地库代码推送到远程库，如果本地库代码跟远程库代码版本不一致，push 的操作是会被拒绝的。也就是说， 要想 push 成功，一定要保证本地库的版本要比远程库的版本高！ </p><font color="red">因此一个成熟的程序员在动手改本地代码之前，一定会先检查下远程库跟本地代码的区别！如果本地的代码版本已经落后，切记要先 pull 拉取一下远程库的代码，将本地代码更新到最新以后，然后再修改，提交，推送 ！</font></blockquote><h3 id="pull拉去远程库到本地库"><a href="#pull拉去远程库到本地库" class="headerlink" title="pull拉去远程库到本地库"></a>pull拉去远程库到本地库</h3><p>右击项目—&gt;<code>Git</code>—&gt;<code>Respository</code>—&gt;<code>pull</code>—&gt;选择分支，点击<code>Pull</code></p><blockquote><p>注意：</p><p>pull 是拉取远端仓库代码到本地，如果远程库代码和本地库代码不一致，会自动合并，如果自动合并失败，还会涉及到手动解决冲突的问题。  </p></blockquote><h3 id="clone远程库到本地"><a href="#clone远程库到本地" class="headerlink" title="clone远程库到本地"></a>clone远程库到本地</h3><p><code>VCS</code>—&gt;<code>Git</code>—&gt;<code>Clone</code>—&gt;填写url，点击<code>test</code>，点击<code>clone</code>—&gt;创建一个工程，点击<code>next</code></p><h3 id="国内代码托管中心——gitee"><a href="#国内代码托管中心——gitee" class="headerlink" title="国内代码托管中心——gitee"></a>国内代码托管中心——gitee</h3><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>众所周知， GitHub 服务器在国外， 使用 GitHub 作为项目托管网站，如果网速不好的话，严重影响使用体验，甚至会出现登录不上的情况。针对这个情况，大家也可以使用国内的项目托管网站——Gitee。  </p><h3 id="注册账号"><a href="#注册账号" class="headerlink" title="注册账号"></a>注册账号</h3><p>官网：<a href="gitee.com">gitee.com</a></p><h3 id="IDEA集成Gitee"><a href="#IDEA集成Gitee" class="headerlink" title="IDEA集成Gitee"></a>IDEA集成Gitee</h3><h4 id="IDEA安装Gitee插件"><a href="#IDEA安装Gitee插件" class="headerlink" title="IDEA安装Gitee插件"></a>IDEA安装Gitee插件</h4><p>由于IDEA默认不带码云插件，我们要使用Gitee的话，就需要安装Gitee插件。</p><p><code>File</code>—&gt;<code>settings</code>—&gt;<code>plugins</code>—&gt;<code>Marketplace</code>—&gt;搜索<code>gitee</code>—&gt;<code>Install</code>—&gt;<code>Restart IDE</code></p><p><code>File</code>—&gt;<code>Settings</code>—&gt;<code>Version Control</code>—&gt;<code>Gitee</code>—&gt;<code>+</code>—&gt;添加Gitee账号密码</p><h4 id="IDEA连接Gitee"><a href="#IDEA连接Gitee" class="headerlink" title="IDEA连接Gitee"></a>IDEA连接Gitee</h4><p>dea 连接Gitee和连接 GitHub 几乎一样，首先在 Idea 里面创建一个工程，初始化 git 工程，然后将代码添加到暂存区，提交到本地库，这些步骤上面已经讲过，此处不再赘述。  </p><h4 id="本地代码Push到Gitee"><a href="#本地代码Push到Gitee" class="headerlink" title="本地代码Push到Gitee"></a>本地代码Push到Gitee</h4><p>右击项目—&gt;<code>Git</code>—&gt;<code>Respository</code>—&gt;<code>push</code>—&gt;在 <code>Push Commits</code>里面可以创建远程链接的别名，url填入Gitee仓库的链接即可—&gt;选择别名，将项目 push 到指定的远程仓库中。</p><p>只要码云远程库链接定义好以后， 对码云远程库进行 pull 和 clone 的操作和 Github 一<br>致，此处不再赘述。  </p><h3 id="Gitee复制GitHub项目"><a href="#Gitee复制GitHub项目" class="headerlink" title="Gitee复制GitHub项目"></a>Gitee复制GitHub项目</h3><p>Gitee提供了复制GitHub项目的功能，方便我们迁移和下载。</p><p>打开gitee —&gt; 右上角<code>+</code> —&gt; 从GitHub/GitLab导入仓库 —&gt;从GitHub导入 —&gt; 选择要导入的仓库，点击导入即可。</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210610194849360.png" alt="从GitHub/GitLab导入仓库"></p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210610194922761.png" alt="选择仓库进行导入"></p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经典排序算法的分析与实现</title>
      <link href="/posts/23901.html"/>
      <url>/posts/23901.html</url>
      
        <content type="html"><![CDATA[<h1 id="经典排序算法的分析与实现"><a href="#经典排序算法的分析与实现" class="headerlink" title="经典排序算法的分析与实现"></a>经典排序算法的分析与实现</h1><p>源码：</p><ul><li>gitee：<a href="https://gitee.com/sehowyoung/Sort">https://gitee.com/sehowyoung/Sort</a></li><li>github：<a href="https://github.com/sehowyoung/Sort">https://github.com/sehowyoung/Sort</a></li></ul><h2 id="1-comparable和comparator"><a href="#1-comparable和comparator" class="headerlink" title="1.comparable和comparator"></a>1.comparable和comparator</h2><blockquote><p>1.Comparable是排序接口；若一个类实现了Comparable接口，就意味着“该类支持排序”。</p><p>（作用在实体类上）<br>2.而Comparator是比较器；我们若需要控制某个类的次序，可以建立一个“该类的比较器”来进行排序。</p><p>（作用在排序类上）</p><p>总结：Comparable相当于“内部比较器”，而Comparator相当于“外部比较器”。</p></blockquote><h2 id="2-约定"><a href="#2-约定" class="headerlink" title="2.约定"></a>2.约定</h2><p>待排序的元素需要实现 Java 的 Comparable 接口，该接口有 compareTo() 方法，可以用它来判断两个元素的大小关系。</p><p>使用辅助函数 lessThan() 和 swap() 来进行比较和交换的操作，使得代码的可读性和可移植性更好。</p><p>排序算法的成本模型是比较和交换的次数。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public abstract class Sort&lt;T extends Comparable&lt;T&gt;&gt;  {    /**     * 对目标数组进行排序     * @param array 目标数组     */    public abstract void sort(T[] array);    /**     * @param v T类型的对象     * @param w T类型的对象     * @return 如果v&lt;w，返回true，否则返回false     */    protected boolean lessThan(T v, T w){        return v.compareTo(w) &lt; 0;    }    /**     * 比较同一类型的两个示例的大小     * @param v T类型的示例     * @param w T类型的示例     * @return 如果v&gt;w，返回true，否则返回false     */    protected boolean moreThn(T v, T w){        return v.compareTo(w) &gt; 0;    }    /**     * 用于交换数组中的两个数     * @param array 目标数组     * @param i 数组下标     * @param j 数组下标     */    protected void swap(T[] array, int i, int  j){        T t = array[i];        array[i] = array[j];        array[j] = t;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-选择排序算法"><a href="#3-选择排序算法" class="headerlink" title="3.选择排序算法"></a>3.选择排序算法</h2><p><strong>原理：</strong></p><p>每次从数组中选择最小元素，将它与数组的第i个元素交换位置。</p><p>选择排序需要 ~N^2^/2 次比较和 ~N 次交换，它的运行时间与输入无关，这个特点使得它对一个已经排序的数组也需要这么多的比较和交换操作。</p><p><img src="https://i.imgur.com/fYPsoKv.gif" alt=""></p><p><strong>代码实现：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Selection&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt; {    /**     * 使用快速排序算法进行排序     * @param array 目标数组     */    @Override    public void sort(T[] array) {        int n = array.length;        for (int i = 0; i &lt; n - 1; i++) {            int min = i;            for (int j = i + 1; j &lt; n; j++) {                if (lessThan(array[j], array[i])){                    min = j;                }            }            swap(array, i, min);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-冒泡排序算法"><a href="#4-冒泡排序算法" class="headerlink" title="4.冒泡排序算法"></a>4.冒泡排序算法</h2><p><strong>原理：</strong></p><p>从左到右不断交换相邻的逆序的元素，在经过一轮的循环之后，可以让最大的元素上浮到最右边。</p><p>在一轮循环中，如果没有发生交换，那么说明数组已经是有序的，此时可以直接退出。</p><p><img src="https://i.imgur.com/vkZ5GS7.gif" alt=""></p><p><strong>代码实现：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Bubble&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt;{    /**     * 用冒泡排序算法进行排序     * @param array 目标数组     */    @Override    public void sort(T[] array) {        int n = array.length;        boolean isSorted = false;        for (int i = 0; i &lt; n - 1; i++) {            isSorted = false;            for (int j = 0; j &lt; n - i - 1; j++) {                if (lessThan(array[j + 1], array[j])){                    swap(array, j + 1, j);                    isSorted = true;                }            }            if (!isSorted){                break;            }        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-插入排序算法"><a href="#5-插入排序算法" class="headerlink" title="5.插入排序算法"></a>5.插入排序算法</h2><p><strong>原理：</strong></p><p>从数组的第i（i&gt;1）个数据开始向前比较，如果比j（j&lt;i）小，交换位置。</p><p><img src="https://i.imgur.com/bncpJ2B.gif" alt=""></p><p><strong>代码实现：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Insertion&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt; {    /**     * 使用插入排序算法进行排序     * @param array 目标数组     */    @Override    public void sort(T[] array) {        for (int i = 1; i &lt; array.length; i++) {            for (int j = i; j &gt; 0; j--) {                if (lessThan(array[j], array[j - 1])){                    swap(array, j, j - 1);                }            }        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-希尔排序算法"><a href="#6-希尔排序算法" class="headerlink" title="6.希尔排序算法"></a>6.希尔排序算法</h2><p><strong>原理：</strong></p><p>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p><p><img src="https://i.imgur.com/3ymhb30.png" alt=""></p><p><strong>代码实现：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Shell&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt; {    /**     * 使用希尔排序算法进行排序     * @param array 目标数组     */    @Override    public void sort(T[] array) {        int gap = array.length / 2;        while(gap &gt;= 1){            for (int i = gap; i &lt; array.length; i++) {                for (int j = i; j &gt; gap - 1; j -= gap) {                    if (lessThan(array[j], array[j - gap])){                        swap(array, j, j - gap);                    }                }            }            gap /= 2;        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="7-归并排序算法"><a href="#7-归并排序算法" class="headerlink" title="7.归并排序算法"></a>7.归并排序算法</h2><p><strong>原理：</strong></p><p>归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。</p><p><strong>归并部分代码：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public abstract class Marge&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt; {    /**     * 归并算法     * @param array 原数组     * @param low   需要进行归并部分的开始下标     * @param mid   需要进行归并部分的中间下标     * @param high  需要进行归并部分的结束下标     * @param aux   辅助数组     */    protected void marge(T[] array, int low, int mid, int high, T[] aux){        for (int i = low; i &lt;= high; i++) {            aux[i] = array[i];        }        //右指针        int right = mid + 1;        //左指针        int left = low;        for (int i = low; i &lt;= high; i++) {            if (left &gt; mid){                //将右序列剩余元素添加进原数组                array[i] = aux[right++];            } else if (right &gt; high){                //将左序列剩余元素添加进原数组                array[i] = aux[left++];            } else if (aux[left].compareTo(aux[right]) &lt;= 0){                //添加小的元素进入原数组                array[i] = aux[left++];            } else {                //添加小的元素进入原数组                array[i] = aux[right++];            }        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-1-自顶向上归并排序"><a href="#7-1-自顶向上归并排序" class="headerlink" title="7.1 自顶向上归并排序"></a>7.1 自顶向上归并排序</h3><p><strong>原理：</strong></p><p>自顶向下的排序算法就是把数组元素不断的二分，直到子数组的元素个数为一个，因为这个时候子数组必定是已有序的，然后将两个有序的序列合并成一个新的有序的序列，两个新的有序序列又可以合并成另一个新的有序序列，以此类推，直到合并成一个有序的数组。</p><p><img src="https://i.imgur.com/b5Dgq52.png" alt=""></p><p><img src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161218194508761-468169540.png" alt=""></p><p><img src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161218194621308-588010220.png" alt=""></p><p><strong>代码实现：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class UpToDownMarge&lt;T extends Comparable&lt;T&gt;&gt; extends Marge&lt;T&gt;{    /**     * 使用自顶向下归并排序算法进行排序     * @param array 目标数组     */    @Override    public void sort(T[] array) {        //创建辅助数组        T[] auxiliary = (T[]) new Comparable[array.length];        sort(array, 0, array.length - 1, auxiliary);    }    /**     * 使用递归对数组进行划分     * @param array 任意类型的原数组     * @param low   需要进行划分部分的初始下标     * @param high  需要进行划分部分的结束下标     * @param aux   辅助数组     */    private void sort(T[] array, int low, int high, T[] aux) {        if (high &lt;= low){            return;        }        int mid = (low + high) / 2;        sort(array, low, mid, aux);        sort(array, mid + 1, high, aux);        marge(array, low, mid, high, aux);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-2-自底向上归并排序"><a href="#7-2-自底向上归并排序" class="headerlink" title="7.2 自底向上归并排序"></a>7.2 自底向上归并排序</h3><p><strong>原理：</strong></p><p>自底向上的排序是归并排序的一种实现方式，将一个无序的N长数组切个成N个有序子序列，然后再两两合并，然后再将合并后的N/2（或者N/2 + 1）个子序列继续进行两两合并，以此类推得到一个完整的有序数组。下图详细的分解了自底向上的合并算法的实现过程：</p><p><img src="https://i.imgur.com/57XtOjM.jpg" alt=""></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class DownToUpMerge&lt;T extends Comparable&lt;T&gt;&gt; extends Merge&lt;T&gt; {    /**     * 使用自底向上归并排序算法进行排序     * @param array 目标数组     */    @Override    public void sort(T[] array) {        T[] auxiliary = (T[]) new Comparable[array.length];        //len表示有len个元素归并，例如len=1表示一个一个元素的进行归并        for (int len = 1; len &lt; array.length; len += len) {            //按照len的长度归并，归并后长度翻倍            for (int start = 0; start &lt; array.length - len; start += len + len) {                merge(array, start, start + len - 1, Math.min(start + len + len -1, array.length - 1), auxiliary);            }        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="8-快速排序算法"><a href="#8-快速排序算法" class="headerlink" title="8.快速排序算法"></a>8.快速排序算法</h2><h3 id="8-1-基本算法"><a href="#8-1-基本算法" class="headerlink" title="8.1 基本算法"></a>8.1 基本算法</h3><p><strong>基本思想：</strong></p><ul><li>先从数列中取出一个数作为基准数。</li><li>分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。</li><li>再对左右区间重复第二步，直到各区间只有一个数。</li></ul><p><img src="https://i.imgur.com/L1UTzxn.png" alt=""></p><ul><li>切分：取 array[low] 作为切分元素，然后从数组的左端向右端扫描知道找到第一个大于等于它的元素，再从数组的右端向左扫描找到第一个小于它的元素，交换这两个元素。不断重复进行这个过程就可以保证左指针 left 的左侧元素都不大于切分元素，右指针 right 的右侧元素都不小于切分元素。当两个指针相遇时，将切分元素 a[low] 和 a[right] 交换位置。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Quick&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt; {    /**     * 使用快速排序算法进行排序     * @param array 目标数组     */    @Override    public void sort(T[] array) {        sort(array, 0, array.length - 1);    }    /**     * 通过递归不断交换元素的位置     * @param array 被操作的数组     * @param low   从左边开始执行的元素下标     * @param high  从右边开始执行的元素下标     */    private void sort(T[] array, int low, int high) {        if (high &lt;= low){            return;        }        //获取被发生交换的元素的位置        int index = partition(array, low, high);        sort(array, low, index - 1);        sort(array, index + 1, high);    }    /**     * 对原数组进行切分，获取与array[low]进行交换的元素的下标     * @param array 操作数组     * @param low   从左边开始执行的元素下标     * @param high  从右边开始执行的元素下标     * @return 返回与array[low]进行交换的元素的下标     */    private int partition(T[] array, int low, int high) {        //左指针        int left = low + 1;        //右指针        int right = high;        T flag = array[low];        while (true){            while (lessThan(array[left], flag) &amp;&amp; left != high){                left++;            }            while (lessThan(flag, array[right]) &amp;&amp; right != low){                right--;            }            if (left &gt;= right){                break;            }            swap(array, left, right);        }        swap(array, low, right);        return right;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="8-2-性能分析"><a href="#8-2-性能分析" class="headerlink" title="8.2 性能分析"></a>8.2 性能分析</h3><p>快速排序是原地排序，不需要辅助数组，但是递归调用需要辅助栈。</p><p>快速排序最好的情况下是每次都正好将数组对半分，这样递归调用次数才是最少的。这种情况下比较次数为 CN=2CN/2+N，复杂度为 O(NlogN)。</p><p>最坏的情况下，第一次从最小的元素切分，第二次从第二小的元素切分，如此这般。因此最坏的情况下需要比较 N2/2。为了防止数组最开始就是有序的，在进行快速排序时需要随机打乱数组。</p><h3 id="8-3-算法改进"><a href="#8-3-算法改进" class="headerlink" title="8.3 算法改进"></a>8.3 算法改进</h3><h4 id="8-3-1-切换到插入排序"><a href="#8-3-1-切换到插入排序" class="headerlink" title="8.3.1 切换到插入排序"></a>8.3.1 切换到插入排序</h4><p>在面对小数组时，使用快速排序会浪费更多的时间、空间，可以学习jdk1.8的排序算法，当数组长度小于某个值时，使用插入排序算法</p><h4 id="8-3-2-三数取中算法"><a href="#8-3-2-三数取中算法" class="headerlink" title="8.3.2 三数取中算法"></a>8.3.2 三数取中算法</h4><p>在快排的过程中，每一次我们要取一个元素作为枢纽值，以这个数字来将序列划分为两部分。在此我们采用三数取中法，也就是取左端、中间、右端三个数，然后进行排序，将中间数作为枢纽值。</p><p><strong>基本原理：</strong></p><p><img src="https://i.imgur.com/KeNroIf.png" alt=""></p><p><img src="https://i.imgur.com/xnQscCO.png" alt=""></p><p><img src="https://i.imgur.com/yLQ3aMX.png" alt=""></p><p><strong>代码实现：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MiddleOfThree&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt; {    /**     * 使用三数取中快速排序算法进行排序     * @param array 目标数组     */    @Override    public void sort(T[] array) {        sort(array, 0, array.length - 1);    }    /**     * 使用递归对目标数组 array 进行排序     * @param array 目标数组     * @param low   左指针     * @param high  右指针     */    private void sort(T[] array, int low, int high) {        dealPivot(array, low, high);        //使用下列判断去除一下已经排好序的情况，节省运行时间        if (high &lt;= low + 1){            return;        }        int pivot = high - 1;        int left = low + 1;        int right = pivot - 1;        while (true){            while (lessThan(array[left], array[pivot]) &amp;&amp; left &lt; high){                left++;            }            while (right &gt; low &amp;&amp; moreThen(array[right], array[pivot])){                right--;            }            if (right &gt; left){                swap(array, left, right);            } else {                break;            }        }        swap(array, left, pivot);        sort(array, low, left - 1);        sort(array, left + 1, high);    }    /**     * 找到枢纽值，并对左端值、枢纽值、右端值进行排序，并将枢纽值放到右端值左侧     * 通过三次判断就保证了三个值的升序排列     * @param array 目标数组     * @param low   左端指针     * @param high  右端指针     */    private void dealPivot(T[] array, int low, int high) {        int mid = (low + high) / 2;        //对左端值、枢纽值、右端值三个数进行排序        if (lessThan(array[mid], array[low])){            swap(array, low, mid);        }        if (lessThan(array[high], array[mid])){            swap(array, mid, high);        }        if (lessThan(array[mid], array[low])){            swap(array, low, mid);        }        //将枢纽值放到右端值左侧        swap(array, mid, high - 1);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="8-3-3-三向切分算法"><a href="#8-3-3-三向切分算法" class="headerlink" title="8.3.3 三向切分算法"></a>8.3.3 三向切分算法</h4><p>对于有大量重复元素的数组，可以将数组切分为三部分，分别对应小于、等于和大于切分元素。</p><p>三向切分快速排序对于有大量重复元素的随机数组可以在线性时间内完成排序。</p><p><strong>基本原理：</strong></p><p>对于每次切分：从数组的左边到右边遍历一次，维护三个指针，其中lt指针使得元素（arr[0]-arr[lt-1]）的值均小于切分元素；gt指针使得元素（arr[gt+1]-arr[N-1]）的值均大于切分元素；index指针使得元素（arr[lt]-arr[index-1]）的值均等于切分元素，（arr[index]-arr[gt]）的元素还没被扫描，切分算法执行到index&gt;gt为止。每次切分之后，位于gt指针和lt指针之间的元素的位置都已经被排定，不需要再去处理了。之后将（lo,lt-1）,（gt+1,hi）分别作为处理左子数组和右子数组的递归函数的参数传入，递归结束，整个算法也就结束。</p><p><img src="https://i.imgur.com/6tWXYdr.png" alt=""></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ThreeWay&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt; {    /**     * 实现Sort的sort接口     * @param array 目标数组     */    @Override    public void sort(T[] array) {        sort(array, 0, array.length - 1);    }    /**     * 递归使用三向切分快速排序算法进行排序     * @param array 目标数组     * @param low   左指针     * @param high  右指针     */    private void sort(T[] array, int low, int high) {        if (high &lt;= low){            return;        }        //lt:less than  gt:greater than        int lt = low;        int index = low + 1;        int gt = high;        T temp = array[low];        while (index &lt;= gt){            int cmp = array[index].compareTo(temp);            if (cmp &lt; 0){                swap(array, lt++, index++);            } else if (cmp &gt; 0){                swap(array, index, gt--);            } else {                index++;            }        }        sort(array, low, lt - 1);        sort(array, gt + 1, high);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="8-4-基于切分的快速选择算法"><a href="#8-4-基于切分的快速选择算法" class="headerlink" title="8.4 基于切分的快速选择算法"></a>8.4 基于切分的快速选择算法</h4><p>快速排序的 partition() 方法，会返回一个整数 j 使得 a[l..j-1] 小于等于 a[j]，且 a[j+1..h] 大于等于 a[j]，此时 a[j] 就是数组的第 j 大元素。</p><p>可以利用这个特性找出数组的第 k 个元素。</p><p>该算法是线性级别的，假设每次能将数组二分，那么比较的总次数为 (N+N/2+N/4+..)，直到找到第 k 个元素，这个和显然小于 2N。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">/**     * 搜索数组中第k个小的元素     * @param array 目标数组     * @param k     第k个元素     * @return      第k个元素     */    public T select(T[] array, int k){        int low = 0;        int high = array.length - 1;        while (high &gt; low){            int index = partition(array, low, high);            if (index == k - 1){                return array[k - 1];            } else if (index &gt; k - 1){                high = index - 1;            } else {                low = index + 1;            }        }        return array[k - 1];    }<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="9-堆排序"><a href="#9-堆排序" class="headerlink" title="9.堆排序"></a>9.堆排序</h2><p>堆中某个节点的值总是大于等于或小于等于其子节点的值，并且堆是一颗完全二叉树。</p><p>堆可以用数组来表示，这是因为堆是完全二叉树，而完全二叉树很容易就存储在数组中。位置 k 的节点的父节点位置为 k/2，而它的两个子节点的位置分别为 2k 和 2k+1。这里不使用数组索引为 0 的位置，是为了更清晰地描述节点的位置关系。</p><p><strong>基本原理：</strong></p><ol><li>构建堆：根据初始数组去构造初始堆（构建一个完全二叉树，保证所有的父结点都比它的孩子结点数值大）。</li><li>每次交换第一个和最后一个元素，输出最后一个元素（最大值），然后把剩下元素重新调整为大根堆。 </li><li>当输出完最后一个元素后，这个数组已经是按照从小到大的顺序排列了。</li></ol><p>具体可以查看博客：<a href="https://www.cnblogs.com/chengxiao/p/6129630.html">图解排序算法(三)之堆排序</a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class HeapSort&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt; {    /**     * 使用堆排序算法进行排序     * @param array 目标数组     */    @Override    public void sort(T[] array) {        //构建大顶堆        int len = array.length;        for (int i = len / 2 - 1; i &gt;= 0; i--) {            //从第一个非叶子结点从下至上，从右至左调整结构            adjust(array, i, len);        }        //调整堆结构+交换堆顶元素与末尾元素        for (int i = len - 1; i &gt; 0; i--) {            swap(array, 0, i);            adjust(array, 0, i);        }    }    /**     * 对第i个节点以及其子节点进行调整调整     * @param array 目标数组     * @param i     第i个节点     * @param len   数组长度     */    private void adjust(T[] array, int i, int len) {        //获取当前值        T temp = array[i];        //从i节点的左子节点开始，即2i+1处        for (int j = i * 2 + 1; j &lt; len; j = j * 2 + 1) {            //如果存在右子节点，并且左子节点小于右子节点，j指向右子节点            if (j + 1 &lt; len &amp;&amp; lessThan(array[j], array[j + 1])){                j++;            }            //如果子节点大于父节点，将子节点值赋给父节点（不进行交换）            if (lessThan(temp, array[j])){                array[i] = array[j];                i = j;            } else {                break;            }        }        //将temp的值放到最终的位置        array[i] = temp;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>分析：</strong></p><ul><li><p>一个堆的高度为 logN，因此在堆中插入元素和删除最大元素的复杂度都为 logN。</p></li><li><p>对于堆排序，由于要对 N 个节点进行下沉操作，因此复杂度为 NlogN。</p></li><li><p>堆排序是一种原地排序，没有利用额外的空间。</p></li><li><p>现代操作系统很少使用堆排序，因为它无法利用局部性原理进行缓存，也就是数组元素很少和相邻的元素进行比较和交换。</p></li></ul><h2 id="10-上述排序算法的比较"><a href="#10-上述排序算法的比较" class="headerlink" title="10.上述排序算法的比较"></a>10.上述排序算法的比较</h2><div class="table-container"><table><thead><tr><th>算法</th><th>稳定性</th><th>时间复杂度</th><th>空间复杂度</th><th>备注</th></tr></thead><tbody><tr><td><a href="#3.选择排序算法">选择排序</a></td><td>×</td><td>N^2^</td><td>1</td><td></td></tr><tr><td><a href="#4.冒泡排序算法">冒泡排序</a></td><td>√</td><td>N^2^</td><td>1</td><td></td></tr><tr><td><a href="#5.插入排序算法">插入排序</a></td><td>√</td><td>N~N^2^</td><td>1</td><td>时间复杂度和初始顺序有关</td></tr><tr><td><a href="#6.希尔排序算法">希尔排序</a></td><td>×</td><td>N的若干倍乘于递增序列的长度</td><td>1</td><td>改进版插入排序</td></tr><tr><td><a href="#7.归并排序算法">归并排序</a></td><td>√</td><td>NlogN</td><td>N</td><td></td></tr><tr><td><a href="#8.快速排序算法">快速排序</a></td><td>×</td><td>NlogN</td><td>logN</td><td></td></tr><tr><td><a href="#8.3.2 三数取中算法">三数取中快速排序</a></td><td>×</td><td>NlogN</td><td>logN</td><td></td></tr><tr><td><a href="#8.3.3 三向切分算法">三向切分快速排序</a></td><td>×</td><td>N ~ NlogN</td><td>logN</td><td>适用于有大量重复数据</td></tr><tr><td><a href="#9.堆排序">堆排序</a></td><td>×</td><td>NlogN</td><td>1</td><td>无法利用局部性原理</td></tr></tbody></table></div><ul><li>排序算法的稳定性：俗地讲就是能保证排序前两个相等的数据其在序列中的先后位置顺序与排序后它们两个先后位置顺序相同。即：如，如果A i == A j，Ai 原来在 Aj 位置前，排序后 Ai 仍然是在 Aj 位置前。</li></ul><h2 id="11-JDK自带的DualPivotQuickSort"><a href="#11-JDK自带的DualPivotQuickSort" class="headerlink" title="11.JDK自带的DualPivotQuickSort"></a>11.JDK自带的DualPivotQuickSort</h2><p>jdk版本：1.8.0_281</p><p>DualPivotQuickSort 类实现了由 Vladimir Yaroslavskiy、Jon Bentley和Josh Bloch的Dual-Pivot Quicksort算法。该算法在许多数据集上提供了O(nlog(n))的性能，这些数据集会导致其他quicksort的性能下降到二次方，并且通常比传统的（单枢轴）Quicksort实现更快。所有暴露的方法都是包私有的，设计为在执行任何必要的数组边界检查并将参数扩展为所需形式后，从公共方法（在类Arrays中）调用。</p><p>整个算法的思路是：首先检查数组的长度，比一个阈值小的时候直接使用双轴快排。其它情况下，先检查数组中数据的顺序连续性。把数组中连续升序或者连续降序的信息记录下来，顺便把连续降序的部分倒置。这样数据就被切割成一段段连续升序的数列。</p><p>以下是int类型排序的源码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">final class DualPivotQuicksort {    /**     * 保护这个类不被实例化     */    private DualPivotQuicksort() {}    /**     * 待归并的序列的最大数量     */    private static final int MAX_RUN_COUNT = 67;    /**     * 待归并的序列的最大长度     */    private static final int MAX_RUN_LENGTH = 33;    /**     * 如果参与排序的数组长度小于这个值，优先使用快速排序而不是归并排序     */    private static final int QUICKSORT_THRESHOLD = 286;    /**     * 如果参与排序的数组长度小于这个值，优先使用插入排序而不是快速排序     */    private static final int INSERTION_SORT_THRESHOLD = 47;    /**     * 如果要排序的字节数组的长度大于这个常数，则优先使用计数排序，而不是插入排序。     */    private static final int COUNTING_SORT_THRESHOLD_FOR_BYTE = 29;    /**     * 如果要排序的短数组或char数组的长度大于这个常数，则优先使用计数排序，而不是Quicksort。     */    private static final int COUNTING_SORT_THRESHOLD_FOR_SHORT_OR_CHAR = 3200;   /**     * 如果可能的话，使用给定的工作空间数组片对数组的指定范围进行排序，以便合并。     *     * @param a         目标数组     * @param left the  第一个元素的索引，包括在内，要进行排序。     * @param right the 要排序的数组的最后一个元素的索引，包括在内。     * @param work     工作区阵列     * @param workBase  工作阵列中可用空间的来源     * @param workLen   工作阵列的可用长度     */    static void sort(int[] a, int left, int right,                     int[] work, int workBase, int workLen) {        // 在小数组上使用Quicksort        if (right - left &lt; QUICKSORT_THRESHOLD) {            sort(a, left, right, true);            return;        }        /*         * Index run[i] is the start of i-th run         * (ascending or descending sequence).         */        int[] run = new int[MAX_RUN_COUNT + 1];        int count = 0; run[0] = left;        // 检查数组是否接近排序        for (int k = left; k &lt; right; run[count] = k) {            if (a[k] &lt; a[k + 1]) { // 升序                while (++k &lt;= right &amp;&amp; a[k - 1] &lt;= a[k]);            } else if (a[k] &gt; a[k + 1]) { // 降序                while (++k &lt;= right &amp;&amp; a[k - 1] &gt;= a[k]);                for (int lo = run[count] - 1, hi = k; ++lo &lt; --hi; ) {                    int t = a[lo]; a[lo] = a[hi]; a[hi] = t;                }            } else { // equal                for (int m = MAX_RUN_LENGTH; ++k &lt;= right &amp;&amp; a[k - 1] == a[k]; ) {                    if (--m == 0) {                        sort(a, left, right, true);                        return;                    }                }            }            /*             * 数组结构不高，用Quicksort代替合并排序。             */            if (++count == MAX_RUN_COUNT) {                sort(a, left, right, true);                return;            }        }        // 检查特殊情况        // 实施说明：变量 "right "增加1。        if (run[count] == right++) { // The last run contains one element            run[++count] = right;        } else if (count == 1) { // The array is already sorted            return;        }        // 确定合并的交替基础        byte odd = 0;        for (int n = 1; (n &lt;&lt;= 1) &lt; count; odd ^= 1);        // 使用或创建临时数组b进行合并        int[] b;                 // temp array; alternates with a        int ao, bo;              // array offsets from 'left'        int blen = right - left; // space needed for b        if (work == null || workLen &lt; blen || workBase + blen &gt; work.length) {            work = new int[blen];            workBase = 0;        }        if (odd == 0) {            System.arraycopy(a, left, work, workBase, blen);            b = a;            bo = 0;            a = work;            ao = workBase - left;        } else {            b = work;            ao = 0;            bo = workBase - left;        }        // Merging        for (int last; count &gt; 1; count = last) {            for (int k = (last = 0) + 2; k &lt;= count; k += 2) {                int hi = run[k], mi = run[k - 1];                for (int i = run[k - 2], p = i, q = mi; i &lt; hi; ++i) {                    if (q &gt;= hi || p &lt; mi &amp;&amp; a[p + ao] &lt;= a[q + ao]) {                        b[i + bo] = a[p++ + ao];                    } else {                        b[i + bo] = a[q++ + ao];                    }                }                run[++last] = hi;            }            if ((count &amp; 1) != 0) {                for (int i = right, lo = run[count - 1]; --i &gt;= lo;                    b[i + bo] = a[i + ao]                );                run[++last] = right;            }            int[] t = a; a = b; b = t;            int o = ao; ao = bo; bo = o;        }    }            /**     * 使用双轴快速排序给指定数组的指定范围排序     *     * @param          目标数组     * @param left     范围内最左边的元素的位置(包括该元素)     * @param right    范围内最右边的元素的位置(包括该元素)     * @param leftmost 指定的范围是否在数组的最左边     */    private static void sort(int[] a, int left, int right, boolean leftmost) {        int length = right - left + 1;        //小数组使用插入排序        if (length &lt; INSERTION_SORT_THRESHOLD) {            if (leftmost) {                /*                 * 传统的（没有哨兵）插入排序，针对服务器虚拟机进行了优化，在最左边的情况下使用。                 */                for (int i = left, j = i; i &lt; right; j = ++i) {                    int ai = a[i + 1];                    while (ai &lt; a[j]) {                        a[j + 1] = a[j];                        if (j-- == left) {                            break;                        }                    }                    a[j + 1] = ai;                }            } else {                /*                 * 跳过开头的升序。                 */                do {                    if (left &gt;= right) {                        return;                    }                } while (a[++left] &gt;= a[left - 1]);                /*                 * 来自相邻部分的每个元素都扮演着哨兵的角色，因此，这使得我们可以避免                 * 每次迭代的左范围检查。此外，我们使用了更优化的算法，即所谓的成对插入                 * 排序，它比传统的插入排序的实现更快（在Quicksort的上下文中）。                 */                for (int k = left; ++left &lt;= right; k = ++left) {                    int a1 = a[k], a2 = a[left];                    if (a1 &lt; a2) {                        a2 = a1; a1 = a[left];                    }                    //先把两个数字中较大的那个移动到合适的位置                    while (a1 &lt; a[--k]) {                        //这里每次需要向左移动两个元素                        a[k + 2] = a[k];                    }                    a[++k + 1] = a1;  //再把两个数字中较小的那个移动到合适的位置                    while (a2 &lt; a[--k]) {                        //这里每次需要向左移动一个元素                        a[k + 1] = a[k];                    }                    a[k + 1] = a2;                }                int last = a[right];                while (last &lt; a[--right]) {                    a[right + 1] = a[right];                }                a[right + 1] = last;            }            return;        }        // length / 7的一种低复杂度实现        int seventh = (length &gt;&gt; 3) + (length &gt;&gt; 6) + 1;        /*         * 在范围内的中心元素周围（并包括中心元素）排序五个均匀间隔的元素。         * 这些元素将用于下文所述的枢轴选择。这些元素间距的选择是根据经验确定的，         * 对各种输入都能很好地发挥作用。         */        // 中间值        int e3 = (left + right) &gt;&gt;&gt; 1;         int e2 = e3 - seventh;        int e1 = e2 - seventh;        int e4 = e3 + seventh;        int e5 = e4 + seventh;        // 对这些元素使用插入排序        if (a[e2] &lt; a[e1]) { int t = a[e2]; a[e2] = a[e1]; a[e1] = t; }        if (a[e3] &lt; a[e2]) { int t = a[e3]; a[e3] = a[e2]; a[e2] = t;            if (t &lt; a[e1]) { a[e2] = a[e1]; a[e1] = t; }        }        if (a[e4] &lt; a[e3]) { int t = a[e4]; a[e4] = a[e3]; a[e3] = t;            if (t &lt; a[e2]) { a[e3] = a[e2]; a[e2] = t;                if (t &lt; a[e1]) { a[e2] = a[e1]; a[e1] = t; }            }        }        if (a[e5] &lt; a[e4]) { int t = a[e5]; a[e5] = a[e4]; a[e4] = t;            if (t &lt; a[e3]) { a[e4] = a[e3]; a[e3] = t;                if (t &lt; a[e2]) { a[e3] = a[e2]; a[e2] = t;                    if (t &lt; a[e1]) { a[e2] = a[e1]; a[e1] = t; }                }            }        }        //指针        int less  = left;  // 中间区域首个元素的下标        int great = right; // 右边区域首个元素的下标        if (a[e1] != a[e2] &amp;&amp; a[e2] != a[e3] &amp;&amp; a[e3] != a[e4] &amp;&amp; a[e4] != a[e5]) {            /*             * 使用五个排序元素中的第二个和第四个作为支点。             * 这些值是数组的第一和第二特码的廉价近似值。             * 请注意，pivot1 &lt;= pivot2。             */            int pivot1 = a[e2];            int pivot2 = a[e4];            /*             * 要排序的第一个和最后一个元素被移动到以前被枢轴占用的位置。             * 分割完成后，将枢轴换回其最终位置，并将其排除在后续排序之外。             */            a[e2] = a[left];            a[e4] = a[right];            /*             * 跳过一些队首的小于pivot1的值，跳过队尾的大于pivot2的值             */            while (a[++less] &lt; pivot1);            while (a[--great] &gt; pivot2);            /*             * Partitioning:             *             *   left part           center part                   right part             * +--------------------------------------------------------------+             * |  &lt; pivot1  |  pivot1 &lt;= &amp;&amp; &lt;= pivot2  |    ?    |  &gt; pivot2  |             * +--------------------------------------------------------------+             *               ^                          ^       ^             *               |                          |       |             *              less                        k     great             *             * Invariants:             *             *              all in (left, less)   &lt; pivot1             *    pivot1 &lt;= all in [less, k)     &lt;= pivot2             *              all in (great, right) &gt; pivot2             *             * Pointer k is the first index of ?-part.             */            outer:            for (int k = less - 1; ++k &lt;= great; ) {                int ak = a[k];                // 将a[k]移动到左部区域                if (ak &lt; pivot1) {                     a[k] = a[less];                    /*                     * Here and below we use "a[i] = b; i++;" instead                     * of "a[i++] = b;" due to performance issue.                     */                    a[less] = ak;                    ++less;                // 移动 a[k]到右侧区域                } else if (ak &gt; pivot2) {                     while (a[great] &gt; pivot2) {                        if (great-- == k) {                            break outer;                        }                    }                    // a[great] &lt;= pivot2                    if (a[great] &lt; pivot1) {                         a[k] = a[less];                        a[less] = a[great];                        ++less;                    } else { // pivot1 &lt;= a[great] &lt;= pivot2                        a[k] = a[great];                    }                    /*                     * Here and below we use "a[i] = b; i--;" instead                     * of "a[i--] = b;" due to performance issue.                     */                    a[great] = ak;                    --great;                }            }            // 交换他们最后的下标            a[left]  = a[less  - 1]; a[less  - 1] = pivot1;            a[right] = a[great + 1]; a[great + 1] = pivot2;            // 递归地对左右两部分进行排序，排除已知的支点。            sort(a, left, less - 2, leftmost);            sort(a, great + 2, right, false);            /*             * If center part is too large (comprises &gt; 4/7 of the array),             * swap internal pivot values to ends.             * 如果中心区域太大，超过数组长度的 4/7。就先进行预处理，再参与递归排序。             * 预处理的方法是把等于pivot1的元素统一放到左边，等于pivot2的元素统一             * 放到右边,最终产生一个不包含pivot1和pivot2的数列，再拿去参与快排中的递归。             */            if (less &lt; e1 &amp;&amp; e5 &lt; great) {                /*                 * 跳过等于枢轴值的元素。                 */                while (a[less] == pivot1) {                    ++less;                }                while (a[great] == pivot2) {                    --great;                }                /*                 * Partitioning:                 *                 *   left part         center part                  right part                 * +----------------------------------------------------------+                 * | == pivot1 |  pivot1 &lt; &amp;&amp; &lt; pivot2  |    ?    | == pivot2 |                 * +----------------------------------------------------------+                 *              ^                        ^       ^                 *              |                        |       |                 *             less                      k     great                 *                 * Invariants:                 *                 *              all in (*,  less) == pivot1                 *     pivot1 &lt; all in [less,  k)  &lt; pivot2                 *              all in (great, *) == pivot2                 *                 * Pointer k is the first index of ?-part.                 */                outer:                for (int k = less - 1; ++k &lt;= great; ) {                    int ak = a[k];                    if (ak == pivot1) { // Move a[k] to left part                        a[k] = a[less];                        a[less] = ak;                        ++less;                    } else if (ak == pivot2) { // Move a[k] to right part                        while (a[great] == pivot2) {                            if (great-- == k) {                                break outer;                            }                        }                        if (a[great] == pivot1) { // a[great] &lt; pivot2                            a[k] = a[less];                            /*                             * 尽管a[great]等于pivot1，但如果a[great]和                             * pivot1是不同符号的浮点零点，那么a[less]=pivot1                             * 的赋值可能是错误的。因此在浮点数和双数排序方法中，                             * 我们必须使用更准确的赋值a[less] = a[great]。                             */                            a[less] = pivot1;                            ++less;                        } else { // pivot1 &lt; a[great] &lt; pivot2                            a[k] = a[great];                        }                        a[great] = ak;                        --great;                    }                }            }            // 中心部分递归排序            sort(a, less, great, false);        } else { // 用一个枢轴进行分区            /*             * 使用五个排序元素中的第三个作为中枢。* 这个值是中位数的廉价近似值。             */            int pivot = a[e3];            /*             * Partitioning degenerates to the traditional 3-way             * (or "Dutch National Flag") schema:             *             *   left part    center part              right part             * +-------------------------------------------------+             * |  &lt; pivot  |   == pivot   |     ?    |  &gt; pivot  |             * +-------------------------------------------------+             *              ^              ^        ^             *              |              |        |             *             less            k      great             *             * Invariants:             *             *   all in (left, less)   &lt; pivot             *   all in [less, k)     == pivot             *   all in (great, right) &gt; pivot             *             * Pointer k is the first index of ?-part.             */            for (int k = less; k &lt;= great; ++k) {                if (a[k] == pivot) {                    continue;                }                int ak = a[k];                if (ak &lt; pivot) { // Move a[k] to left part                    a[k] = a[less];                    a[less] = ak;                    ++less;                } else { // a[k] &gt; pivot - Move a[k] to right part                    while (a[great] &gt; pivot) {                        --great;                    }                    if (a[great] &lt; pivot) { // a[great] &lt;= pivot                        a[k] = a[less];                        a[less] = a[great];                        ++less;                    } else { // a[great] == pivot                        /*                         * 尽管a[great]等于pivot，但如果a[great]和pivot是不同符号                         * 的浮点零点，那么a[k]=pivot的赋值可能是错误的。因此在浮点数                         * 和双数排序方法中，我们必须使用更准确的赋值a[k] = a[great]。                         */                        a[k] = pivot;                    }                    a[great] = ak;                    --great;                }            }            /*             * 左右部分递归排序。从中心部分开始的所有元素都是相等的，因此，已经进行了排序。             */            sort(a, left, less - 1, leftmost);            sort(a, great + 1, right, false);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="学习参考："><a href="#学习参考：" class="headerlink" title="学习参考："></a>学习参考：</h2><ol><li><a href="https://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80/%E7%AE%97%E6%B3%95%20-%20%E6%8E%92%E5%BA%8F.html#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F">算法-排序</a></li><li><a href="https://www.cnblogs.com/chengxiao/p/6104371.html">图解排序算法(二)之希尔排序</a></li><li><a href="https://www.cnblogs.com/chengxiao/p/6194356.html">图解排序算法(四)之归并排序</a></li><li><a href="https://www.cnblogs.com/ningvsban/p/3789479.html">自底向上的归并排序</a></li><li><a href="https://www.cnblogs.com/chengxiao/p/6262208.html">图解排序算法(五)之快速排序——三数取中法</a></li><li><a href="https://www.cnblogs.com/chengxiao/p/6129630.html">图解排序算法(三)之堆排序</a></li><li><a href="https://blog.csdn.net/weixin_41552752/article/details/90410749?spm=1001.2014.3001.5501">常用算法稳定性分析</a></li><li><a href="https://www.cnblogs.com/dion-90/articles/8547688.html">常用排序算法稳定性、时间复杂度分析</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客优化</title>
      <link href="/posts/27992.html"/>
      <url>/posts/27992.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文参考<a href="https://fenghen0918.github.io/2020/06/18/hexo/hexo-github-da-jian-matery-bo-ke-er-zhu-ti-pei-zhi-pian/#toc-heading-17">Hexo+github搭建matery博客二（主题配置篇）</a></p></blockquote><h2 id="更改主题的默认配置"><a href="#更改主题的默认配置" class="headerlink" title="更改主题的默认配置"></a>更改主题的默认配置</h2><h3 id="增加红心"><a href="#增加红心" class="headerlink" title="增加红心"></a>增加红心</h3><p>打开<code>themes\matery\layout\_partial/header.ejs</code>文件，增加：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在需要红心的地方添加以下代码：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>i</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>heartbeat<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>fa fas fa-heartbeat<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>i</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="修改页脚"><a href="#修改页脚" class="headerlink" title="修改页脚"></a>修改页脚</h3><p>打开<code>themes\matery\layout\_partial/footer.ejs</code>文件，修改成自己想要的样式：</p><pre class="line-numbers language-ejs" data-language="ejs"><code class="language-ejs">Copyright&amp;nbsp;&amp;copy;&lt;% if (theme.time.year !== new Date().getFullYear()) { %&gt;&lt;span id="year"&gt;&lt;%- theme.time.year %&gt;-&lt;%- new Date().getFullYear() %&gt;&lt;/span&gt;&lt;% } else { %&gt;&lt;span id="year"&gt;&lt;%- theme.time.year %&gt;&lt;/span&gt;&lt;% } %&gt;&lt;span id="year"&gt;&lt;%- theme.time.year %&gt;&lt;/span&gt;&lt;i id="heartbeat" class="fa fas fa-heartbeat"&gt;&lt;/i&gt;&amp;nbsp;&lt;a href="&lt;%- url_for('/about') %&gt;" target="_blank"&gt;&lt;%- config.title %&gt;&lt;/a&gt;&lt;br&gt;欢迎访问我的博客！&lt;br&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210609181455329.png" alt="页脚效果图"></p><h3 id="修改打赏二维码"><a href="#修改打赏二维码" class="headerlink" title="修改打赏二维码"></a>修改打赏二维码</h3><p>在主题文件的<code>source/medias/reward</code>文件中，替换成自己的支付宝和微信二维码即可。</p><h3 id="修改社交链接"><a href="#修改社交链接" class="headerlink" title="修改社交链接"></a>修改社交链接</h3><p>打开主题的<code>_config.yml</code>文件，找到<code>socialLink</code>，按自己的意愿修改代码：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"># 首页 banner 中的第二行个人信息配置，留空即不启用socialLink:  github:  https://github.com/sehowyoung  email: howyoung525@foxmail.com  facebook: # https://www.facebook.com/xxx  twitter: # https://twitter.com/xxx  qq: 846614051  weibo: # https://weibo.com/xxx  zhihu: # https://www.zhihu.com/xxx  rss: false # true、false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="鼠标点击增加特效"><a href="#鼠标点击增加特效" class="headerlink" title="鼠标点击增加特效"></a>鼠标点击增加特效</h3><h4 id="增加文字特效"><a href="#增加文字特效" class="headerlink" title="增加文字特效"></a>增加文字特效</h4><p>在<code>themes/matery/layout/layout.ejs</code>中，在最后增加代码如下：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span><span class="token operator">&gt;</span>    <span class="token keyword">var</span> a_idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">jQuery</span><span class="token punctuation">(</span>document<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ready</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">$</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"body"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token string">"富强"</span><span class="token punctuation">,</span> <span class="token string">"民主"</span><span class="token punctuation">,</span> <span class="token string">"文明"</span><span class="token punctuation">,</span> <span class="token string">"和谐"</span><span class="token punctuation">,</span> <span class="token string">"自由"</span><span class="token punctuation">,</span> <span class="token string">"平等"</span><span class="token punctuation">,</span> <span class="token string">"公正"</span><span class="token punctuation">,</span> <span class="token string">"法治"</span><span class="token punctuation">,</span> <span class="token string">"爱国"</span><span class="token punctuation">,</span> <span class="token string">"敬业"</span><span class="token punctuation">,</span> <span class="token string">"诚信"</span><span class="token punctuation">,</span>                              <span class="token string">"友善"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">var</span> $i <span class="token operator">=</span> <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"&lt;span/&gt;"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">text</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>a_idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            a_idx <span class="token operator">=</span> <span class="token punctuation">(</span>a_idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> a<span class="token punctuation">.</span>length<span class="token punctuation">;</span>            <span class="token keyword">var</span> x <span class="token operator">=</span> e<span class="token punctuation">.</span>pageX<span class="token punctuation">,</span>                y <span class="token operator">=</span> e<span class="token punctuation">.</span>pageY<span class="token punctuation">;</span>            $i<span class="token punctuation">.</span><span class="token function">css</span><span class="token punctuation">(</span><span class="token punctuation">{</span>                <span class="token string">"z-index"</span><span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">,</span>                <span class="token string">"top"</span><span class="token operator">:</span> y <span class="token operator">-</span> <span class="token number">20</span><span class="token punctuation">,</span>                <span class="token string">"left"</span><span class="token operator">:</span> x<span class="token punctuation">,</span>                <span class="token string">"position"</span><span class="token operator">:</span> <span class="token string">"absolute"</span><span class="token punctuation">,</span>                <span class="token string">"font-weight"</span><span class="token operator">:</span> <span class="token string">"bold"</span><span class="token punctuation">,</span>                <span class="token string">"color"</span><span class="token operator">:</span> <span class="token string">"#FF0000"</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"body"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>$i<span class="token punctuation">)</span><span class="token punctuation">;</span>            $i<span class="token punctuation">.</span><span class="token function">animate</span><span class="token punctuation">(</span><span class="token punctuation">{</span>                <span class="token string">"top"</span><span class="token operator">:</span> y <span class="token operator">-</span> <span class="token number">180</span><span class="token punctuation">,</span>                <span class="token string">"opacity"</span><span class="token operator">:</span> <span class="token number">0</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>                       <span class="token number">3000</span><span class="token punctuation">,</span>                       <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                $i<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token string">'delay()'</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">function</span> <span class="token function">delay</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">".buryit"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">removeAttr</span><span class="token punctuation">(</span><span class="token string">"onclick"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="增加爱心特效"><a href="#增加爱心特效" class="headerlink" title="增加爱心特效"></a>增加爱心特效</h4><p>在主题的<code>_config.yml</code>文件中，将<code>clicklove.enable</code>设为<code>true</code></p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">clicklove:  enable: true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210609184055104.png" alt="特效示例"></p><h3 id="动态背景科技线条"><a href="#动态背景科技线条" class="headerlink" title="动态背景科技线条"></a>动态背景科技线条</h3><p>在<code>themes/matery/layout/layout.ejs</code>文件中添加如下代码：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span> color<span class="token operator">=</span><span class="token string">"122 103 238"</span> opacity<span class="token operator">=</span><span class="token string">'0.7'</span> zIndex<span class="token operator">=</span><span class="token string">"-2"</span> count<span class="token operator">=</span><span class="token string">"200"</span>src<span class="token operator">=</span><span class="token string">"//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210609184730213.png" alt="科技线特效"></p><h3 id="页面获取标题"><a href="#页面获取标题" class="headerlink" title="页面获取标题"></a>页面获取标题</h3><p>让每个页面有不同的标题</p><p>修改<code>themes\matery\layout\_partial</code>中的<code>bg-cover-content.ejs</code>文件，将第四行的div标签换为：</p><pre class="line-numbers language-ejs" data-language="ejs"><code class="language-ejs">&lt;div class="title center-align"&gt;     &lt;% if (is_home() &amp;&amp; config.subtitle &amp;&amp; config.subtitle.length &gt; 0) { %&gt;        &lt;%= config.subtitle %&gt;     &lt;% } else { %&gt;        &lt;%= page.title %&gt;     &lt;% } %&gt;&lt;/div&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><font color="red">这个有一点bug，归档页面标题无法显示，解决办法目前还没有。</font><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210609190045015.png" alt="效果图" style="zoom: 50%;"></p><h3 id="打字机效果"><a href="#打字机效果" class="headerlink" title="打字机效果"></a>打字机效果</h3><p>在主题配置文件中，按自己的心意进行配置subtitle</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"># 打字效果副标题.# 如果有符号 ‘ ，请在 ’ 前面加上 \subtitle:  enable: true  loop: true # 是否循环  showCursor: true # 是否显示光标  startDelay: 300 # 开始延迟  typeSpeed: 130 # 打字速度  backSpeed: 70 # 删除速度  sub1: 从来没有真正的绝境, 只有心灵的迷途  sub2: 即使爬到最高的山上，一次也只能脚踏实地地迈一步<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/sehowyoung/images/raw/master/%E6%89%93%E5%AD%97%E6%9C%BA%E6%95%88%E6%9E%9C%E5%9B%BE.gif" alt="打字机效果图"></p><h2 id="博客优化"><a href="#博客优化" class="headerlink" title="博客优化"></a>博客优化</h2><h3 id="gulp代码压缩"><a href="#gulp代码压缩" class="headerlink" title="gulp代码压缩"></a>gulp代码压缩</h3><blockquote><p>hexo生成的html、css、js等都有很多的空格或者换行，而空格和换行也是占用字节的，所以需要将空格换行去掉也就是我要进行的“压缩”，减小一点资源文件的大小也是对访问速度有那么一点提升的。</p></blockquote><p>在站点目录执行以下命令，安装插件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 全局安装gulp模块npm install gulp -g# 安装各种小功能模块  执行这步的时候，可能会提示权限的问题，最好以管理员模式执行npm install gulp gulp-htmlclean gulp-htmlmin gulp-minify-css gulp-uglify gulp-imagemin --save# 额外的功能模块npm install gulp-debug gulp-clean-css gulp-changed gulp-if gulp-plumber gulp-babel babel-preset-es2015 del @babel/core --save<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在Hexo根目录新建文件 gulpfile.js，并复制以下内容到文件中，有中文注释，可以根据自己需求修改。（注意：文件名不能错，一定为gulpfile.js，否则会出错！）</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> gulp <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"gulp"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> debug <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"gulp-debug"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> cleancss <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"gulp-clean-css"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//css压缩组件</span><span class="token keyword">var</span> uglify <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"gulp-uglify"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//js压缩组件</span><span class="token keyword">var</span> htmlmin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"gulp-htmlmin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//html压缩组件</span><span class="token keyword">var</span> htmlclean <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"gulp-htmlclean"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//html清理组件</span><span class="token keyword">var</span> imagemin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"gulp-imagemin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//图片压缩组件</span><span class="token keyword">var</span> changed <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"gulp-changed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//文件更改校验组件</span><span class="token keyword">var</span> gulpif <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"gulp-if"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//任务 帮助调用组件</span><span class="token keyword">var</span> plumber <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"gulp-plumber"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//容错组件（发生错误不跳出任务，并报出错误内容）</span><span class="token keyword">var</span> isScriptAll <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">//是否处理所有文件，(true|处理所有文件)(false|只处理有更改的文件)</span><span class="token keyword">var</span> isDebug <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">//是否调试显示 编译通过的文件</span><span class="token keyword">var</span> gulpBabel <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"gulp-babel"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> es2015Preset <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"babel-preset-es2015"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> del <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"del"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> Hexo <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"hexo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> hexo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Hexo</span><span class="token punctuation">(</span>process<span class="token punctuation">.</span><span class="token function">cwd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 初始化一个hexo对象</span><span class="token comment">// 清除public文件夹</span>gulp<span class="token punctuation">.</span><span class="token function">task</span><span class="token punctuation">(</span><span class="token string">"clean"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">del</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"public/**/*"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 下面几个跟hexo有关的操作，主要通过hexo.call()去执行，注意return</span><span class="token comment">// 创建静态页面 （等同 hexo generate）</span>gulp<span class="token punctuation">.</span><span class="token function">task</span><span class="token punctuation">(</span><span class="token string">"generate"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> hexo<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">hexo</span>            <span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">"generate"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>                watch<span class="token operator">:</span> <span class="token boolean">false</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> hexo<span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> hexo<span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 启动Hexo服务器</span>gulp<span class="token punctuation">.</span><span class="token function">task</span><span class="token punctuation">(</span><span class="token string">"server"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> hexo        <span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token function">hexo</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">"server"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 部署到服务器</span>gulp<span class="token punctuation">.</span><span class="token function">task</span><span class="token punctuation">(</span><span class="token string">"deploy"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> hexo<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">hexo</span>            <span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">"deploy"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>                watch<span class="token operator">:</span> <span class="token boolean">false</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> hexo<span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> hexo<span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 压缩public目录下的js文件</span>gulp<span class="token punctuation">.</span><span class="token function">task</span><span class="token punctuation">(</span><span class="token string">"compressJs"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> gulp        <span class="token punctuation">.</span><span class="token function">src</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"./public/**/*.js"</span><span class="token punctuation">,</span> <span class="token string">"!./public/libs/**"</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">//排除的js</span>        <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span><span class="token function">gulpif</span><span class="token punctuation">(</span><span class="token operator">!</span>isScriptAll<span class="token punctuation">,</span> <span class="token function">changed</span><span class="token punctuation">(</span><span class="token string">"./public"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span><span class="token function">gulpif</span><span class="token punctuation">(</span>isDebug<span class="token punctuation">,</span> <span class="token function">debug</span><span class="token punctuation">(</span><span class="token punctuation">{</span> title<span class="token operator">:</span> <span class="token string">"Compress JS:"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span><span class="token function">plumber</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>            <span class="token function">gulpBabel</span><span class="token punctuation">(</span><span class="token punctuation">{</span>                presets<span class="token operator">:</span> <span class="token punctuation">[</span>es2015Preset<span class="token punctuation">]</span> <span class="token comment">// es5检查机制</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span><span class="token function">uglify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//调用压缩组件方法uglify(),对合并的文件进行压缩</span>        <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>gulp<span class="token punctuation">.</span><span class="token function">dest</span><span class="token punctuation">(</span><span class="token string">"./public"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//输出到目标目录</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 压缩public目录下的css文件</span>gulp<span class="token punctuation">.</span><span class="token function">task</span><span class="token punctuation">(</span><span class="token string">"compressCss"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> option <span class="token operator">=</span> <span class="token punctuation">{</span>        rebase<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>        <span class="token comment">//advanced: true, //类型：Boolean 默认：true [是否开启高级优化（合并选择器等）]</span>        compatibility<span class="token operator">:</span> <span class="token string">"ie7"</span> <span class="token comment">//保留ie7及以下兼容写法 类型：String 默认：''or'*' [启用兼容模式； 'ie7'：IE7兼容模式，'ie8'：IE8兼容模式，'*'：IE9+兼容模式]</span>        <span class="token comment">//keepBreaks: true, //类型：Boolean 默认：false [是否保留换行]</span>        <span class="token comment">//keepSpecialComments: '*' //保留所有特殊前缀 当你用autoprefixer生成的浏览器前缀，如果不加这个参数，有可能将会删除你的部分前缀</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> gulp        <span class="token punctuation">.</span><span class="token function">src</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"./public/**/*.css"</span><span class="token punctuation">,</span> <span class="token string">"!./public/**/*.min.css"</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">//排除的css</span>        <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span><span class="token function">gulpif</span><span class="token punctuation">(</span><span class="token operator">!</span>isScriptAll<span class="token punctuation">,</span> <span class="token function">changed</span><span class="token punctuation">(</span><span class="token string">"./public"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span><span class="token function">gulpif</span><span class="token punctuation">(</span>isDebug<span class="token punctuation">,</span> <span class="token function">debug</span><span class="token punctuation">(</span><span class="token punctuation">{</span> title<span class="token operator">:</span> <span class="token string">"Compress CSS:"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span><span class="token function">plumber</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span><span class="token function">cleancss</span><span class="token punctuation">(</span>option<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>gulp<span class="token punctuation">.</span><span class="token function">dest</span><span class="token punctuation">(</span><span class="token string">"./public"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 压缩public目录下的html文件</span>gulp<span class="token punctuation">.</span><span class="token function">task</span><span class="token punctuation">(</span><span class="token string">"compressHtml"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> cleanOptions <span class="token operator">=</span> <span class="token punctuation">{</span>        protect<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">&lt;\!--%fooTemplate\b.*?%--&gt;</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">,</span> <span class="token comment">//忽略处理</span>        unprotect<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">&lt;script [^&gt;]*\btype="text\/x-handlebars-template"[\s\S]+?&lt;\/script&gt;</span><span class="token regex-delimiter">/</span><span class="token regex-flags">gi</span></span> <span class="token comment">//特殊处理</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> minOption <span class="token operator">=</span> <span class="token punctuation">{</span>        collapseWhitespace<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">//压缩HTML</span>        collapseBooleanAttributes<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">//省略布尔属性的值 &lt;input checked="true"/&gt; ==&gt; &lt;input /&gt;</span>        removeEmptyAttributes<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">//删除所有空格作属性值 &lt;input id="" /&gt; ==&gt; &lt;input /&gt;</span>        removeScriptTypeAttributes<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">//删除&lt;script&gt;的type="text/javascript"</span>        removeStyleLinkTypeAttributes<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">//删除&lt;style&gt;和&lt;link&gt;的type="text/css"</span>        removeComments<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">//清除HTML注释</span>        minifyJS<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">//压缩页面JS</span>        minifyCSS<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">//压缩页面CSS</span>        minifyURLs<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token comment">//替换页面URL</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> gulp        <span class="token punctuation">.</span><span class="token function">src</span><span class="token punctuation">(</span><span class="token string">"./public/**/*.html"</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span><span class="token function">gulpif</span><span class="token punctuation">(</span>isDebug<span class="token punctuation">,</span> <span class="token function">debug</span><span class="token punctuation">(</span><span class="token punctuation">{</span> title<span class="token operator">:</span> <span class="token string">"Compress HTML:"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span><span class="token function">plumber</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span><span class="token function">htmlclean</span><span class="token punctuation">(</span>cleanOptions<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span><span class="token function">htmlmin</span><span class="token punctuation">(</span>minOption<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>gulp<span class="token punctuation">.</span><span class="token function">dest</span><span class="token punctuation">(</span><span class="token string">"./public"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 压缩 public/medias 目录内图片</span>gulp<span class="token punctuation">.</span><span class="token function">task</span><span class="token punctuation">(</span><span class="token string">"compressImage"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> option <span class="token operator">=</span> <span class="token punctuation">{</span>        optimizationLevel<span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token comment">//类型：Number 默认：3 取值范围：0-7（优化等级）</span>        progressive<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">//类型：Boolean 默认：false 无损压缩jpg图片</span>        interlaced<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token comment">//类型：Boolean 默认：false 隔行扫描gif进行渲染</span>        multipass<span class="token operator">:</span> <span class="token boolean">false</span> <span class="token comment">//类型：Boolean 默认：false 多次优化svg直到完全优化</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> gulp        <span class="token punctuation">.</span><span class="token function">src</span><span class="token punctuation">(</span><span class="token string">"./public/medias/**/*.*"</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span><span class="token function">gulpif</span><span class="token punctuation">(</span><span class="token operator">!</span>isScriptAll<span class="token punctuation">,</span> <span class="token function">changed</span><span class="token punctuation">(</span><span class="token string">"./public/medias"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span><span class="token function">gulpif</span><span class="token punctuation">(</span>isDebug<span class="token punctuation">,</span> <span class="token function">debug</span><span class="token punctuation">(</span><span class="token punctuation">{</span> title<span class="token operator">:</span> <span class="token string">"Compress Images:"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span><span class="token function">plumber</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span><span class="token function">imagemin</span><span class="token punctuation">(</span>option<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>gulp<span class="token punctuation">.</span><span class="token function">dest</span><span class="token punctuation">(</span><span class="token string">"./public"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 执行顺序： 清除public目录 -&gt; 产生原始博客内容 -&gt; 执行压缩混淆 -&gt; 部署到服务器</span>gulp<span class="token punctuation">.</span><span class="token function">task</span><span class="token punctuation">(</span>    <span class="token string">"build"</span><span class="token punctuation">,</span>    gulp<span class="token punctuation">.</span><span class="token function">series</span><span class="token punctuation">(</span>        <span class="token string">"clean"</span><span class="token punctuation">,</span>        <span class="token string">"generate"</span><span class="token punctuation">,</span>        <span class="token string">"compressHtml"</span><span class="token punctuation">,</span>        <span class="token string">"compressCss"</span><span class="token punctuation">,</span>        <span class="token string">"compressJs"</span><span class="token punctuation">,</span>        gulp<span class="token punctuation">.</span><span class="token function">parallel</span><span class="token punctuation">(</span><span class="token string">"deploy"</span><span class="token punctuation">)</span>    <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 默认任务</span>gulp<span class="token punctuation">.</span><span class="token function">task</span><span class="token punctuation">(</span>    <span class="token string">"default"</span><span class="token punctuation">,</span>    gulp<span class="token punctuation">.</span><span class="token function">series</span><span class="token punctuation">(</span>        <span class="token string">"clean"</span><span class="token punctuation">,</span>        <span class="token string">"generate"</span><span class="token punctuation">,</span>        gulp<span class="token punctuation">.</span><span class="token function">parallel</span><span class="token punctuation">(</span><span class="token string">"compressHtml"</span><span class="token punctuation">,</span> <span class="token string">"compressCss"</span><span class="token punctuation">,</span> <span class="token string">"compressJs"</span><span class="token punctuation">)</span>    <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//Gulp4最大的一个改变就是gulp.task函数现在只支持两个参数，分别是任务名和运行任务的函数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：这里我去掉了图片的压缩，如果想要加上可以在第154行加上 “compressImage”, 和第165行的加上”compressImage” 即可</p></blockquote><p>使用（两种方式）：</p><ul><li>直接在Hexo根目录执行 gulp，这个命令相当于 hexo cl&amp;&amp;hexo g 并且再把代码压缩，再hexo s进行部署即可</li><li>在Hexo根目录执行 gulp build ，这个命令与第1种相比是：在最后又加了个 hexo d ，等于说生成、压缩文件后又帮你自动部署了</li></ul><h3 id="新建文章自动打开本地Markdown编辑器"><a href="#新建文章自动打开本地Markdown编辑器" class="headerlink" title="新建文章自动打开本地Markdown编辑器"></a>新建文章自动打开本地Markdown编辑器</h3><blockquote><p>写新文章时，需要控制台执行hexo new “文章名字”生成一篇新文章，但需要手动打开，挺麻烦，我们可以设置在生成之后自动打开</p></blockquote><p>在站点根目录下新建scripts目录，然后在新建<code>auto_open.js</code>，在文件填入一下内容：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> spawn <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'child_process'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>exec<span class="token punctuation">;</span><span class="token comment">// Hexo 2.x 用户复制这段</span><span class="token comment">//hexo.on('new', function(path){</span>  <span class="token comment">//spawn('start  "markdown编辑器绝对路径.exe" ' + path);</span><span class="token comment">//});</span><span class="token comment">// Hexo 3 用户复制这段</span>hexo<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'new'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token function">spawn</span><span class="token punctuation">(</span><span class="token string">'start  "D:\program\typora\Typora\Typora.exe" '</span> <span class="token operator">+</span> data<span class="token punctuation">.</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>其中”D:\program\typora\Typora\Typora.exe”是我本地编辑器的路径，只需要改为你本地编辑器的路径即可，然后在执行<code>hexo cl &amp;&amp; hexo g -d</code>，部署到GitHub即可，以后在发布文章就会自动打开编辑器。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为使用matery主题的hexo增加Valine评论系统</title>
      <link href="/posts/16606.html"/>
      <url>/posts/16606.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文参考<a href="https://fenghen0918.github.io/2020/06/19/hexo/matery-zhu-ti-valine-ping-lun-xi-tong/">matery主题+Valine评论系统</a></p></blockquote><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>上篇博客讲述了如何对hexo+GitHub的博客系统进行一些配置，由于配置评论系统较为复杂，故单独写本篇博客来记录如何为使用matery主题的hexo博客系统增加评论系统</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>由于本站博客系统使用的是<a href="https://console.leancloud.cn/">LeanCloud</a>提供的，因此先打开官网进行<a href="https://leancloud.cn/dashboard/login.html#/signup">注册</a>。</p><p>注册完成后直接选择创建应用，应用名称随便填，方案选择开发版，点击创建即可。</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210609162216842.png" alt="创建应用"></p><p>创建完成后，点击设置</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210609162337837.png" alt="进入设置"></p><p>我们需要用到AppID和AppKey。</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210609162431565.png" alt="获取AppID和AppKey"></p><h2 id="配置评论系统"><a href="#配置评论系统" class="headerlink" title="配置评论系统"></a>配置评论系统</h2><p>在matery主题的配置文件<code>_config.yml</code>中，创建Valine属性：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"># Valine 评论模块的配置，默认为不激活，如要使用，就请激活该配置项，并设置 appId 和 appKey.valine:  enable: true   appId: 你的AppID  appKey: 你的AppKey  pageSize: 10                # 每页显示条数  avatar: monsterid           # 默认头像  lang: zh-CN   placeholder: 昵称填写qq可以显示qq头像和昵称哦~   # 提示信息  guest_info: nick,mail,link   recordIP: true   serverURLs: ''   background: /medias/comment_bg.png               # 背景图片  count: true <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="管理评论"><a href="#管理评论" class="headerlink" title="管理评论"></a>管理评论</h2><p>进入<a href="https://console.leancloud.cn/apps">LeanCloud</a>，点击<code>数据存储</code>，选择<code>Comment</code>，然后你就可以操作数据了</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/%E5%88%A0%E9%99%A4%E8%AF%84%E8%AE%BA.gif" alt="删除评论"></p><h2 id="增强Valine系统"><a href="#增强Valine系统" class="headerlink" title="增强Valine系统"></a>增强Valine系统</h2><h3 id="更换Valine的版本"><a href="#更换Valine的版本" class="headerlink" title="更换Valine的版本"></a>更换Valine的版本</h3><p>在matery配置页面，找到libs.js.valine，将其设置为<code>valine: https://unpkg.com/valine/dist/Valine.min.js</code></p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210609164616769.png" alt="更改valine的版本"></p><h3 id="更换表情"><a href="#更换表情" class="headerlink" title="更换表情"></a>更换表情</h3><p>打开<code>themes\matery\layout\_partial</code>中找到<code>valine.ejs</code>，找到其中的<code>new Valine</code>，大概在249行，修改为以下内容：</p><pre class="line-numbers language-ejs" data-language="ejs"><code class="language-ejs">new Valine({        el: '#vcomments',        appId: '&lt;%- theme.valine.appId %&gt;',        appKey: '&lt;%- theme.valine.appKey %&gt;',        notify: '&lt;%- theme.valine.notify %&gt;' === 'true',        verify: '&lt;%- theme.valine.verify %&gt;' === 'true',        visitor: '&lt;%- theme.valine.visitor %&gt;' === 'true',        avatar: '&lt;%- theme.valine.avatar %&gt;',        pageSize: '&lt;%- theme.valine.pageSize %&gt;',        lang: '&lt;% if (config.language == "zh-CN") {  %&gt;zh-cn&lt;% } else { %&gt;en&lt;% } %&gt;',        placeholder: '&lt;%= theme.valine.placeholder %&gt;',        enableQQ: true,        emojiCDN: '//i0.hdslb.com/bfs/emote/',         // 表情title和图片映射        emojiMaps: {        "tv_doge": "6ea59c827c414b4a2955fe79e0f6fd3dcd515e24.png",        "tv_亲亲": "a8111ad55953ef5e3be3327ef94eb4a39d535d06.png",        "tv_偷笑": "bb690d4107620f1c15cff29509db529a73aee261.png",        "tv_再见": "180129b8ea851044ce71caf55cc8ce44bd4a4fc8.png",        "tv_冷漠": "b9cbc755c2b3ee43be07ca13de84e5b699a3f101.png",        "tv_发怒": "34ba3cd204d5b05fec70ce08fa9fa0dd612409ff.png",        "tv_发财": "34db290afd2963723c6eb3c4560667db7253a21a.png",        "tv_可爱": "9e55fd9b500ac4b96613539f1ce2f9499e314ed9.png",        "tv_吐血": "09dd16a7aa59b77baa1155d47484409624470c77.png",        "tv_呆": "fe1179ebaa191569b0d31cecafe7a2cd1c951c9d.png",        "tv_呕吐": "9f996894a39e282ccf5e66856af49483f81870f3.png",        "tv_困": "241ee304e44c0af029adceb294399391e4737ef2.png",        "tv_坏笑": "1f0b87f731a671079842116e0991c91c2c88645a.png",        "tv_大佬": "093c1e2c490161aca397afc45573c877cdead616.png",        "tv_大哭": "23269aeb35f99daee28dda129676f6e9ea87934f.png",        "tv_委屈": "d04dba7b5465779e9755d2ab6f0a897b9b33bb77.png",        "tv_害羞": "a37683fb5642fa3ddfc7f4e5525fd13e42a2bdb1.png",        "tv_尴尬": "7cfa62dafc59798a3d3fb262d421eeeff166cfa4.png",        "tv_微笑": "70dc5c7b56f93eb61bddba11e28fb1d18fddcd4c.png",        "tv_思考": "90cf159733e558137ed20aa04d09964436f618a1.png",        "tv_惊吓": "0d15c7e2ee58e935adc6a7193ee042388adc22af.png",        "tv_打脸": "56ab10b624063e966bfcb76ea5dc4794d87dfd47.png",        "tv_抓狂": "fe31c08edad661d63762b04e17b8d5ae3c71a757.png",        "tv_抠鼻": "c666f55e88d471e51bbd9fab9bb308110824a6eb.png",        "tv_斜眼笑": "911f987aa8bc1bee12d52aafe62bc41ef4474e6c.png",        "tv_无奈": "ea8ed89ee9878f2fece2dda0ea8a5dbfe21b5751.png",        "tv_晕": "5443c22b4d07fb1907ccc610c8e6db254f2461b7.png",        "tv_流汗": "cead1c351ab8d79e9f369605beb90148db0fbed3.png",        "tv_流泪": "7e71cde7858f0cd50d74b0264aa26db612a8a167.png",        "tv_流鼻血": "c32d39db2737f89b904ca32700d140a9241b0767.png",        "tv_点赞": "f85c354995bd99e28fc76c869bfe42ba6438eff4.png",        "tv_生气": "26702dcafdab5e8225b43ffd23c94ac1ff932654.png",        "tv_生病": "8b0ec90e6b86771092a498c54f09fc94621c1900.png",        "tv_疑问": "0793d949b18d7be716078349c202c15ff166f314.png",        "tv_白眼": "c1d59f439e379ee50eef488bcb5e5378e5044ea4.png",        "tv_皱眉": "72ccad6679fea0d14cce648b4d818e09b8ffea2d.png",        "tv_目瞪口呆": "0b8cb81a68de5d5365212c99375e7ace3e7891b7.png",        "tv_睡着": "8b196675b53af58264f383c50ad0945048290b33.png",        "tv_笑哭": "1abc628f6d4f4caf9d0e7800878f4697abbc8273.png",        "tv_腼腆": "89712c0d4af73e67f89e35cbc518420380a7f6f4.png",        "tv_色": "61822c7e9aae5da76475e7892534545336b23a6f.png",        "tv_调侃": "4bc022533ef31544ca0d72c12c808cf4a1cce3e3.png",        "tv_调皮": "b9c41de8e82dd7a8515ae5e3cb63e898bf245186.png",        "tv_鄙视": "6e72339f346a692a495b123174b49e4e8e781303.png",        "tv_闭嘴": "c9e990da7f6e93975e25fd8b70e2e290aa4086ef.png",        "tv_难过": "87f46748d3f142ebc6586ff58860d0e2fc8263ba.png",        "tv_馋": "fc7e829b845c43c623c8b490ee3602b7f0e76a31.png",        "tv_鬼脸": "0ffbbddf8a94d124ca2f54b360bbc04feb6bbfea.png",        "tv_黑人问号": "45821a01f51bc867da9edbaa2e070410819a95b2.png",        "tv_鼓掌": "1d21793f96ef4e6f48b23e53e3b9e42da833a0f6.png"        },        requiredFields: ['nick','mail'], //设置必填项    });<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重新部署查看</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo clean &amp; hexo g -d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210609165023460.png" alt="评论板块界面"></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo+GitHub个人主页更换主题</title>
      <link href="/posts/38798.html"/>
      <url>/posts/38798.html</url>
      
        <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>上一篇博客我为大家介绍了如何使用hexo+GitHub搭建个人博客，本片我将记录我如何更换hexo的主题matery。</p><h2 id="主题的下载与切换"><a href="#主题的下载与切换" class="headerlink" title="主题的下载与切换"></a>主题的下载与切换</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>hexo主题的官网：<a href="https://hexo.io/themes/">https://hexo.io/themes/</a></p><p>matery主题官网：<a href="https://github.com/blinkfox/hexo-theme-matery">https://github.com/blinkfox/hexo-theme-matery</a></p><p>可以在官网的release里面下载，也可以使用<code>git clone https://github.com/blinkfox/hexo-theme-matery.git</code>下载，将下载的文件夹放到博客文件夹下的themes下。</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210609110153569.png" alt="themes文件夹"></p><h3 id="切换"><a href="#切换" class="headerlink" title="切换"></a>切换</h3><p>在博客文件夹下，打开<code>_config.yml</code>文件，将<code>theme</code>设置为你的主题名字。</p><h2 id="主题的配置"><a href="#主题的配置" class="headerlink" title="主题的配置"></a>主题的配置</h2><h3 id="增加页面"><a href="#增加页面" class="headerlink" title="增加页面"></a>增加页面</h3><p>增加tags标签页、categories分类页、about关于我页面、contact留言板页。</p><h4 id="新建分类-categories-页"><a href="#新建分类-categories-页" class="headerlink" title="新建分类 categories 页"></a>新建分类 categories 页</h4><p><code>categories</code> 页是用来展示所有分类的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>categories/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page "categories"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/categories/index.md</code>，至少需要以下内容：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">---title: categoriesdate: 2021-06-8 17:25:30type: "categories"layout: "categories"---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="新建标签-tags-页"><a href="#新建标签-tags-页" class="headerlink" title="新建标签 tags 页"></a>新建标签 tags 页</h4><p><code>tags</code> 页是用来展示所有标签的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>tags/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page "tags"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/tags/index.md</code>，至少需要以下内容：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">---title: tagsdate: 2021-06-8 17:23:38type: "tags"layout: "tags"---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="新建关于我-about-页"><a href="#新建关于我-about-页" class="headerlink" title="新建关于我 about 页"></a>新建关于我 about 页</h4><p><code>about</code> 页是用来展示<strong>关于我和我的博客</strong>信息的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>about/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page "about"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/about/index.md</code>，至少需要以下内容：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">---title: aboutdate: 2021-06-8 17:25:30type: "about"layout: "about"---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="新建留言板-contact-页"><a href="#新建留言板-contact-页" class="headerlink" title="新建留言板 contact 页"></a>新建留言板 contact 页</h4><p><code>contact</code> 页是用来展示<strong>留言板</strong>信息的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>contact/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page "contact"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/contact/index.md</code>，至少需要以下内容：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">---title: contactdate: 2021-06-8 17:25:30type: "contact"layout: "contact"---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>注</strong>：本留言板功能依赖于第三方评论系统，请<strong>激活</strong>你的评论系统才有效果。并且在主题的 <code>_config.yml</code> 文件中，第 <code>19</code> 至 <code>21</code> 行的“<strong>菜单</strong>”配置，取消关于留言板的注释即可。</p></blockquote><h4 id="新建-404-页"><a href="#新建-404-页" class="headerlink" title="新建 404 页"></a>新建 404 页</h4><p>如果在你的博客 <code>source</code> 目录下还没有 <code>404.md</code> 文件，那么你就需要新建一个</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page 404<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/404/index.md</code>，至少需要以下内容：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">---title: 404date: 2021-06-8 17:25:30type: "404"layout: "404"description: "Oops～，我崩溃了！找不到你想要的页面 :("---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="增加emoji支持"><a href="#增加emoji支持" class="headerlink" title="增加emoji支持"></a>增加emoji支持</h3><p>:smile：使你的markdown博客里的emoji表情跳动起来</p><p>安装插件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm install hexo-filter-github-emojis --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在博客文件夹下增加下面配置：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">githubEmojis:  enable: true  className: github-emoji  inject: true  styles:  customEmojis:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210609113107377.png" alt="emoji表情示例"></p><h3 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h3><p>由于 Hexo 自带的代码高亮主题不好看，所以我们采用一个插件来代替它。</p><p>使用<code>npm i -S hexo-prism-plugin</code>来安装插件</p><p>打开项目文件夹下的<code>_config.yml</code>，将 highlight.enable 的值改为 false ，新增下面的代码。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">prism_plugin:  mode: 'preprocess'    # realtime/preprocess  theme: 'tomorrow'  line_number: false    # default false  custom_css:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="搜索功能"><a href="#搜索功能" class="headerlink" title="搜索功能"></a>搜索功能</h3><p>我们使用 <a href="https://github.com/wzpan/hexo-generator-search">hexo-generator-search</a> 的 Hexo 插件来做内容搜索，安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm install hexo-generator-search --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">search:  path: search.xml  field: post<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="中文链接转拼音"><a href="#中文链接转拼音" class="headerlink" title="中文链接转拼音"></a>中文链接转拼音</h3><p>如果你的文章名称是中文的，那么 Hexo 默认生成的永久链接也会有中文，这样不利于 <code>SEO</code>，且 <code>gitment</code> 评论对中文链接也不支持。我们可以用 <a href="https://github.com/viko16/hexo-permalink-pinyin">hexo-permalink-pinyin</a> Hexo 插件使在生成文章时生成中文拼音的永久链接。</p><p>安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm i hexo-permalink-pinyin --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">permalink_pinyin:  enable: true  separator: '-' # default: '-'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="文章字数统计"><a href="#文章字数统计" class="headerlink" title="文章字数统计"></a>文章字数统计</h3><p>为了在文章中显示文章字数、阅读时长信息，可以安装 <a href="https://github.com/willin/hexo-wordcount">hexo-wordcount</a>插件。</p><p>安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm i --save hexo-wordcount<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后只需在本主题下的 <code>_config.yml</code> 文件中，将各个文章字数相关的配置激活即可：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"># 文章信息--若要开启文章字数统计，需要安装 hexo-wordcount 插件，安装命令: `npm i --save hexo-wordcount`postInfo:  date: true # 发布日期  update: false # 更新日期  wordCount: true # 文章字数统计  totalCount: false # 站点总文章字数  min2read: true # 文章阅读时长  readCount: true # 文章阅读次数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="配置音乐播放器"><a href="#配置音乐播放器" class="headerlink" title="配置音乐播放器"></a>配置音乐播放器</h3><p>要支持音乐播放，在主题的 <code>_config.yml</code> 配置文件中激活music配置即可：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"># 音乐music:  enable: true  title:         # 非吸底模式有效    enable: true    show: 听听音乐放松一下吧  server: netease   # require music platform: netease, tencent, kugou, xiami, baidu  type: playlist    # require song, playlist, album, search, artist  id: 2799574927     # require song id / playlist id / album id / search keyword  fixed: false      # 开启吸底模式  autoplay: true   # 是否自动播放  theme: '#42b983'  loop: 'all'       # 音频循环播放, 可选值: 'all', 'one', 'none'  order: 'random'   # 音频循环顺序, 可选值: 'list', 'random'  preload: 'auto'   # 预加载，可选值: 'none', 'metadata', 'auto'  volume: 0.7       # 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效  listFolded: false  # 列表默认折叠  hideLrc: true     # 隐藏歌词<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>属性介绍：</p><ol><li><p><code>server</code>可选<code>netease</code>（网易云音乐），<code>tencent</code>（QQ音乐），<code>kugou</code>（酷狗音乐），<code>xiami</code>（虾米音乐），<code>baidu</code>（百度音乐）。</p></li><li><p><code>type</code>可选<code>song</code>（歌曲），<code>playlist</code>（歌单），<code>album</code>（专辑），<code>search</code>（搜索关键字），<code>artist</code>（歌手）</p></li><li><p><code>id</code>获取方法示例: 浏览器打开网易云音乐，点击我喜欢的音乐歌单，浏览器地址栏后面会有一串数字，<code>playlist</code>的<code>id</code>即为这串数字。</p></li></ol></blockquote><h3 id="修改公告-dream一栏-里的每日一句"><a href="#修改公告-dream一栏-里的每日一句" class="headerlink" title="修改公告(dream一栏)里的每日一句"></a>修改公告(dream一栏)里的每日一句</h3><p>找到<code>/themes/matery/layout/index.ejs</code>，第17行改为：</p><pre class="line-numbers language-ejs" data-language="ejs"><code class="language-ejs">&lt;% if (theme.dream.enable) { %&gt;  &lt;!-- &lt;%- partial('_widget/dream') %&gt; --&gt;  &lt;i class="fa fa-volume-up fa-lg fa-fw text-color"&gt;&lt;/i&gt; &lt;%- '&lt;span id="hitokoto"&gt;一言API请求超时。请稍后重试。&lt;/span&gt; （来源：一言API）' %&gt;&lt;% } %&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>同时在<code>/themes/matery/layout/_partial/head.ejs</code>增加代码：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"https://v1.hitokoto.cn/?c=d&amp;encode=js&amp;select=%23hitokoto"</span> defer<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+GitHub搭建个人博客</title>
      <link href="/posts/48892.html"/>
      <url>/posts/48892.html</url>
      
        <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>本篇博客技术了如何使用hexo+GitHub搭建个人博客。gitee至今年五月开始休整个人主页，暂时无法搭建。</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><p>git下载地址：<a href="https://git-scm.com/downloads">Git - Downloads (git-scm.com)</a></p><p>验证git是否安装完成：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">git --version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>出现下面的信息即安装完成。</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210608225744230.png" alt="查看git是否安装成功"></p><h3 id="安装node"><a href="#安装node" class="headerlink" title="安装node"></a>安装node</h3><p>node.js下载地址：<a href="https://nodejs.org/zh-cn/download/">下载 | Node.js (nodejs.org)</a></p><p>验证node是否安装成功</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">node -v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>出现下面的信息即代表安装完成：</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210608230136589.png" alt="产看node是否安装成功"></p><h3 id="GitHub仓库"><a href="#GitHub仓库" class="headerlink" title="GitHub仓库"></a>GitHub仓库</h3><p>创建一个GitHub的账号，当然gitee也可以。</p><p>GitHub地址：<a href="https://github.com/">https://github.com/</a></p><p>Gitee地址：<a href="https://gitee.com/">https://gitee.com/</a></p><p>在注册好以后创建一个新仓库</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210609085515819.png" alt="新建仓库"></p><p>仓库名构成为：用户名.github.io</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210609085818668.png" alt="创建仓库"></p><h2 id="安装hexo并且本地运行"><a href="#安装hexo并且本地运行" class="headerlink" title="安装hexo并且本地运行"></a>安装hexo并且本地运行</h2><p>创建一个文件夹，用于存放你的博客</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">//切换到所在磁盘位置e://切换到文件夹位置cd myBlog<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>安装hexo-cli脚手架</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm install -g hexo-cli<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>用<code>hexo -v</code>验证hexo-cli脚手架是否安装完成</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210609090103875.png" alt="查看hexo版本"></p><p>使用<code>hexo init</code>初始化网站，如果报错或者安装不成功，就去<a href="https://github.com/hexojs/hexo-starter">hexojs/hexo-starter(github.com)</a>将代码下载下来，放到你的目录下。</p><p>然后进入网站所在文件夹，执行<code>npm install</code>命令，安装必备的组件。完成安装后，页面结构如图所示</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.├── _config.yml # 网站的配置信息，您可以在此配置大部分的参数。 ├── package.json├── node_modules # 组件所在文件夹├── scaffolds # 模版文件夹├── source  # 资源文件夹，除 _posts 文件，其他以下划线_开头的文件或者文件夹不会被编译打包到public文件夹|   ├── _drafts # 草稿文件|   └── _posts # 文章Markdowm文件 └── themes  # 主题文件夹<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用<code>hexo g</code>即可生成静态网页，可在public里面找到。然后运行<code>hexo s</code>打开本地服务器，就可以查看，这是我更换主题matery后的界面，具体后面会写。</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210609091349215.png" alt="静态主页"></p><h2 id="连接GitHub与本地git"><a href="#连接GitHub与本地git" class="headerlink" title="连接GitHub与本地git"></a>连接GitHub与本地git</h2><h3 id="配置ssh-key"><a href="#配置ssh-key" class="headerlink" title="配置ssh key"></a>配置ssh key</h3><p>右击鼠标，选中<code>Git Bash Here</code>，打开git界面，开始配置ssh key。</p><p>输入<code>ssh-keygen -t rsa -C '你的邮箱'</code></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ssh-keygen -t rsa -C 'howyoung525@foxmail.com'Generating public/private rsa key pair.Enter file in which to save the key (/c/Users/84661/.ssh/id_rsa): 可以在此输入你的文件保存地址，默认为~/.ssh/id_rsa,建议换成~/.ssh/id_rsa.githubEnter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in /c/Users/84661/.ssh/id_rsaYour public key has been saved in /c/Users/84661/.ssh/id_rsa.pubThe key fingerprint is:SHA256:oFnXNTgDePDBcW6j2xp9mTpbheokQ0JjM+3nLvtxqfA howyoung525@foxmail.comThe key's randomart image is:+---[RSA 3072]----+|      .++o..o    ||      .oo=+. .   ||      O.+ =o     ||     * B o . .   ||    o . S . . .  ||       o * . =   ||        * B B    ||        .@.B     ||        o+Eo     |+----[SHA256]-----+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输入命令<code>cat ~/.ssh/id_rsa.github.pub</code>，查看公钥文件，然后选中，右击复制。</p><p>打开你的GitHub，点击右上角头像旁边的倒三角，选择<code>settings</code>，在点击<code>SSH adn GPG keys</code>，点击<code>new</code>，在页面里添加title和key，title可以随意写，key把公钥文件内容粘贴进去即可。</p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://gitee.com/sehowyoung/images/raw/master/%E9%85%8D%E7%BD%AE.gif" alt="git与GitHub连接配置"></h2><h3 id="配置本地账户"><a href="#配置本地账户" class="headerlink" title="配置本地账户"></a>配置本地账户</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">git config --global user.name '你的用户名'git config --global user.email '你的邮箱'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="测试连接"><a href="#测试连接" class="headerlink" title="测试连接"></a>测试连接</h3><p>使用<code>ssh -T git@github.com</code>来测试是否成功，出现下面信息即成功（第一会让输入yes）</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210609094359872.png" alt="测试连接"></p><h2 id="部署到GitHub"><a href="#部署到GitHub" class="headerlink" title="部署到GitHub"></a>部署到GitHub</h2><p>安装插件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm install hexo-deployer-git --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>打开文件夹下面的<code>_config.yml</code>文件，找到最下面的<code>delpoy</code>，修改配置为：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">deploy:  type: git  repository:    github: git@github.com:你的GitHub用户名/用户名.github.io.git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>使用<code>hexo g -d</code>生成静态文件并上传。</p><p>稍等一会，便可以在浏览器访问<code>https://你的用户名.github.io</code>，即可看见你的博客了。</p><p>此外，最好将<code>_config.yml</code>文件最前端的6-12行进行修改：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"># Sitetitle: howyoung's blogsubtitle: howyoung's blogdescription: 'howyoung 的博客'keywords: blog 博客 howyoungauthor: howyounglanguage: zh-CNtimezone: Asia/Shanghaiurl: https://sehowyoung.github.io/per_page: 建议改为6的倍数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
