<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>各种学习资料</title>
      <link href="/posts/15096.html"/>
      <url>/posts/15096.html</url>
      
        <content type="html"><![CDATA[<h1 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h1><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><ol><li>JVM与GC调优课程<br>链接: <a href="https://pan.baidu.com/s/1c6-9bvRIVxdW9F_-U-AxPg">https://pan.baidu.com/s/1c6-9bvRIVxdW9F_-U-AxPg</a> 提取码: s4fr</li><li>Java架构师提升课程<br>链接: <a href="https://pan.baidu.com/s/1LzF5Y38SR_FGqR_0Ei9o6w">https://pan.baidu.com/s/1LzF5Y38SR_FGqR_0Ei9o6w</a> 提取码: scwc</li><li>Java进阶 20210726-高薪必备JVM面试题解惑<br>链接: <a href="https://pan.baidu.com/s/1SBiLLIq8xaupVjfxqpRlhA">https://pan.baidu.com/s/1SBiLLIq8xaupVjfxqpRlhA</a> 提取码: ue69</li><li>《Java高级开发工程师》课程包含六大专题【完整】<br>链接: <a href="https://pan.baidu.com/s/1-DXe6woRplhsmKVqgrfFAg">https://pan.baidu.com/s/1-DXe6woRplhsmKVqgrfFAg</a> 提取码: q19m</li><li>Java高级互联网架构师 1-6班<br>链接: <a href="https://pan.baidu.com/s/1p8I0Lfb3fCdlxZFxU_12iw">https://pan.baidu.com/s/1p8I0Lfb3fCdlxZFxU_12iw</a> 提取码: s985</li><li>互联网Java突击面试（1~3季)<br>链接: <a href="https://pan.baidu.com/s/1V_7C53G_866-wzULn8Ph-g">https://pan.baidu.com/s/1V_7C53G_866-wzULn8Ph-g</a> 提取码: 0w9o</li><li>JAVA架构师微职位：Java集群架构<br>链接: <a href="https://pan.baidu.com/s/1Y_veaniXXQlxpRPAKp8b8g">https://pan.baidu.com/s/1Y_veaniXXQlxpRPAKp8b8g</a> 提取码: 7una</li></ol><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><ol><li>【完结】python金融实务从入门到精通<br>链接: <a href="https://pan.baidu.com/s/1NVAAUc7wu5YpSMktTTc4FA">https://pan.baidu.com/s/1NVAAUc7wu5YpSMktTTc4FA</a> 提取码: 0gzn</li><li>数据蛙第一期就业班<br>链接: <a href="https://pan.baidu.com/s/1COYmEGBvvx-izi_PP7FnTw">https://pan.baidu.com/s/1COYmEGBvvx-izi_PP7FnTw</a> 提取码: knu5</li><li>明明白白学Python<br>链接: <a href="https://pan.baidu.com/s/1V9TD-rfVTsN9Ea1RYd92JQ">https://pan.baidu.com/s/1V9TD-rfVTsN9Ea1RYd92JQ</a> 提取码: 420b</li><li>TensorFlow2.0入门到实践<br>链接: <a href="https://pan.baidu.com/s/1BzKvr4Tj-yHk05nGM8Lkig">https://pan.baidu.com/s/1BzKvr4Tj-yHk05nGM8Lkig</a> 提取码: i057</li></ol><h2 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h2><ol><li>2020新版Go开发工程师完结<br>链接: <a href="https://pan.baidu.com/s/192t-KmfKcDB-e-okqKRoxg">https://pan.baidu.com/s/192t-KmfKcDB-e-okqKRoxg</a> 提取码: u089</li></ol><h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><ol><li>2020年最新 尚硅谷ES6教程<br>链接: <a href="https://pan.baidu.com/s/1u_YQCtJAGGTvZsKULUnAeg">https://pan.baidu.com/s/1u_YQCtJAGGTvZsKULUnAeg</a> 提取码: ixww</li></ol><h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><ol><li>Vue2.0+Vue3.0从入门到精通教程（Kerwin老师主讲）<br>链接: <a href="https://pan.baidu.com/s/1AMN8koyq7k_Rf2sQQEaaYQ">https://pan.baidu.com/s/1AMN8koyq7k_Rf2sQQEaaYQ</a> 提取码: 7791</li></ol><h2 id="Net"><a href="#Net" class="headerlink" title=".Net"></a>.Net</h2><ol><li>.Net Core 开发API<br>链接: <a href="https://pan.baidu.com/s/1gVGN2v2XT-rupHf24pwSsA">https://pan.baidu.com/s/1gVGN2v2XT-rupHf24pwSsA</a> 提取码: 9952</li></ol><h1 id="学习套餐"><a href="#学习套餐" class="headerlink" title="学习套餐"></a>学习套餐</h1><ol><li>李兴华开发合集<br>链接: <a href="https://pan.baidu.com/s/13zM0yn-TjF3Zxo87N4_Zyg">https://pan.baidu.com/s/13zM0yn-TjF3Zxo87N4_Zyg</a> 提取码: 6i4a</li><li>阿里P7开发课程<br>链接: <a href="https://pan.baidu.com/s/1d410AD4O1QkR8LJHwvA9oA">https://pan.baidu.com/s/1d410AD4O1QkR8LJHwvA9oA</a> 提取码: w0qe</li></ol><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><ol><li>黑马程序员 Java设计模式（图解+框架源码分析+实战）【资料完整】<br>链接: <a href="https://pan.baidu.com/s/1vs1zG-qipnN_0D8EjyGxNQ">https://pan.baidu.com/s/1vs1zG-qipnN_0D8EjyGxNQ</a> 提取码: 223c</li></ol><h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><ol><li>JUC并发编程与源码分析课程<br>链接: <a href="https://pan.baidu.com/s/1G8n3MYTiJZfBgvsjpHUtGA">https://pan.baidu.com/s/1G8n3MYTiJZfBgvsjpHUtGA</a> 提取码: kk0s</li></ol><h1 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h1><ol><li>京东数据分析课程<br>链接: <a href="https://pan.baidu.com/s/1H9NUlOZp0cRY-D5_wua0EA">https://pan.baidu.com/s/1H9NUlOZp0cRY-D5_wua0EA</a> 提取码: 51rv</li><li>数据分析全栈大师集训营来啦！<br>链接: <a href="https://pan.baidu.com/s/1bCS22nU2yVhQL5fUFcP3Yw">https://pan.baidu.com/s/1bCS22nU2yVhQL5fUFcP3Yw</a> 提取码: u5j0</li><li>商务数据分析教程<br>链接: <a href="https://pan.baidu.com/s/1BiIgozER2HyOQIM978OYLw">https://pan.baidu.com/s/1BiIgozER2HyOQIM978OYLw</a> 提取码: ae9h</li></ol><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><ol><li>邓俊辉-算法训练营 第二期<br>链接: <a href="https://pan.baidu.com/s/1K2Gcbw2ImW70SmZLHAMvZA">https://pan.baidu.com/s/1K2Gcbw2ImW70SmZLHAMvZA</a> 提取码: 6gm2</li><li>算法基础入门班（第五期）<br>链接: <a href="https://pan.baidu.com/s/1FLsC4xb7ETP76R3E-Rs3-w">https://pan.baidu.com/s/1FLsC4xb7ETP76R3E-Rs3-w</a> 提取码: ber6</li><li>算法基础提升班（第五期）<br>链接: <a href="https://pan.baidu.com/s/1atyHX1UjwgFiTDvp458D3Q">https://pan.baidu.com/s/1atyHX1UjwgFiTDvp458D3Q</a> 提取码: i7p5</li><li>算法高级班（第十一期）<br>链接: <a href="https://pan.baidu.com/s/1gfbAjPrXgrdTAZczm9JrvA">https://pan.baidu.com/s/1gfbAjPrXgrdTAZczm9JrvA</a> 提取码: 52mg</li><li>算法中级班（第十一期）<br>链接: <a href="https://pan.baidu.com/s/1tzF2efcKeNLxqA9nYOD0Gg">https://pan.baidu.com/s/1tzF2efcKeNLxqA9nYOD0Gg</a> 提取码: pdls</li><li>2020年最新 算法直通套餐（中级+高级）<br>链接: <a href="https://pan.baidu.com/s/1LXafedzoLpBB6IM5C8A9UA">https://pan.baidu.com/s/1LXafedzoLpBB6IM5C8A9UA</a> 提取码: h6xa</li><li>牛课班算法<br>链接: <a href="https://pan.baidu.com/s/1LYwyb5vmapk-PGQQfy1D_g">https://pan.baidu.com/s/1LYwyb5vmapk-PGQQfy1D_g</a> 提取码: 9e2b</li><li>算法初级班第4期课程（已完结）<br>链接: <a href="https://pan.baidu.com/s/1y6znDF3bGqf02zgKI7QdFQ">https://pan.baidu.com/s/1y6znDF3bGqf02zgKI7QdFQ</a> 提取码: 833s</li><li>算法进阶班第4期课程（已完结）<br>链接: <a href="https://pan.baidu.com/s/1HY1yfC2Ru8Tl2xRIc2qd0A">https://pan.baidu.com/s/1HY1yfC2Ru8Tl2xRIc2qd0A</a> 提取码: 7y94</li></ol><h1 id="spring系列"><a href="#spring系列" class="headerlink" title="spring系列"></a>spring系列</h1><ol><li>Spring boot源码解析【资料完整】<br>链接: <a href="https://pan.baidu.com/s/1jSEY_MU3e31uNiK-wuB42g">https://pan.baidu.com/s/1jSEY_MU3e31uNiK-wuB42g</a> 提取码: 35mc</li><li>全栈H版本+新增Spring Cloud Alibaba架构实战课程<br>链接: <a href="https://pan.baidu.com/s/1PsDWW2I_dyhhNOh9ayZ6OA">https://pan.baidu.com/s/1PsDWW2I_dyhhNOh9ayZ6OA</a> 提取码: 28m8</li><li>Spring Cloud 亿级账户系统 TCC 分布式事务实战<br>链接: <a href="https://pan.baidu.com/s/1R21zVWlJ_T164X-DjuT72w">https://pan.baidu.com/s/1R21zVWlJ_T164X-DjuT72w</a> 提取码: 2xly</li><li>SpringBoot就业编程实战<br>链接: <a href="https://pan.baidu.com/s/1zZ-UOiuBQeug0Cmwfltncg">https://pan.baidu.com/s/1zZ-UOiuBQeug0Cmwfltncg</a> 提取码: 3o24</li><li>SpringCloud alibaba微服务全家桶<br>链接: <a href="https://pan.baidu.com/s/1PolzltOVwdJvfgXluuZhcQ">https://pan.baidu.com/s/1PolzltOVwdJvfgXluuZhcQ</a> 提取码: ivxr</li><li>分布式事务实践 解决数据 （无秘）<br>链接: <a href="https://pan.baidu.com/s/1eYy7sWBQtiKmszl3Az3B9Q">https://pan.baidu.com/s/1eYy7sWBQtiKmszl3Az3B9Q</a> 提取码: 0d0e</li></ol><h1 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h1><ol><li>大数据机器学习（2019春）<br>链接: <a href="https://pan.baidu.com/s/17zcfRtVZaS6jgXcol41VgA">https://pan.baidu.com/s/17zcfRtVZaS6jgXcol41VgA</a> 提取码: v96e</li><li>大数据HBase-Phoenix技术精讲<br>链接: <a href="https://pan.baidu.com/s/1exdhNlP_1y6NqiERmXpEoQ">https://pan.baidu.com/s/1exdhNlP_1y6NqiERmXpEoQ</a> 提取码: 4j2y</li><li>黑马程序员 - 8天零基础入门大数据<br>链接: <a href="https://pan.baidu.com/s/1oIG9R-1tuF8BUJXWTuPNfg">https://pan.baidu.com/s/1oIG9R-1tuF8BUJXWTuPNfg</a> 提取码: 8d9w</li><li>大数据Java基础课程【完整资料】<br>链接: <a href="https://pan.baidu.com/s/1H6E-o6-jYWbsv6q-M-2rVA">https://pan.baidu.com/s/1H6E-o6-jYWbsv6q-M-2rVA</a> 提取码: q5og</li></ol><h1 id="机器学习与深度学习"><a href="#机器学习与深度学习" class="headerlink" title="机器学习与深度学习"></a>机器学习与深度学习</h1><ol><li>机器学习之Python编程基础与数据分析<br>链接: <a href="https://pan.baidu.com/s/1mQVcWpX0ZrpaeZZ0ZGkI8g">https://pan.baidu.com/s/1mQVcWpX0ZrpaeZZ0ZGkI8g</a> 提取码: 43nh</li><li>Tensorflow-物体检测-Faster-Rcnn解读<br>链接: <a href="https://pan.baidu.com/s/1bENtgT8seAaLxDOGfRvlpg">https://pan.baidu.com/s/1bENtgT8seAaLxDOGfRvlpg</a> 提取码: 77z9</li><li>Tensorflow-图像处理视频课程<br>链接: <a href="https://pan.baidu.com/s/18ZHmCP5S4etCwF9r5dFibg">https://pan.baidu.com/s/18ZHmCP5S4etCwF9r5dFibg</a> 提取码: h0c0</li><li>图像处理与机器学习<br>链接: <a href="https://pan.baidu.com/s/1LN9KM7cW91-0e7VKYSwImQ">https://pan.baidu.com/s/1LN9KM7cW91-0e7VKYSwImQ</a> 提取码: 598a</li><li>深度学习之神经网络<br>链接: <a href="https://pan.baidu.com/s/1nZ2oECGskQoAZUorPy1xbw">https://pan.baidu.com/s/1nZ2oECGskQoAZUorPy1xbw</a> 提取码: fqv1</li></ol><h1 id="Linux相关（容器、网络编程等）"><a href="#Linux相关（容器、网络编程等）" class="headerlink" title="Linux相关（容器、网络编程等）"></a>Linux相关（容器、网络编程等）</h1><ol><li>带你轻松玩转Docker技术<br>链接: <a href="https://pan.baidu.com/s/1OVo2EbLNzsou1wftgqHUuw">https://pan.baidu.com/s/1OVo2EbLNzsou1wftgqHUuw</a> 提取码: b6y4</li><li>新一代容器技术Docker【资料完整】<br>链接: <a href="https://pan.baidu.com/s/1ZkoQKmmCPoArcK6zr6RziA">https://pan.baidu.com/s/1ZkoQKmmCPoArcK6zr6RziA</a> 提取码: 4g6y</li><li>K8s（kubernetes）周末班视频资料齐全<br>链接: <a href="https://pan.baidu.com/s/1hxseWrp2JhKaqdhLLFGzDw">https://pan.baidu.com/s/1hxseWrp2JhKaqdhLLFGzDw</a> 提取码: nrwo</li><li>kubernetes全栈技术讲解+企业案例演示[带你快速学习和使用k8s]【基础+进阶版】<br>链接: <a href="https://pan.baidu.com/s/1vHivOuLofQf7cP4y_Jj5HA">https://pan.baidu.com/s/1vHivOuLofQf7cP4y_Jj5HA</a> 提取码: o7uq</li><li>Linux系统及网络编程视频课程专题<br>链接: <a href="https://pan.baidu.com/s/1G8dWp3ACtSIZ8YCetiex7w">https://pan.baidu.com/s/1G8dWp3ACtSIZ8YCetiex7w</a> 提取码: 4rqy</li><li>老男孩脱产班linux运维51期<br>链接: <a href="https://pan.baidu.com/s/1VBkdwt_0ijgAx8p6pMQgQg">https://pan.baidu.com/s/1VBkdwt_0ijgAx8p6pMQgQg</a> 提取码: b1bb</li></ol><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><ol><li>分布式存储极致性能Redis6  直奔阿里P6-P7水平<br>链接: <a href="https://pan.baidu.com/s/1KI2LENhYLHiNdPKC7yu5IA">https://pan.baidu.com/s/1KI2LENhYLHiNdPKC7yu5IA</a> 提取码: zrci</li><li>数据库精讲课程<br>链接: <a href="https://pan.baidu.com/s/182QED7hvx_Bx33dZCJg6gg">https://pan.baidu.com/s/182QED7hvx_Bx33dZCJg6gg</a> 提取码: rc34</li></ol><h1 id="逆向破解"><a href="#逆向破解" class="headerlink" title="逆向破解"></a>逆向破解</h1><ol><li>易语言 安卓逆向<br>链接: <a href="https://pan.baidu.com/s/1mrtQaIPlPhlZUYifVdPcAA">https://pan.baidu.com/s/1mrtQaIPlPhlZUYifVdPcAA</a> 提取码: 09hn</li></ol><h1 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h1><ol><li>网络安全最新视频 1-20天课程<br>链接: <a href="https://pan.baidu.com/s/10rjtxz0hHsPhPcJEg4eEvA">https://pan.baidu.com/s/10rjtxz0hHsPhPcJEg4eEvA</a> 提取码: 93ws</li><li>网络安全总监Kail渗透测试代码审计等保测评应急响应<br>链接: <a href="https://pan.baidu.com/s/1LpbHMB5KHWbeZQZmEQ0s9w">https://pan.baidu.com/s/1LpbHMB5KHWbeZQZmEQ0s9w</a> 提取码: 173t</li><li>网络安全入门到入灰<br>链接: <a href="https://pan.baidu.com/s/1qZCthSTt2lCu4AyT9Cpeuw">https://pan.baidu.com/s/1qZCthSTt2lCu4AyT9Cpeuw</a> 提取码: 3e28</li><li>全栈网络安全专家<br>链接: <a href="https://pan.baidu.com/s/1GqqBpcOl8m9ARP-BaNTSTQ">https://pan.baidu.com/s/1GqqBpcOl8m9ARP-BaNTSTQ</a> 提取码: 5ctb</li></ol><h1 id="虚拟引擎"><a href="#虚拟引擎" class="headerlink" title="虚拟引擎"></a>虚拟引擎</h1><ol><li>UE4虚拟引擎开发教程<br>链接: <a href="https://pan.baidu.com/s/1FA5uBKTsSoZMosEtjYGAng">https://pan.baidu.com/s/1FA5uBKTsSoZMosEtjYGAng</a> 提取码: w691</li></ol><h1 id="手机端开发"><a href="#手机端开发" class="headerlink" title="手机端开发"></a>手机端开发</h1><h2 id="鸿蒙"><a href="#鸿蒙" class="headerlink" title="鸿蒙"></a>鸿蒙</h2><ol><li>HarmonyOS鸿蒙 快速入门应用开发进阶<br>链接: <a href="https://pan.baidu.com/s/1P2hPKiHdp247ETNyykkh2w">https://pan.baidu.com/s/1P2hPKiHdp247ETNyykkh2w</a> 提取码: dvu3</li></ol><h2 id="安卓"><a href="#安卓" class="headerlink" title="安卓"></a>安卓</h2><h1 id="软件测试"><a href="#软件测试" class="headerlink" title="软件测试"></a>软件测试</h1><ol><li>自动化工具Jmeter 入门到进阶6小时搞定<br>链接: <a href="https://pan.baidu.com/s/18mIgRmQjvUNGOf5XUYLpxg">https://pan.baidu.com/s/18mIgRmQjvUNGOf5XUYLpxg</a> 提取码: 5c8p</li></ol><h1 id="考研"><a href="#考研" class="headerlink" title="考研"></a>考研</h1><ol><li>20天勤计算机复试上机辅导<br>链接: <a href="https://pan.baidu.com/s/1WamuZelJbRkEnRw9uCG6LQ">https://pan.baidu.com/s/1WamuZelJbRkEnRw9uCG6LQ</a> 提取码: b19z</li></ol><h1 id="项目实战"><a href="#项目实战" class="headerlink" title="项目实战"></a>项目实战</h1><h2 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h2><ol><li>Java实战项目 双11互联网电商秒杀系统解决方案<br>链接: <a href="https://pan.baidu.com/s/1IVXHoPB4_yxxITgC6pXDFw">https://pan.baidu.com/s/1IVXHoPB4_yxxITgC6pXDFw</a> 提取码: jgx8</li><li>Java企业级实战全栈项目 中信CRM（完整资料）<br>链接: <a href="https://pan.baidu.com/s/1LHSRVgYrrKOMMQXrpx2ZYw">https://pan.baidu.com/s/1LHSRVgYrrKOMMQXrpx2ZYw</a> 提取码: 4y6e</li><li>Java企业级项目 易购商城（完整资料）<br>链接: <a href="https://pan.baidu.com/s/1GqAzvlX-2YiJ9jH4p1i2jA">https://pan.baidu.com/s/1GqAzvlX-2YiJ9jH4p1i2jA</a> 提取码: qkwf</li><li>Spark离线和实时电影推荐系统直播回放(视频+文档+代码）<br>链接: <a href="https://pan.baidu.com/s/1HS-3xXqhe_zKx6ujbCwqgQ">https://pan.baidu.com/s/1HS-3xXqhe_zKx6ujbCwqgQ</a> 提取码: 074a</li></ol><h2 id="python-1"><a href="#python-1" class="headerlink" title="python"></a>python</h2><ol><li>聊天机器人视频课程【完整资料】<br>链接: <a href="https://pan.baidu.com/s/1PYlJo8bos_peM9Uq5LBWrQ">https://pan.baidu.com/s/1PYlJo8bos_peM9Uq5LBWrQ</a> 提取码: 9892</li><li>Java企业级项目 对标阿里P7 P8《锋迷商城》项目实战（完结 资料完整）<br>链接: <a href="https://pan.baidu.com/s/10jNU6SbLswkN28kNACUeAA">https://pan.baidu.com/s/10jNU6SbLswkN28kNACUeAA</a> 提取码: x406</li></ol><h2 id="Go-1"><a href="#Go-1" class="headerlink" title="Go"></a>Go</h2><ol><li>2020年最新 Go语言零基础微服务项目<br>链接: <a href="https://pan.baidu.com/s/156qMNvpXSvQObz_H_QKG2g">https://pan.baidu.com/s/156qMNvpXSvQObz_H_QKG2g</a> 提取码: h10k</li><li>Go语言实战班1期<br>链接: <a href="https://pan.baidu.com/s/1-L62OqrD4a4M5gMeNABupw">https://pan.baidu.com/s/1-L62OqrD4a4M5gMeNABupw</a> 提取码: 795k</li></ol><h2 id="毕设"><a href="#毕设" class="headerlink" title="毕设"></a>毕设</h2><ol><li>程序员毕设全流程课程<br>链接: <a href="https://pan.baidu.com/s/1kSQwZq5eAGQA88Q3_nGQtA">https://pan.baidu.com/s/1kSQwZq5eAGQA88Q3_nGQtA</a> 提取码: 4851</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习资料 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习资料 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划刷题入门</title>
      <link href="/posts/33655.html"/>
      <url>/posts/33655.html</url>
      
        <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><blockquote><p>动态规划常常适用于有重叠子问题和最优子结构性质的问题，并且记录所有子问题的结果，因此动态规划方法所耗时间往往远少于朴素解法。 </p><p>动态规划有自底向上和自顶向下两种解决问题的方式。自顶向下即记忆化递归，自底向上就是递推。 </p><p>使用动态规划解决的问题有个明显的特点，一旦一个子问题的求解得到结果，以后的计算过程就不会修改它，这样的特点叫做无后效性，求解问题的过程形成了一张有向无环图。动态规划只解决每个子问题一次，具有天然剪枝的功能，从而减少计算量。</p></blockquote><h1 id="入门题"><a href="#入门题" class="headerlink" title="入门题"></a>入门题</h1><h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><p><a href="https://leetcode-cn.com/problems/fibonacci-number/">509. 斐波那契数 - 力扣（LeetCode） (leetcode-cn.com)</a></p><blockquote><p>斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：</p><p>F(0) = 0，F(1) = 1<br>F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1<br>给你 n ，请计算 F(n) 。</p><p><strong>示例 1：</strong></p><p>输入：2<br>输出：1<br>解释：F(2) = F(1) + F(0) = 1 + 0 = 1</p><p><strong>示例 2：</strong></p><p>输入：3<br>输出：2<br>解释：F(3) = F(2) + F(1) = 1 + 1 = 2</p><p><strong>示例 3：</strong></p><p>输入：4<br>输出：3<br>解释：F(4) = F(3) + F(2) = 2 + 1 = 3</p><p><strong>提示：</strong></p><p>0 &lt;= n &lt;= 30</p></blockquote><p>斐波那契数列的特点是：$ f(n)=f(n-1)+f(n-2) $，也是此题的 dp 方程。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {    public int fib(int n) {        if (n == 0 || n == 1){            return n;        }        return fib(n - 1) + fib(n - 2);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/sehowyoung/images/raw/master/202108262041283.png" alt="提交"></p><h2 id="第N个泰波纳契数"><a href="#第N个泰波纳契数" class="headerlink" title="第N个泰波纳契数"></a>第N个泰波纳契数</h2><p><a href="https://leetcode-cn.com/problems/n-th-tribonacci-number/">1137. 第 N 个泰波那契数 - 力扣（LeetCode） (leetcode-cn.com)</a></p><blockquote><p>泰波那契序列 $T_{n}$ 定义如下： </p><p>$T_{0} =0$, </p><p>$T_{1} = 1$, </p><p>$T_{2}=1$, </p><p>且在 n &gt;= 0 的条件下 </p><p>$T<em>{n + 3}=T</em>{n}+T<em>{n+1}+T</em>{n+2}$</p><p>给你整数 <code>n</code>，请返回第 n 个泰波那契数 $T_{n}$ 的值。</p><p><strong>示例 1：</strong></p><p>输入：n = 4<br>输出：4<br>解释：<br>T_3 = 0 + 1 + 1 = 2<br>T_4 = 1 + 1 + 2 = 4</p><p><strong>示例 2：</strong></p><p>输入：n = 25<br>输出：1389537</p><p><strong>提示：</strong></p><ul><li>0 &lt;= n &lt;= 37</li><li>答案保证是一个 32 位整数，即 answer &lt;= 2^31 - 1。</li></ul></blockquote><p>这道题其实和上面的有点类似，但如果我们还用上面那道题的递归来做（代码如下），就会发现超出时间限制，其实就是因为使用递归会进行大量的重复计算。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {    public int tribonacci(int n) {        if (n &lt; 2){            return n;        } else if (n == 2){            return 1;        }        return tribonacci(n - 1) + tribonacci(n - 2) + tribonacci(n - 3);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/sehowyoung/images/raw/master/202108280833786.png" alt="image-20210828083349599"></p><p>但如果创造一个数组来存储值，将会大大减少重复计算的数据量。</p><p>动归方程：$dp[n] = dp[n-1] + dp[n-2] + dp[n-3]$</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {    public int tribonacci(int n) {        int[] dp = new int[3];        dp[1] = 1;        dp[2] = 1;        for (int i = 3; i &lt;= n; i++) {            dp[i % 3] = dp[0] + dp[1] + dp[2];        }        return dp[n % 3];    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/sehowyoung/images/raw/master/202108280835450.png" alt="image-20210828083543424"></p><h2 id="使用最小花费爬楼梯"><a href="#使用最小花费爬楼梯" class="headerlink" title="使用最小花费爬楼梯"></a>使用最小花费爬楼梯</h2><p><a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/">746. 使用最小花费爬楼梯 - 力扣（LeetCode） (leetcode-cn.com)</a></p><blockquote><p>数组的每个下标作为一个阶梯，第 <code>i</code> 个阶梯对应着一个非负数的体力花费值 <code>cost[i]</code>（下标从 0 开始）。</p><p>每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。</p><p>请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。</p><p><strong>示例 1：</strong></p><p>输入：cost = [10, 15, 20]<br>输出：15<br>解释：最低花费是从 cost[1] 开始，然后走两步即可到阶梯顶，一共花费 15 。</p><p><strong>示例 2：</strong></p><p>输入：cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]<br>输出：6<br>解释：最低花费方式是从 cost[0] 开始，逐个经过那些 1 ，跳过 cost[3] ，一共花费 6 。</p><p><strong>提示：</strong></p><ul><li>cost 的长度范围是 [2, 1000]。</li><li>cost[i] 将会是一个整型数据，范围为 [0, 999] 。</li></ul></blockquote><p>本题其实就是计算达到下标<code>n</code>的最小花费，因此要通过动态规划来求解。</p><p>创建数组长度为<code>n + 1</code>的数组<code>dp</code>，其中<code>dp[i]</code>表示到下标<code>i</code>的最小花费，因此<code>dp</code>方程为：</p><p>$dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])$</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {    public int minCostClimbingStairs(int[] cost) {        int[] dp = new int[cost.length + 1];        for (int i = 2; i &lt; dp.length; i++) {            dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i -2] + cost[i - 2]);        }        return dp[dp.length - 1];    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/sehowyoung/images/raw/master/202108280919406.png" alt="image-20210828091940372"></p><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(n)$</li></ul><p>但是其实使用的空间是可以压缩的，我们这里只需要获取<code>dp[i - 1]</code>和<code>dp[i-2]</code>的值，因此，我们只需要2个变量来存储就可以了。其中<code>pre</code>代表前一个值，相当于<code>dp[i - 2]</code>，<code>curr</code>代表当前值，相当于<code>dp[i - 1]</code>。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {    public int minCostClimbingStairs(int[] cost) {        int pre = 0;        int curr = 0;        for (int i = 2; i &lt; cost.length + 1; i++){            int next = Math.min(pre + cost[i - 2], curr + cost[i - 1]);            pre = curr;            curr = next;        }        return curr;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(1)$</li></ul><h1 id="中等题"><a href="#中等题" class="headerlink" title="中等题"></a>中等题</h1><h2 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h2><p><a href="https://leetcode-cn.com/problems/house-robber/">198. 打家劫舍 - 力扣（LeetCode） (leetcode-cn.com)</a></p><blockquote><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><p><strong>示例 1：</strong></p><p>输入：[1,2,3,1]<br>输出：4<br>解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。<br>    偷窃到的最高金额 = 1 + 3 = 4 。</p><p><strong>示例 2：</strong></p><p>输入：[2,7,9,3,1]<br>输出：12<br>解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。<br>    偷窃到的最高金额 = 2 + 9 + 1 = 12 。</p><p><strong>提示：</strong></p><ul><li>1 &lt;= nums.length &lt;= 100</li><li>0 &lt;= nums[i] &lt;= 400</li></ul></blockquote><p>创建长度为<code>nums.length</code>的dp数组，<code>dp[i]</code>表示在前<code>i</code>家内偷到的最大金额，因为小偷总共有两种偷盗方式：</p><ul><li>偷第<code>i</code>家，那么<code>dp[i] = dp[i - 2] + nums[i]</code></li><li>不偷第<code>i</code>家，那就是偷第<code>i - 1</code>家，那么<code>dp[i] = dp[i - 1]</code></li></ul><p>因此其dp方程为：</p><p>$dp[i] = Math.max(dp[i - 1], dp[i - 2] + cost[i])$</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {    public int rob(int[] nums) {        if (nums.length == 1){            return nums[0];        }        int[] dp = new int[nums.length];        dp[0] = nums[0];        dp[1] = Math.max(nums[0], nums[1]);        for (int i = 2; i &lt; nums.length; i++) {            dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);        }        return dp[dp.length - 1];    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/sehowyoung/images/raw/master/202108281016477.png" alt="image-20210828101606441"></p><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(n)$</li></ul><p>此外，也可以进行滚动数组优化，采用两个变量来完成，同<a href="https://blog.howyoung.work/posts/33655.html#使用最小花费爬楼梯">使用最小花费爬楼梯</a>一样。</p><h2 id="打家劫舍II"><a href="#打家劫舍II" class="headerlink" title="打家劫舍II"></a>打家劫舍II</h2><p><a href="https://leetcode-cn.com/problems/house-robber-ii/">213. 打家劫舍 II - 力扣（LeetCode） (leetcode-cn.com)</a></p><blockquote><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。</p><p><strong>示例 1：</strong></p><p>输入：nums = [2,3,2]<br>输出：3<br>解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。</p><p><strong>示例 2：</strong></p><p>输入：nums = [1,2,3,1]<br>输出：4<br>解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。<br>    偷窃到的最高金额 = 1 + 3 = 4 。</p><p><strong>示例 3：</strong></p><p>输入：nums = [0]<br>输出：0</p><p><strong>提示：</strong></p><ul><li>1 &lt;= nums.length &lt;= 100</li><li>0 &lt;= nums[i] &lt;= 1000</li></ul></blockquote><p>创建长度为<code>nums.length</code>的数组<code>dp</code>，其中<code>dp[i]</code>表示前i家的最大偷盗金额。那么在上一道的条件上，分为两种情况：</p><ul><li>如果偷盗最后一家，就可以将数组剪切掉第一个数，使用上一题的方法进行判断</li><li>如果不偷盗最后一家，就可以剪掉数组最后一个数，使用上一题的方法进行判断</li></ul><p>返回结果就是这两者的最大值。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {    public int rob(int[] nums) {        if (nums.length == 1){            return nums[0];        } else if (nums.length == 2){            return Math.max(nums[0], nums[1]);        }        return Math.max(myrob(Arrays.copyOfRange(nums, 1, nums.length)),                         myrob(Arrays.copyOfRange(nums, 0, nums.length - 1)));    }    public int myrob(int[] nums){        int pre = nums[0];        int cur = Math.max(pre, nums[1]);        for (int i = 2; i &lt; nums.length; i++) {            int next = Math.max(pre + nums[i], cur);            pre = cur;            cur = next;        }        return cur;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/sehowyoung/images/raw/master/202108281117366.png" alt="image-20210828111706324"></p><h2 id="删除并获得点数"><a href="#删除并获得点数" class="headerlink" title="删除并获得点数"></a>删除并获得点数</h2><p><a href="https://leetcode-cn.com/problems/delete-and-earn/">740. 删除并获得点数 - 力扣（LeetCode） (leetcode-cn.com)</a></p><blockquote><p>给你一个整数数组 nums ，你可以对它进行一些操作。</p><p>每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后，你必须删除 所有 等于 nums[i] - 1 和 nums[i] + 1 的元素。</p><p>开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。</p><p><strong>示例 1：</strong></p><p>输入：nums = [3,4,2]<br>输出：6<br>解释：<br>删除 4 获得 4 个点数，因此 3 也被删除。<br>之后，删除 2 获得 2 个点数。总共获得 6 个点数。</p><p><strong>示例 2：</strong></p><p>输入：nums = [2,2,3,3,3,4]<br>输出：9<br>解释：<br>删除 3 获得 3 个点数，接着要删除两个 2 和 4 。<br>之后，再次删除 3 获得 3 个点数，再次删除 3 获得 3 个点数。<br>总共获得 9 个点数。</p><p><strong>提示：</strong></p><ul><li>1 &lt;= nums.length &lt;= 2 * 104</li><li>1 &lt;= nums[i] &lt;= 104</li></ul></blockquote><h3 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h3><p>根据题意，在选择了元素<code>x</code>后，该元素以及所有等于<code>x-1</code>或<code>x+1</code>的元素会从数组中删去。若还有多个值为<code>x</code>的元素，由于所有等于<code>x-1</code>或<code>x+1</code>的元素已经被删除，我们可以直接删除<code>x</code>并获得其点数。因此若选择了<code>x</code>，所有等于<code>x</code>的元素也应一同被选择，以尽可能多地获得点数。</p><p>记元素<code>x</code>在数组中出现的次数为$c_{x}$，我们可以用一个数组<code>sum</code>录数组<code>nums</code>中所有相同元素之和，即 \textit{sum}</p><p>$sum[x] = x * c_{x}$</p><p>若选择了<code>x</code>，则可以获取<code>sum[x]</code>的点数，且无法再选择<code>x−1</code>和<code>x+1</code>。这与「打家劫舍」是一样的，在统计出 <code>sum</code>数组后，读者可参考<a href="https://blog.howyoung.work/posts/33655.html#打家劫舍">打家劫舍</a>中的动态规划过程计算出答案。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {    public int deleteAndEarn(int[] nums) {        int max = nums[0];        for (int num : nums){            max = Math.max(num, max);        }        int[] sum = new int[max + 1];        for (int num : nums) {            sum[num] += num;        }        return rob(sum);    }    public int rob(int[] nums){        if (nums.length == 2){            return nums[1];        }        int pre = nums[1];        int cur = Math.max(pre, nums[2]);        for (int i = 3; i &lt; nums.length; i++) {            int next = Math.max(pre + nums[i], cur);            pre = cur;            cur = next;        }        return cur;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/sehowyoung/images/raw/master/202108282303984.png" alt="image-20210828230334936"></p><ul><li>时间复杂度：$O(N+M)$，<code>N</code>为nums数组的长度，<code>M</code>为nuns数组中最大的值</li><li>空间复杂度：$O(M)$</li></ul><h3 id="方法二：排序-动态规划"><a href="#方法二：排序-动态规划" class="headerlink" title="方法二：排序 + 动态规划"></a>方法二：排序 + 动态规划</h3><p>注意到若<code>nums</code>中不存在某个元素<code>x</code>，则选择任一小于<code>x</code>的元素不会影响到大于<code>x</code>的元素的选择。因此我们可以将 <code>nums</code>排序后，将其划分成若干连续子数组，子数组内任意相邻元素之差不超过<code>1</code>。对每个子数组按照方法一的动态规划过程计算出结果，累加所有结果即为答案。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Solution {    public int deleteAndEarn(int[] nums) {        int n = nums.length;        int ans = 0;        Arrays.sort(nums);        List&lt;Integer&gt; sum = new ArrayList&lt;Integer&gt;();        sum.add(nums[0]);        int size = 1;        for (int i = 1; i &lt; n; i++) {            int val = nums[i];            if (val == nums[i - 1]) {                sum.set(size - 1, sum.get(size - 1) + val);            } else if (val == nums[i - 1] + 1) {                sum.add(val);                size++;            } else {                ans += rob(sum);                sum.clear();                sum.add(val);                size = 1;            }        }        ans += rob(sum);        return ans;    }    public int rob(List&lt;Integer&gt; nums) {        int size = nums.size();        if (size == 1) {            return nums.get(0);        }        int first = nums.get(0), second = Math.max(nums.get(0), nums.get(1));        for (int i = 2; i &lt; size; i++) {            int temp = second;            second = Math.max(first + nums.get(i), second);            first = temp;        }        return second;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度：$O(NlogN)$，其中<code>N</code>是数组<code>nums</code>的长度。对<code>nums</code>排序需要花费$O(NlogN)$的时间，遍历计算需要花费$O(N)$的时间，故总的时间复杂度为$O(NlogN)$。</li><li>空间复杂度：$O(N)$。统计 <code>sum</code>至多需要花费$O(N)$的空间。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯法</title>
      <link href="/posts/58235.html"/>
      <url>/posts/58235.html</url>
      
        <content type="html"><![CDATA[<h1 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h1><p><strong>回溯法（back tracking）</strong>（探索与回溯法）是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 回溯法 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务架构学习笔记</title>
      <link href="/posts/63498.html"/>
      <url>/posts/63498.html</url>
      
        <content type="html"><![CDATA[<h1 id="微服务架构介绍"><a href="#微服务架构介绍" class="headerlink" title="微服务架构介绍"></a>微服务架构介绍</h1><h2 id="技术架构演变"><a href="#技术架构演变" class="headerlink" title="技术架构演变"></a>技术架构演变</h2><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210718200826947.png" alt="技术架构的演变" style="zoom:50%;"></p><h3 id="单体架构"><a href="#单体架构" class="headerlink" title="单体架构"></a>单体架构</h3><p>单体架构也被称为单体系统或者是单体应用，是一种把所有的功能、模块耦合在一个应用中的架构方式。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol><li>打包成一个独立的单元（一个 jar 包或者一个 war 包）</li><li>以一个进程的方式来运行</li></ol><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li>优点：<ul><li>项目易于管理</li><li>部署简单</li></ul></li><li>缺点：<ul><li>测试成本高</li><li>可伸缩性差</li><li>可靠性差</li><li>系统迭代困难</li><li>跨语言程度差</li><li>团队协作难</li></ul></li></ul><h3 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h3><p>微服务是一种架构风格，一个复杂的软件应用，有一个或多个服务组成。系统中的各个微服务可被独立部署，各个微服务之间是松耦合的。每个微服务仅仅关注并完成一个任务。</p><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ol><li>系统是由多个服务构成</li><li>每个服务可以单独部署</li><li>每个服务之间是松耦合的，服务内部是高内聚的（每个服务只关注完成一个功能），外部是低耦合的。</li></ol><h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li>优点：<ul><li>测试容易</li><li>可伸缩性强</li><li>可靠性强</li><li>跨语言成都更灵活</li><li>团队协作容易</li><li>系统迭代容易</li></ul></li><li>缺点：<ul><li>运维成本高，部署数量较多</li><li>接口兼容多版本</li><li>分布式系统的复杂性</li><li>分布式事务</li></ul></li></ul><h3 id="常见软件架构方式的区别"><a href="#常见软件架构方式的区别" class="headerlink" title="常见软件架构方式的区别"></a>常见软件架构方式的区别</h3><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210719192354021.png" alt="MVC、RPC、SOA、微服务架构区别" style="zoom:67%;"></p><p>ESB（Enterprise Service Bus）：企业服务总线，起到中介的作用，主要是提供了服务与服务之间的交互。包含了负载均衡、流量控制、加密处理、服务监控、异常处理等功能。</p><div class="table-container"><table><thead><tr><th></th><th>MVC架构</th><th>RPC架构</th><th>SOA架构</th><th>微服务架构</th></tr></thead><tbody><tr><td>介绍</td><td>单体架构</td><td>RPC（Remote Procedure Call）：远程过程调用，通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的一种技术</td><td>SOA（Service Oriented Architecture）：面向服务架构</td><td>轻量级的服务治理方案，拥有服务注册中心</td></tr><tr><td>代表技术</td><td>Structs2、Spring MVC、Spring、Mybatis</td><td>Thrift、Hession</td><td>Mule、WSO2</td><td>Spring Cloud</td></tr></tbody></table></div><h2 id="微服务的设计原则"><a href="#微服务的设计原则" class="headerlink" title="微服务的设计原则"></a>微服务的设计原则</h2><h3 id="AKF-拆分原则"><a href="#AKF-拆分原则" class="headerlink" title="AKF 拆分原则"></a>AKF 拆分原则</h3><p>业界对于可扩展的系统架构设计 有一个朴素的理念就是<strong>通过加机器就可以解决容量和可用性问题</strong>（如果一台不行，那就两台）。 </p><p>这一理念在“云计算”概念疯狂流行的今天，得到了广泛的认可！对于一个规模迅速增长的系统而言，容量和性能间题当然是首当其冲的，但是随着时间的推移，系统规模的增长，除了面对性能与容量的问题外，还需要面对功能与模块数量上的增长带来的系统复杂性问题以及业务的变化带来的提供差异化服务问题。而许多系统，在架构设计时并未充分考虑到这些间题，导政系统的重构成为常态，从而影响业务交付能力，还浪费人力财力！对此，《可扩展的艺术》一书提出了ー个更加系统的可扩展模型一一AKF 可扩展立方(Scalability Cube),这个立方体中沿着三个坐标轴设置分别为X、Y、Z</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210720175420134.png" alt="AKF 扩展立方体"></p><ul><li>X 轴：关注水平拓展，即通过加机器解决问题</li><li>Y 轴：关注应用中功能划分，基于不同业务拆分</li><li>Z 轴：关注服务和数据的优先级划分</li></ul><p>微服务拆分方式：</p><ul><li>按不同功能进行拆分</li></ul><p>微服务拆分要点：</p><ul><li>低耦合、高内聚：一个服务只完成一个独立功能</li><li>按团队结构，小规模团队维护，快速进行迭代</li></ul><h4 id="功能拆分"><a href="#功能拆分" class="headerlink" title="功能拆分"></a>功能拆分</h4><p>对于一个电商平台，有以下功能，我们可以将其拆分成不同的服务，有如下架构：</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210720180644479.png" alt="功能架构" style="zoom:50%;"></p><p>当服务数量不断增多，服务间的调用关系将变得更加复杂。因此，我们可以采用服务注册的机制形成服务网关来进行服务治理。这样看起来就会非常清晰、简洁，拓展新的服务也将变得更加容易。</p><p><img src="C:\Users\84661\AppData\Roaming\Typora\typora-user-images\image-20210720181012524.png" alt="增加服务网关的架构" style="zoom:50%;"></p><h4 id="水平拓展"><a href="#水平拓展" class="headerlink" title="水平拓展"></a>水平拓展</h4><p>Ⅹ 轴扩展与我们前面朴素理念是一致的，通过绝对平等地复制服务与数据，以解决容量和可用性的问题。其实就是将微服务运行多个实例，做集群加负载均衡的模式。</p><p>为了提升单个服务的可用性和容量，<strong>对每一个服务进行 X 轴扩展划分</strong>。</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210720181340198.png" alt="进行水平拓展后的架构" style="zoom:50%;"></p><h4 id="数据分区"><a href="#数据分区" class="headerlink" title="数据分区"></a>数据分区</h4><p>Z 轴扩展通常是指基于请求者或用户独特的需求，进行系统划分，并使得划分出来的子系统是相互隔离但又是完整的。以生产汽车的工厂来举例：福特公司为了发展在中国的业务，或者利用中国的廉价劳动力，在中国建立一个完整的子工厂，与美国工厂一样，负责完整的汽车生产。这就是一种 Z 轴扩展。</p><h3 id="前后端分离原则"><a href="#前后端分离原则" class="headerlink" title="前后端分离原则"></a>前后端分离原则</h3><p><img src="https://gitee.com/sehowyoung/images/raw/master/1394466-20180916231716242-1862208927.png" alt="前后端分离" style="zoom:50%;"></p><p>使用前后端分离的好处：</p><ol><li>前后端技术分离，可以由各自的专家来进行优化，可以是前端的用户体验更好</li><li>分离模式下，前后端交互界面更清晰，后端的接口简洁明了，更容易维护。</li><li>前端多渠道集成场景更容易实现，后端服务无需变更，采用统一的数据和模型，可以支持多个前端</li></ol><h3 id="无状态服务"><a href="#无状态服务" class="headerlink" title="无状态服务"></a>无状态服务</h3><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210720234626826.png" alt="无状态服务"></p><p>对于无状态服务，首先说一下什么是状态：如果一个数据需要被多个服务共享，才能完成一笔交易，那么这个数据被称为状态。进而依赖这个“状态”数据的服务被称为有状态服务，反之称为无状态服务。</p><p>那么这个无状态服务原则并不是说在微服务架构里就不允许存在状态，表达的真实意思是要把有状态的业务服务改变为无状态的计算类服务，那么状态数据也就相应的迁移到对应的“有状态数据服务”中。</p><p>场景说明：例如我们以前在本地内存中建立的数据缓存、 Session缓存，到现在的微服务架构中就应该把这些数据迁移到分布式缓存中存储，让业务服务变成一个无状态的计算节点。迁移后，就可以做到按需动态伸缩，微服务应用在运行时动态增删节点，就不再需要考虑缓存数据如何同步的问题。</p><h3 id="RestFul-风格"><a href="#RestFul-风格" class="headerlink" title="RestFul 风格"></a>RestFul 风格</h3><blockquote><p>**表现层状态</p><p><strong>转换</strong>（<a href="https://zh.wikipedia.org/wiki/英语">英语</a>：<strong>Representational State Transfer</strong>，<a href="https://zh.wikipedia.org/wiki/縮寫">缩写</a>：<strong>REST</strong>）是<a href="https://zh.wikipedia.org/w/index.php?title=Roy_Thomas_Fielding&amp;action=edit&amp;redlink=1">Roy Thomas Fielding</a>博士于2000年在他的博士论文中提出来的一种<a href="https://zh.wikipedia.org/wiki/万维网">万维网</a><a href="https://zh.wikipedia.org/wiki/软件架构">软件架构</a>风格，目的是便于不同软件/程序在网络（例如互联网）中互相传递信息。表现层状态转换是根基于<a href="https://zh.wikipedia.org/wiki/超文本传输协议">超文本传输协议（HTTP）</a>之上而确定的一组约束和属性，是一种设计提供万维网络服务的<a href="https://zh.wikipedia.org/wiki/軟件架構">软件构建风格</a>。符合或兼容于这种架构风格（简称为 REST 或 RESTful）的网络服务，允许客户端发出以<a href="https://zh.wikipedia.org/wiki/统一资源标志符">统一资源标识符</a>访问和操作网络资源的请求，而与预先定义好的无状态操作集一致化。因此表现层状态转换提供了在互联网络的计算系统之间，彼此资源可交互使用的协作性质（interoperability）。相对于其它种类的网络服务，例如SOAP服务，则是以本身所定义的操作集，来访问网络上的资源。</p></blockquote><p>可以看一下<a href="https://www.ruanyifeng.com/blog/2011/09/restful.html">理解RESTful架构 - 阮一峰的网络日志 (ruanyifeng.com)</a></p><h1 id="Spring-Cloud-入门"><a href="#Spring-Cloud-入门" class="headerlink" title="Spring Cloud 入门"></a>Spring Cloud 入门</h1><h2 id="什么是Spring-Cloud"><a href="#什么是Spring-Cloud" class="headerlink" title="什么是Spring Cloud"></a>什么是Spring Cloud</h2><blockquote><p>Spring Cloud 是开发分布式系统的“全家桶”，是一系列框架的有序集合。Spring Cloud 利用 <a href="http://c.biancheng.net/spring_boot/">Spring Boot</a> 的开发便利性巧妙地简化了分布式系统基础设施的开发。</p><p>Spring Cloud 对于中小型互联网公司来说是一种福音，使用 Spring Cloud 一站式解决方案能在从容应对业务发展的同时大大减少开发成本。</p><p><a href="http://c.biancheng.net/spring_cloud/">Spring Cloud</a> 是一系列框架的有序集合。它利用 <a href="http://c.biancheng.net/spring/">Spring</a> Boot 的开发便利性，巧妙地简化了分布式系统基础设施的开发，如服务注册、服务发现、配置中心、消息总线、负载均衡、断路器、数据监控等，这些都可以用 Spring Boot 的开发风格做到一键启动和部署。</p><p>通俗地讲，Spring Cloud 就是用于构建微服务开发和治理的框架集合（并不是具体的一个框架），主要贡献来自 Netflix OSS。</p></blockquote><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>Spring Cloud 模块的相关介绍如下：</p><ul><li>Eureka：服务注册中心，用于服务管理。</li><li>Ribbon：基于客户端的负载均衡组件。</li><li>Hystrix：容错框架，能够防止服务的雪崩效应。</li><li>Feign：Web 服务客户端，能够简化 HTTP 接口的调用。</li><li>Zuul：API 网关，提供路由转发、请求过滤等功能。</li><li>Config：分布式配置管理。</li><li>Sleuth：服务跟踪。</li><li>Stream：构建消息驱动的微服务应用程序的框架。</li><li>Bus：消息代理的集群消息总线。</li></ul><p>除了上述模块，还有 Cli、Task等。</p><h2 id="Spring-Cloud-和-Dubbo-的区别"><a href="#Spring-Cloud-和-Dubbo-的区别" class="headerlink" title="Spring Cloud 和 Dubbo 的区别"></a>Spring Cloud 和 Dubbo 的区别</h2>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> spring cloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_JZ12_数值的整数次方题解</title>
      <link href="/posts/26957.html"/>
      <url>/posts/26957.html</url>
      
        <content type="html"><![CDATA[<h1 id="剑指offerJZ12数值的整数次方题解"><a href="#剑指offerJZ12数值的整数次方题解" class="headerlink" title="剑指offerJZ12数值的整数次方题解"></a>剑指offer<em>JZ12</em>数值的整数次方题解</h1><blockquote><p><strong>描述</strong></p><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p><p>保证base和exponent不同时为0。不得使用库函数，同时不需要考虑大数问题，也不用考虑小数点后面0的位数。</p><p><strong>示例1</strong></p><blockquote><p>输入：2.00000,3</p><p>返回值：8.00000</p></blockquote><p><strong>示例2</strong></p><blockquote><p>输入：2.10000,3</p><p>返回值：9.26100</p></blockquote><p><strong>示例3</strong></p><blockquote><p>输入：2.00000, -2</p><p>返回值：0.25000</p></blockquote></blockquote><h2 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h2><p>不断进行乘法运算即可。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Solution {    public double Power(double base, int exponent) {        double ans = 1.0;        if (exponent == 0){            return ans;        } else if (exponent &gt; 0){            ans = base;            for (int i = 0; i &lt; exponent - 1; i++) {                ans *= base;            }        } else {            ans = 1 / base;            double temp = ans;            for (int i = exponent + 1; i &lt; 0; i++){                ans *= temp;            }        }        return ans;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="递归法（快速幂）"><a href="#递归法（快速幂）" class="headerlink" title="递归法（快速幂）"></a>递归法（快速幂）</h2><p>算法思路：</p><ol><li>如果是<code>exponent</code>是负数，就先转换，然后进入递归方法</li><li>在递归方法中进行判断，如果<code>exponent</code>为 0，则返回 1.0</li><li>判断<code>exponent</code>为技术还是偶数，如果是奇数，只需将<code>base</code>留出一个，继续进入递归</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Solution {    public double Power(double base, int exponent) {        if (exponent &lt; 0){            base = 1 / base;            exponent /= -1;        }        return pow(base, exponent);    }    public double pow(double base, int exponent){        if (exponent == 1){            return base;        } else if (exponent == 0){            return 1.0;        } else if (exponent == 2){            return base * base;        }        if (exponent % 2 == 1){            return base * pow(base, exponent - 1);        } else {            return pow(pow(base, exponent / 2), 2);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="非递归法（快速幂）"><a href="#非递归法（快速幂）" class="headerlink" title="非递归法（快速幂）"></a>非递归法（快速幂）</h2><p>算法思路：</p><ul><li>$2.0^{7}=2.0^{1+2+4}$，7的二进制位为：0111</li><li>按这样的思路，我们就可以只对指数二进中为 1 的位进行运算</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Solution {    public double Power(double base, int exponent) {        if (exponent &lt; 0){            base = 1 / base;            exponent /= -1;        } else if (exponent == 0) {            return 1.0;        }        double res = 1.0;        while (exponent != 0){            if ((exponent &amp; 1) != 0){                res *= base;            }            base *= base;            exponent &gt;&gt;= 1;        }        return res;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法题解 </tag>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer_JZ11_二进制中的1的个数题解</title>
      <link href="/posts/40431.html"/>
      <url>/posts/40431.html</url>
      
        <content type="html"><![CDATA[<h1 id="剑指offerJZ11二进制中的1的个数题解"><a href="#剑指offerJZ11二进制中的1的个数题解" class="headerlink" title="剑指offerJZ11二进制中的1的个数题解"></a>剑指offer<em>JZ11</em>二进制中的1的个数题解</h1><blockquote><p><strong>描述</strong></p><p>输入一个整数，输出该数32位二进制表示中1的个数。其中负数用补码表示。</p><p><strong>示例1</strong></p><blockquote><p>输入：10</p><p>返回值：2</p></blockquote></blockquote><p><strong>知识点：</strong>位运算</p><h2 id="方法一：除-2-取模法"><a href="#方法一：除-2-取模法" class="headerlink" title="方法一：除 2 取模法"></a>方法一：除 2 取模法</h2><p>使用除 2 取模法还是比较好实现的。</p><p>但是经过测试，在一些负数问题上会出现错误，比如：-2147483648</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Solution {    public int NumberOf1(int n){        int num = 0;        while (n != 0){            int temp = n % 2;            n /= 2;            if (temp == 1){                num++;            }        }        return num;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="方法二：二进制移位运算"><a href="#方法二：二进制移位运算" class="headerlink" title="方法二：二进制移位运算"></a>方法二：二进制移位运算</h2><p>我们可以让 1 从右向左做与运算</p><p>例如：10：1010</p><ul><li>1010 &amp; 0001 = 0000;</li><li>1010 &amp; 0010 = 0010;</li><li>1010 &amp; 0100 = 0000;</li><li>1010 &amp; 1000 = 1000;</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Solution {    public int NumberOf1(int n){        int num = 0;        int mark = 1;        while (mark != 0){            if ((mark &amp; n) != 0){                num++;            }            mark &lt;&lt;= 1;        }        return num;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="方法三：位运算"><a href="#方法三：位运算" class="headerlink" title="方法三：位运算"></a>方法三：位运算</h2><p>考虑二进制数：num: 10010, num - 1: 10001; num &amp; (num - 1) = 10000，这样不就消去了一个 1 吗。而且效率肯定是比前两种方法高的。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Solution {    public int NumberOf1(int n){        int val = n;        int ans = 0;        while (val != 0){            ans++;            val = val &amp; (val - 1);            System.out.println(val);        }        return ans;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法题解 </tag>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nowcoder_NC76_反转链表题解</title>
      <link href="/posts/34898.html"/>
      <url>/posts/34898.html</url>
      
        <content type="html"><![CDATA[<h1 id="nowcoderNC76反转链表题解"><a href="#nowcoderNC76反转链表题解" class="headerlink" title="nowcoderNC76反转链表题解"></a>nowcoder<em>NC76</em>反转链表题解</h1><blockquote><p><strong>描述</strong></p><p>输入一个链表，反转链表后，输出新链表的表头</p><p><strong>示例</strong></p><blockquote><p>输入：  {1,2,3}</p><p>返回值：{3,2,1}</p></blockquote></blockquote><p>这道题目一眼看过去是比较简单的，简答的做法就是创建一个新的链表，然后返回就行了。</p><h2 id="方法一：构造链表"><a href="#方法一：构造链表" class="headerlink" title="方法一：构造链表"></a>方法一：构造链表</h2><p>做法就是先遍历链表，获取每个节点的值，存到一个 ArrayList 中，然后根据这些值创建新的链表即可。</p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">/*public class ListNode {    int val;    ListNode next = null;     ListNode(int val) {        this.val = val;    }}*/import java.util.*; public class Solution {    public ListNode ReverseList(ListNode head) {        if (head == null){            return null;        }        List list = new ArrayList&lt;Integer&gt;();        while (head.next != null){            list.add(head.val);            head = head.next;        }        list.add(head.val);        ListNode node = new ListNode((Integer)list.get(list.size() - 1));        ListNode re = node;        for (int i = list.size() - 2; i &gt;= 0; i--){            node.next = new ListNode((Integer)list.get(i));            node = node.next;        }        return re;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="方法二：使用指针反转"><a href="#方法二：使用指针反转" class="headerlink" title="方法二：使用指针反转"></a>方法二：使用指针反转</h2><p>构造新链表的方法所说简单，但是其消耗的内存是很大的，那有没有一种方法是空间复杂度为 O(1) 的呢？答案，肯定是有点，我们需要两个指针即可。</p><p>算法描述：</p><ol><li>创建指针<code>first</code>，指针指向反转好的链表的第一个节点</li><li>创建指针<code>nex</code>，指向<code>head</code>节点的下一个节点</li><li>移动<code>nex</code>指针：<code>nex = head.next</code></li><li>断开<code>head</code>和<code>nex</code>的连接，连接<code>head</code>和<code>first</code>：<code>head.next = first</code></li><li>移动<code>head</code>和<code>first</code>指针</li><li>重复 3~5</li></ol><p>举例：</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210705140359237.png" alt="初始链表"></p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210705140713984.png" alt="一次循环操作"></p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210705140822781.png" alt="循环结束后"></p><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(1)</li></ul><p>Java 实现：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">/*class ListNode {    int val;    ListNode next = null;    ListNode(int val) {        this.val = val;    }}*//** * @author  howyoung */public class Solution {    public ListNode ReverseList(ListNode head) {        // 指向已经反转好的链表的第一个节点        ListNode first = null;        // 指向待反转列表的第二个节点        ListNode nex = null;        while (head != null){            nex = head.next;            head.next = first;            first = head;            head = nex;        }        return first;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Go 实现：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">package mainimport . "nc_tools"/* * type ListNode struct{ *   Val int *   Next *ListNode * } *//** *  * @param pHead ListNode类  * @return ListNode类*/func ReverseList( pHead *ListNode ) *ListNode {    // write code herevar head *ListNodevar temp *ListNodefor pHead != nil {temp = pHeadpHead = pHead.Nexttemp.Next = headhead = temp}return head}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法题解 </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络知识总结</title>
      <link href="/posts/55932.html"/>
      <url>/posts/55932.html</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络知识总结"><a href="#计算机网络知识总结" class="headerlink" title="计算机网络知识总结"></a>计算机网络知识总结</h1><p><img src="https://gitee.com/sehowyoung/images/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.png" alt="计算机网络"></p><h2 id="网络概述"><a href="#网络概述" class="headerlink" title="网络概述"></a>网络概述</h2><p><img src="https://gitee.com/sehowyoung/images/raw/master/980266035_1565787665824_1ABB2DC3D76311944FFDBE9980FBAADD" alt="网络模型及对应的协议"></p><h2 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h2><h3 id="TCP-和-UDP-的区别"><a href="#TCP-和-UDP-的区别" class="headerlink" title="TCP 和 UDP 的区别"></a>TCP 和 UDP 的区别</h3><ul><li>是否面向连接：TCP 面向连接，UDP 无连接</li><li>传输可靠性：TCP 传输可靠，UDP 传输不可靠</li><li>传输形式：TCP 字节流形式传输，UDP 数据报文段形式传输</li><li>传输效率：TCP 较慢，UDP 较快</li><li>所需资源：TCP 多，UDP 少</li><li>应用场景：TCP 主要应用于通信数据可靠的传输，例如：文件传输、邮件收发等；UDP 主要应用于要求传输速度快的传输，例如：直播等</li></ul><h3 id="TCP-可靠传输"><a href="#TCP-可靠传输" class="headerlink" title="TCP 可靠传输"></a>TCP 可靠传输</h3><ul><li>应用数据被 TCP 分割成数据块</li><li>TCP 会给发送的每一个包编号，接收方对数据包进行排序，把有序数据传给应用层</li><li>校验和：TCP 将保持它首部和数据的校验和，目的是检测传输过程中的变化。</li><li>TCP 的接收端会丢弃重复的数据</li><li>流量控制：TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。TCP 使用的流量控制协议是可变大小的滑动窗口协议。</li><li>拥塞控制：当网络拥塞时，减少数据发送</li><li>ARQ 协议：停止等待 ARQ 协议和连续 ARQ 协议</li><li>超时重传：当 TCP 发出⼀个段后，它启动⼀个定时器，等待⽬的端确认收到这个报⽂段。如果不能及时收到⼀个确认，将重发这个报⽂段。  </li></ul><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h3 id="ARP-协议和-ARP-攻击"><a href="#ARP-协议和-ARP-攻击" class="headerlink" title="ARP 协议和 ARP 攻击"></a>ARP 协议和 ARP 攻击</h3><p>地址解析协议。ARP攻击的第一步就是ARP欺骗。由上述“ARP协议的工作过程”我们知道，ARP协议基本没有对网络的安全性做任何思考，当时人们考虑的重点是如何保证网络通信能够正确和快速的完成——ARP协议工作的前提是默认了其所在的网络是一个善良的网络，每台主机在向网络中发送应答信号时都是使用的真实身份。不过后来，人们发现ARP应答中的IP地址和MAC地址中的信息是可以伪造的，并不一定是自己的真实IP地址和MAC地址，由此，ARP欺骗就产生了。</p><h3 id="ICMP-协议"><a href="#ICMP-协议" class="headerlink" title="ICMP 协议"></a>ICMP 协议</h3><p>它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。</p><h3 id="路由器和交换机的区别"><a href="#路由器和交换机的区别" class="headerlink" title="路由器和交换机的区别"></a>路由器和交换机的区别</h3>]]></content>
      
      
      <categories>
          
          <category> 常识 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程编程</title>
      <link href="/posts/31931.html"/>
      <url>/posts/31931.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java多线程编程"><a href="#Java多线程编程" class="headerlink" title="Java多线程编程"></a>Java多线程编程</h1><h2 id="使用线程"><a href="#使用线程" class="headerlink" title="使用线程"></a>使用线程</h2><p>三种使用方法：</p><ul><li>实现 Runnable 接口</li><li>实现 Callable 接口</li><li>继承 Thread 类</li></ul><p>实现 Runnable 和 Callable 接口的类只能当作一个可以在线程中运行的任务，不是真正意义上的线程，因此最好还需要 Thread 来调用。可以理解为任务是通过线程驱动从而执行的。</p><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>synchronized 保证了代码块在任意时刻最多只有一个线程能执行。</p><p>使用 synchronized：</p><ol><li>找出修改共享变量的线程代码块</li><li>选择一个共享示例作为锁</li><li>使用 synchronized 锁定示例</li></ol><p>使用 synchronized 解决了多线程同步访问共享变量的问题。但是，它的缺点是带来了性能的下降。一方面，synchronized 代码块无法并发执行，另一方面，加锁和解锁会消耗一定的时间</p><h3 id="不需要-synchronized-的操作"><a href="#不需要-synchronized-的操作" class="headerlink" title="不需要 synchronized 的操作"></a>不需要 synchronized 的操作</h3><p>JVM 规范定义了几种原子操作：</p><ul><li>基本类型（long 和 double 除外）赋值</li><li>应用类型赋值</li></ul><p>long 和 double 是 64 位数据，JVM 没有明确规定 64 位赋值操作是不是一个原子操作，不过 X64 平台的 JVM 是把 long 和 double 的赋值作为原子操作实现的。</p><p>单条原子操作的语句不需要同步，多条则需要。有时候，可以通过巧妙地转换将非原子操作变成原子操作</p><h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><p>让线程自己选择锁对象往往会使得代码逻辑混乱，也不利于封装。更好的方法是把<code>synchronized</code>逻辑封装起来。</p><p>如果一个类被设计为允许多线程正确访问，我们就说这个类就是“线程安全”的（thread-safe）</p><p>还有一些不变类，例如<code>String</code>，<code>Integer</code>，<code>LocalDate</code>，它们的所有成员变量都是<code>final</code>，多线程同时访问时只能读不能写，这些不变类也是线程安全的。</p><p>最后，类似<code>Math</code>这些只提供静态方法，没有成员变量的类，也是线程安全的。</p><blockquote><p>没有特殊说明时，一个类默认是非线程安全的。</p></blockquote><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>JVM 允许同一个线程重复获取同一个锁，这种能被同一个线程反复获取的锁就叫做<code>可重入锁</code></p><p>感觉跟操作系统的一样，都是互斥、占有并等待、非抢占式、环路等待</p><p>解决方法：保证线程获取锁的顺序一致。</p><h2 id="wait-和-notify"><a href="#wait-和-notify" class="headerlink" title="wait() 和 notify()"></a>wait() 和 notify()</h2><p>多线程协调运行的原则：当条件不满足时，线程进入等待状态；当条件满足时，被唤醒。</p><p>Thread.wait() 方法会使当前线程进入等待状态；</p><p>Thread.notify() 方法会唤醒该进程；</p><p>Thread.notifyAll() 方法会唤醒列表中的全部进程</p><p>已唤醒的线程还需要重新获得锁后才能继续执行</p><h2 id="Concurrent"><a href="#Concurrent" class="headerlink" title="Concurrent"></a>Concurrent</h2><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>位于<code>java.util.concurrent</code>包中，用于替换<code>synchronized</code>加锁。</p><p>ReentrantLock 保证了只有一个线程可以执行临界区代码</p><p>synchronized 的缺点：</p><ul><li>很重</li><li>获取时必须一直等待，没有额外的尝试机制</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Counter{    private final Lock lock = new ReentrantLock();    private int count;        public void add(int n){        lock.lock();        try{            count += n;        } finally {            lock.unlock();        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ReentrantLock 和 synchronized 一样，都是可重入锁，不同的是，ReentrantLock 可以尝试获取锁：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">if (lock.tryLock(1, TimeUnit.SECONDS)) {    try{            } finally {        lock.unlock();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码在尝试获取锁的时候，最多等待1秒。如果1秒后仍未获取到锁，<code>tryLock()</code>返回<code>false</code>，程序就可以做一些额外处理，而不是无限等待下去。</p><h3 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h3><p>synchronized 锁有 wait() 和 notify() 两个功能，而 ReentrantLock 没有，因此就需要借助 Contition 对象来实现。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class TaskQueue {    private final Lock lock = new ReentrantLock();    private final Condition condition = lock.newCondition();    private Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();    public void addTask(String s) {        lock.lock();        try {            queue.add(s);            condition.signalAll();        } finally {            lock.unlock();        }    }    public String getTask() {        lock.lock();        try {            while (queue.isEmpty()) {                condition.await();            }            return queue.remove();        } finally {            lock.unlock();        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>Condition</code>提供的<code>await()</code>、<code>signal()</code>、<code>signalAll()</code>原理和<code>synchronized</code>锁对象的<code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code>是一致的，并且其行为也是一样的：</p><ul><li><code>await()</code>会释放当前锁，进入等待状态；</li><li><code>signal()</code>会唤醒某个等待线程；</li><li><code>signalAll()</code>会唤醒所有等待线程；</li><li>唤醒线程从<code>await()</code>返回后需要重新获得锁。</li></ul><h3 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h3><p>为了实现多个线程同时读，但只允许一个线程进行写入操作，引入 ReadWriteLock：</p><ul><li>只允许一个线程写入（其他线程既不能写入也不能读取）；</li><li>没有写入时，多个线程允许同时读（提高性能）。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Counter {    private final ReadWriteLock rwlock = new ReentrantReadWriteLock();    private final Lock rlock = rwlock.readLock();    private final Lock wlock = rwlock.writeLock();    private int[] counts = new int[10];    public void inc(int index) {        wlock.lock(); // 加写锁        try {            counts[index] += 1;        } finally {            wlock.unlock(); // 释放写锁        }    }    public int[] get() {        rlock.lock(); // 加读锁        try {            return Arrays.copyOf(counts, counts.length);        } finally {            rlock.unlock(); // 释放读锁        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h3><p>ReadWriteLock 可以解决多线程同时读，但只有一个线程能写。</p><p><code>StampedLock</code>和<code>ReadWriteLock</code>相比，改进之处在于：读的过程中也允许获取写锁后写入！这样一来，我们读的数据就可能不一致，所以，需要一点额外的代码来判断读的过程中是否有写入，这种读锁是一种乐观锁。</p><p>乐观锁的意思就是乐观地估计读的过程中大概率不会有写入，因此被称为乐观锁。反过来，悲观锁则是读的过程中拒绝有写入，也就是写入必须等待。显然乐观锁的并发效率更高，但一旦有小概率的写入导致读取的数据不一致，需要能检测出来，再读一遍就行。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Point {    private final StampedLock stampedLock = new StampedLock();    private double x;    private double y;    public void move(double deltaX, double deltaY) {        long stamp = stampedLock.writeLock(); // 获取写锁        try {            x += deltaX;            y += deltaY;        } finally {            stampedLock.unlockWrite(stamp); // 释放写锁        }    }    public double distanceFromOrigin() {        long stamp = stampedLock.tryOptimisticRead(); // 获得一个乐观读锁        // 注意下面两行代码不是原子操作        // 假设x,y = (100,200)        double currentX = x;        // 此处已读取到x=100，但x,y可能被写线程修改为(300,400)        double currentY = y;        // 此处已读取到y，如果没有写入，读取是正确的(100,200)        // 如果有写入，读取是错误的(100,400)        if (!stampedLock.validate(stamp)) { // 检查乐观读锁后是否有其他写锁发生            stamp = stampedLock.readLock(); // 获取一个悲观读锁            try {                currentX = x;                currentY = y;            } finally {                stampedLock.unlockRead(stamp); // 释放悲观读锁            }        }        return Math.sqrt(currentX * currentX + currentY * currentY);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>代码更复杂</li><li>stampedLock 是不可重入锁</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 多线程编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统知识点总结</title>
      <link href="/posts/19060.html"/>
      <url>/posts/19060.html</url>
      
        <content type="html"><![CDATA[<h1 id="数据库系统"><a href="#数据库系统" class="headerlink" title="数据库系统"></a>数据库系统</h1><h2 id="SQL-和数据库管理系统"><a href="#SQL-和数据库管理系统" class="headerlink" title="SQL 和数据库管理系统"></a>SQL 和数据库管理系统</h2><h3 id="sql"><a href="#sql" class="headerlink" title="sql"></a>sql</h3><blockquote><p>结构化查询语言，实现数据的查询和更新，关系型数据通用语言</p></blockquote><p>分类：</p><ul><li>DDL：数据定义语言，结构上的操作</li><li>DML：数据操纵语言，数据上的操作（增删改操作）</li><li>DCL：数据控制语言，授权操作</li><li>DQL：数据查询语言，查询操作</li></ul><h3 id="DBMS"><a href="#DBMS" class="headerlink" title="DBMS"></a>DBMS</h3><blockquote><p>数据库管理系统，对数据实现管理和操纵</p></blockquote><ul><li>RDBMS：关系型数据库<ul><li>二元关系模型（表格形式）</li></ul></li><li>NoSQL：非关系型数据库<ul><li>弥补关系型数据库管理系统的不足（高 IO 瓶颈）</li></ul></li></ul><h2 id="SQL-语言的基本使用"><a href="#SQL-语言的基本使用" class="headerlink" title="SQL 语言的基本使用"></a>SQL 语言的基本使用</h2><ol><li><p>查询<code>emp</code>表工资在 1000 到 2000 之间的员工信息(范围查询)</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select * from emp where sal between 1000 and 2000;-- 或者 select * from emp where sal &gt;= 1000 and sal &lt;= 2000;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>查询员工编号为<code>7369</code>，<code>7788</code>，<code>7521</code>的员工信息</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- 组合查询select * from emp where empno = 7369 or mpno = 7788 or mpno = 7521;-- 集合查询select &amp; from emp where empno in (7369,7788,7521);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>查询<code>emp</code>中所有的职位信息</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- 使用distinct对结果去重select distinct job from emp;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>模糊查询</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"># 查询员工名称包含L的select * from emp where ename like '%L%';# 查询员工名称第二个字是L的select * from emp where ename like '_L%';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>排序</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"># 升序select * from emp order by sal;# 降序select * from emp order by sal desc;# 工资升序，如果一样，按empno降序排序select * from emp order by sal, empno desc;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>限制结果查询</p><p>limit index, length;</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">#select * from emp limit 5;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>查询每个部门的部门编号和平均工资</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select deptno, avg(sal) avg from emp group by deptno;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>查询部门平均工资 &gt;2000 的部门编号及其平均工资</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select deptno, avg(sal) avg from emp group by deptno having avg &gt; 2000 ;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>having 和 where 的区别？</p><ol><li>where 和 having 都是实现条件过滤</li><li>where 使用在过滤之前，having 在过滤之后，为了能够在分组之后再次对结果进行过滤</li><li>where 不能使用聚合函数，having 可以使用聚合函数</li></ol></li></ol><h2 id="高级查询"><a href="#高级查询" class="headerlink" title="高级查询"></a>高级查询</h2><p><a href="https://blog.csdn.net/plg17/article/details/78758593">图解MySQL 内连接、外连接、左连接、右连接、全连接的区别</a></p><h3 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h3><blockquote><p>连接表都匹配的记录才会出现在最终的结果里</p><p>与连接顺序无关</p></blockquote><p>查询所有的员工的名称、薪水以及他们部门的名称</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select * from emp, dept where emp.deptno = dept.deptno;# 或者使用inner join ... on ..select * from emp inner join dept on emp.deptno = dept.deptno;# 或者使用inner join ... using ...# using注意事项：两张表需要进行关联的字段名称一致select * from emp inner join dept using(deptno)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><blockquote><p>左外连接：left join … on ..</p><p>右外连接：right join .. on ..</p><p>以其中一张表为驱动表，与另外一张表的每条记录进行匹配，如果能够匹配则进行关联并展示，如果匹配不到，以 null 填充</p><p>与连接顺序有关</p></blockquote><h2 id="SQL-语句的执行原理"><a href="#SQL-语句的执行原理" class="headerlink" title="SQL 语句的执行原理"></a>SQL 语句的执行原理</h2><p><a href="https://database.51cto.com/art/202101/639231.htm">说说MySQL的架构体系 - 51CTO.COM</a></p><p><img src="https://gitee.com/sehowyoung/images/raw/master/202108020804965.jpeg" alt="MySQL体系架构"></p><h3 id="MySQL-的基本架构和执行流程"><a href="#MySQL-的基本架构和执行流程" class="headerlink" title="MySQL 的基本架构和执行流程"></a>MySQL 的基本架构和执行流程</h3><p><img src="https://gitee.com/sehowyoung/images/raw/master/202108021046987.png" alt="MySQL 5.X 的基础架构"></p><ul><li><p>连接器：建立客户端和服务端的连接，权限获取，维持管理链接</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql -h$ip -P$port -u$user -p<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>mysql 客户端连接工具，tcp握手成功，需要进行身份认证</p><p>查询连接状态：</p><ul><li><p>短连接：执行少数几次查询就会断开，浪费大量资源</p></li><li><p>长连接：连接成功之后一直保持连接，wait_timeout 默认连接时长</p></li><li><p>```sql<br>show variables like ‘wait_timeout’;</p><pre class="line-numbers language-none"><code class="language-none">```sqlshow processlist;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><p>长连接驻留内存的解决办法：</p><ol><li>固定时间自动重新连接</li><li><code>mysql_reset_connection</code>重置连接</li></ol></li><li><p>查询缓存</p><p>query_cache_type：查询缓存类型，默认关闭，如果要使用，需要将值设为<code>DEMAND</code></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select SQL_CACHE * from emp where empno = 7788;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>适用于大量查询操作。</p><p><strong>注意：</strong>只有在 MySQL 5.X 中还存在，MySQL 8.X 中已移除</p></li><li><p>分析器</p><p>词法分析：检测每个单词的含义</p><p>语法分析：语法规则校验，语法是否正确</p></li><li><p>优化器</p><p>选择最优解</p><p>索引选择或执行顺序会影响执行效率，因此需要最优选择。</p></li><li><p>执行器</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select * from emp where deptno = 10;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>对表操作权限进行验证</li><li>innodb 存储引擎安行查询 deptno </li><li>将结果返回</li></ol></li></ul><h3 id="行列转换"><a href="#行列转换" class="headerlink" title="行列转换"></a>行列转换</h3><ul><li><p>纵表转横表</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select username sum(case course when 'mysql' then score else 0 end) mysql from stu group by username;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">create view vstu as select username,sum(case course when 'mysql' then score else 0 end)mysql,sum(case course when 'hive' then score else 0 end) hive,sum(case course when 'python' then score else 0 end) pythonfrom stu group by username<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>横表转纵表</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select username, 'mysql' course, mysql score from vstuunion allselect sername, 'hive' course, hive score from vstuunion allselect sername, 'python' course, p score from vstu<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>数据库存储引擎是数据库底层软件组织，数据库管理系统(DBMS)使用数据引擎进行创建、查询、更新和删除数据。不同的存储引提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引，还可以获得特定的功能，Mysq的核心就是存储引擎。</p><p>MySQL 底层设计采用可插拔是的存储引擎用户可以根据需求，选挥或自定义存储引擎。MySQL5 之后默认存储引为 Innodb</p><p>查看 MySQL 支持的存储引擎：<code>show engines;</code></p><h3 id="存储引擎的对比"><a href="#存储引擎的对比" class="headerlink" title="存储引擎的对比"></a>存储引擎的对比</h3><div class="table-container"><table><thead><tr><th>特点</th><th>Myisam</th><th>BDB</th><th>Memory</th><th>InnoDB</th><th>Archive</th></tr></thead><tbody><tr><td>存储限制</td><td>无</td><td>无</td><td>有</td><td>64TB</td><td>无</td></tr><tr><td>事务安全</td><td></td><td>支持</td><td></td><td>支持</td><td></td></tr><tr><td>锁机制</td><td>表锁</td><td>页锁</td><td>表锁</td><td>支持</td><td>行锁</td></tr><tr><td>B树索引</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td><td></td></tr><tr><td>哈希索引</td><td></td><td></td><td>支持</td><td>支持</td><td></td></tr><tr><td>全文索引</td><td>支持</td><td></td><td></td><td></td><td></td></tr><tr><td>集群索引</td><td></td><td></td><td></td><td>支持</td><td></td></tr><tr><td>数据缓存</td><td></td><td></td><td>支持</td><td>支持</td><td></td></tr><tr><td>索引缓存</td><td>支持</td><td></td><td>支持</td><td>支持</td><td></td></tr><tr><td>数据可压缩</td><td>支持</td><td></td><td></td><td></td><td>支持</td></tr><tr><td>空间使用</td><td>低</td><td>低</td><td>N/A</td><td>高</td><td>非常低</td></tr><tr><td>内存使用</td><td>低</td><td>低</td><td>中等</td><td>高</td><td>低</td></tr><tr><td>批量插入速度</td><td>高</td><td>高</td><td>高</td><td>低</td><td>非常高</td></tr><tr><td>支持外键</td><td></td><td></td><td></td><td>支持</td></tr></tbody></table></div><ul><li><p>InnoDB</p><p>MySQL 默认存储引擎。事务型数据库</p><ol><li>数据底层存储：数据表文件 —&gt; .frm（表结构）文件和 .ibd（数据和索引）文件</li><li>事务：支持热备份，对事物完整性要求比较高时使用</li><li>锁的粒度：采用 MVVC 支持高并发操作，支持四种事务隔离级别，行锁</li><li>存储索引特点：采用聚簇索引</li><li>场景<ol><li>更新查找频繁，高并发</li><li>要求事务</li><li>外键约束</li></ol></li></ol></li><li><p>Myisam</p><ol><li>存储形式：数据表文件 —&gt; .frm .MYD .MYI （数据和索引分离）</li><li>事务：不支持</li><li>存储特点：非聚簇索引</li><li>其他：全文检索、压缩，延迟更新索引</li><li>场景<ol><li>count 计算</li><li>查询</li></ol></li></ol></li><li><p>Memory</p><p>数据保存在内存中，增删改查效率高，但不能持久化</p><p>不支持事务，表级锁</p></li></ul><h3 id="如何设置存储引擎"><a href="#如何设置存储引擎" class="headerlink" title="如何设置存储引擎"></a>如何设置存储引擎</h3><p>创建表时修改存储引擎：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">create table t_name() engine = INNODB;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看某张表的基本信息：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">show tables status from [database] where name = '[name]' \G<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>为了提升查询效率创建数据结构</p><h3 id="常见索引模型"><a href="#常见索引模型" class="headerlink" title="常见索引模型"></a>常见索引模型</h3><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>key —— value 方式存储</p><p>key 经过 hash 计算获取到一个值，区该位置寻找数据（值）。</p><p>哈希碰撞，利用“拉链法”解决</p><p>适合等值查询，不适合范围查询</p><h4 id="有序数组"><a href="#有序数组" class="headerlink" title="有序数组"></a>有序数组</h4><p>整个数组中排列是有序的，查找方便。</p><p>等职查询和范围查询都比较适合，当时插入、删除困难。</p><h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><p>二叉树的结构进行存储</p><p>树最影响效率的是树的深度，尽可能平衡</p><p>真正存储采用多叉树  </p><h3 id="InnoDB-索引模式"><a href="#InnoDB-索引模式" class="headerlink" title="InnoDB 索引模式"></a>InnoDB 索引模式</h3><p>InnoDB 根据主键的顺序以索引的方式进行存储</p><p>InnoDB 中默认采用 B+ 树索引模型，数据组织存储到 B+ 树中。</p><p>索引类型分为主键索引和非主键索引</p><ul><li>主键索引：叶子节点中存储的整行数据，称为聚簇索引</li><li>非主键索引：叶子节点中存储的主键的值，称为二级索引</li></ul><p>主键索引与非主键索引的区别：</p><ul><li>主键索引只需要查找一次 B+ 树就可以定位数据</li><li>非主键索引第一次只能查找到主键索引，需要根据主键索引再次查找整条记录</li></ul><p>索引是需要维护的。</p><ul><li>添加索引避免在增删操作较多的表</li><li>索引自身也需要占用空间存储</li></ul><p>索引的选择</p><ul><li>优先选择主键索引</li><li>逐渐长度越小越好</li><li>尽量不要选择业务字段作为主键</li><li>表数据量较多</li><li>尽可能选择高基数列</li></ul><h3 id="添加索引"><a href="#添加索引" class="headerlink" title="添加索引"></a>添加索引</h3><ol><li><p>查看索引</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">show index from emp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>普通索引</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">create index index_name on [table]([col])create table [name](col ...     ...    index index_name(col))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>删除索引</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">drop index index_name on [table]([col])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>唯一索引</p><p>索引列必须唯一</p><ul><li><p>添加索引</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">create unique index index_name on [table]([col])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>删除索引</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">alter table name drop index index_name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul></li><li><p>主键索引</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">alter table name add constraint PK_ID primary key (id)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>组合索引</p><p>可以在多个字段添加索引，但是查询索引必须使用第一个字段索引</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">create index index_name on [table](col1, col2, ...)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h2 id="SQL-优化"><a href="#SQL-优化" class="headerlink" title="SQL 优化"></a>SQL 优化</h2><h3 id="使用-explain-分析查询"><a href="#使用-explain-分析查询" class="headerlink" title="使用 explain 分析查询"></a>使用 explain 分析查询</h3><ol><li>type：连接类型<ul><li>ALL：表示全表扫，若表中数据有百万乃至千万，必须要优化，否则性很慢</li><li>Index: full index scan, Index 与 ALL 的区別为 index 只历引，这通常比 ALL 快，因为引文件通常比数据文件小（也就是说 ALL 和 index 都是读全表，但是 index 是从索引中读取的，而ALL 是从硬盘中读取的)</li><li>range：只检索给定范围的行，使用一个索引来选择行，key 列显示使用了那个索引，一般是在你的 where 语句中出现了 between、&gt;、&lt;、in 等的音询，这种范围扫描比全表行要好，因为它只需要开始索引的某一点，而结束语另一点，不用扫描全部索引。</li><li>ref：非唯一性索引扫描，返回匹配某个单独值得所有行，本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，它可能会找到多个符合条件的行，所以它应该属于查找和扫描的混合体</li><li>eq_ref：唯一索引扫描，对于每个索引键，表中只有一条记录与之匹配，常见于主键或唯一索引扫描</li><li>const：表示通过索引一次就找到了，const 用户比 primary key 或者 unique 黑引，因为只匹配一行数据，所以很快；如将逐新置于 where 列表中，Mysql 就将改查询转换为一个常量</li><li>system：表示只有一行记（等于系统表），这是 const 类的特列，平时不会出现，可以忽路不记</li></ul></li><li>possiable_keys：可能用到的索引</li><li>key：真正用到的索引</li><li>key_len：索引的长度，越短越好</li><li>ref：索引的哪一列被使用了</li><li>rows：索引的函数</li></ol><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">explain select * from stu where id = 1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="profilling-分析语句执行时间"><a href="#profilling-分析语句执行时间" class="headerlink" title="profilling 分析语句执行时间"></a>profilling 分析语句执行时间</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"># 打开统计分析set profilling;# 查看执行时间show profile;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="sql-基本优化原则"><a href="#sql-基本优化原则" class="headerlink" title="sql 基本优化原则"></a>sql 基本优化原则</h3><ol><li>字段维护在 B 树上，数据类型有要求（设计 3NF）<ol><li>尽可能使用较小类型</li><li>尽量使用简单类型</li><li>尽可能设置合理的长度，固定长度比变化的长度快</li><li>not null 约束</li></ol></li><li>sql 优化<ol><li>尽量不要使用 select *</li><li>sql 尽量减少嵌套</li><li>尽量用 limit 限制字段</li></ol></li><li>索引失效的状况<ol><li>索引列使用函数</li><li>使用模糊查询</li><li>索引列不要运用计算</li><li>索引列尽量不要使用 (!\=&lt;&gt;)</li></ol></li><li>in 和 exists<ol><li>in 把内表和外表进行 hash 连接，exists 把外表 loop</li><li>内表和外表数据量差距不大，性能基本相同</li><li>内表小使用 in，外表比较小 exists</li></ol></li></ol><h2 id="数据库系统原理"><a href="#数据库系统原理" class="headerlink" title="数据库系统原理"></a>数据库系统原理</h2><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>事务是指满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。</p><p>ACID：</p><ul><li>原子性（Atomicity）：事务被视为不可分割的最小单元，事务的所有操作要么全部成功，要么全部失败</li><li>一致性（Consistency）：数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。</li><li>隔离性（Isolation）：一个事务所做的修改在最终提交前，对其它事务不可见</li><li>持久性（Durability）：一旦事务提交，其所作的修改将会永远保存在数据库中。</li></ul><p>AUTOCOMMIT：MySQL 默认采用自动提交模式。</p><h3 id="并发一致性问题"><a href="#并发一致性问题" class="headerlink" title="并发一致性问题"></a>并发一致性问题</h3><p>在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题</p><h4 id="丢失修改"><a href="#丢失修改" class="headerlink" title="丢失修改"></a>丢失修改</h4><p>丢失修改指一个事务的更新操作被另外一个事务的更新操作替换。一般在现实生活中常会遇到，例如：$T<em>{1}$和$T</em>{2}$两个事务都对一个数据进行修改，$T<em>{1}$先修改并提交生效，$T</em>{2}$随后修改，$T<em>{2}$的修改覆盖了$T</em>{1}$的修改</p><h4 id="读脏数据"><a href="#读脏数据" class="headerlink" title="读脏数据"></a>读脏数据</h4><p>读脏数据指在不同的事务下，当前事务可以读到另外事务未提交的数据。例如：$T<em>{!}$修改一个数据但未提交，$T</em>{2}$随后读取这个数据。如果$T<em>{1}$撤销了这次修改，那么$T</em>{2}$读取的数据是脏数据。</p><h4 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h4><p>不可重复读指在一个事务内多次读取同一数据集合。在这一事务还未结束前，另一事务也访问了该同一数据集合并做了修改，由于第二个事务的修改，第一次事务的两次读取的数据可能不一致。例如：$T<em>{2}$读取一个数据，$T</em>{1}$对该数据做了修改。如果$T_{2}$再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p><h4 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h4><p>幻读本质上也属于不可重复读的情况，$T<em>{1}$读取某个范围的数据，$T</em>{2}$在这个范围内插入新的数据，$T_{1}$再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</p><p>产生并发不一致性问题的主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。</p><h3 id="封锁"><a href="#封锁" class="headerlink" title="封锁"></a>封锁</h3><h4 id="封锁粒度"><a href="#封锁粒度" class="headerlink" title="封锁粒度"></a>封锁粒度</h4><ul><li>MySQL提供了两种封锁粒度：行级锁以及表级锁</li><li>应该尽量之锁定需要修改的那部分数据，而不是所有资源。锁定的数据量越少，发生锁争的可能就越小，系统的并发程度就越高</li><li>加锁需要消耗资源，锁的各种行为都会增加系统开销。因此锁的粒度越小，系统开销越大</li><li>在选择粒度时，需要在锁开销和并发程度之间做一个权衡</li></ul><h4 id="封锁类型"><a href="#封锁类型" class="headerlink" title="封锁类型"></a>封锁类型</h4><ul><li><p>读写锁</p><ul><li>互斥锁：简写为 X 锁，又称写锁</li><li>共享锁：简写为 S 锁，又称读锁</li></ul><p>两个规定：</p><ul><li>一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。枷锁期间其他事务不能对 A 加任何锁</li><li>一个事务对数据对象 A 加了 S 锁，只可以对 A 进行读取操作，无法进行更新操作。加锁期间其他事务能对 A 加 S 锁，但是不能加 X 锁</li></ul></li><li><p>意向锁</p><p>使用意向锁可以更容易地支持多粒度封锁</p><p>在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。</p><p>意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：</p><ul><li><p>一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；</p></li><li><p>一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。</p></li></ul><p>通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207214442687.png" alt="意向锁兼容关系"></p></li></ul><h4 id="封锁协议"><a href="#封锁协议" class="headerlink" title="封锁协议"></a>封锁协议</h4><ol><li><p>三级封锁协议</p><ol><li><p>一级封锁协议</p><p>事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁</p><p>可以解决丢失修改问题。</p></li><li><p>耳机封锁协议</p><p>在一级的基础上，要求读取数据 A 时必须加 S 锁，读完马上释放 S 锁。</p><p>可以解决读脏数据。</p></li><li><p>三级封锁协议</p><p>在二级的基础上，要求读取数据 A 时必须加 S 锁，指导事务结束才能释放</p><p>可以解决不可重复读问题</p></li></ol></li><li><p>两段封锁协议</p><p>加锁和解锁分为两个阶段进行。</p><p>可串行化调度是指：通过并发控制，使得并发执行的事务结果与某个串行执行的书屋结果相同，串行执行的事务互不干扰，不会出现并发一致性问题。</p><p>事务遵循两段封锁协议是保证可串行化调度的充分条件。</p></li></ol><h4 id="MySQL-隐式与显示锁定"><a href="#MySQL-隐式与显示锁定" class="headerlink" title="MySQL 隐式与显示锁定"></a>MySQL 隐式与显示锁定</h4><p>MySQL 的 InnoDB 存储引擎采用两段封锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻释放，这被称为隐式锁定</p><p>InnoDB 也可以使用特定的语句进行显示锁定：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT ... LOCK In SHARE MODE;SELECT ... FOR UPDATE;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="索引-1"><a href="#索引-1" class="headerlink" title="索引"></a>索引</h3><h4 id="B-Tree原理"><a href="#B-Tree原理" class="headerlink" title="B+ Tree原理"></a>B+ Tree原理</h4><p>B+ Tree 是基于 B Tree（Balance Tree，平衡树） 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。</p><p>在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 $key<em>{i}$ 和 $key</em>{i+1}$，且不为 null，则该指针指向节点的所有 key 大于等于 $key<em>{i}$ 且小于等于 $key</em>{i+1}$</p><h2 id="学习视频"><a href="#学习视频" class="headerlink" title="学习视频"></a>学习视频</h2><ol><li><a href="https://www.aliyundrive.com/s/ZBsgyhbhZ4N">https://www.aliyundrive.com/s/ZBsgyhbhZ4N</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 常识 </category>
          
          <category> 数据库系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
            <tag> 数据库系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http知识总结</title>
      <link href="/posts/24206.html"/>
      <url>/posts/24206.html</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP总结"><a href="#HTTP总结" class="headerlink" title="HTTP总结"></a>HTTP总结</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="HHTP-基本概念"><a href="#HHTP-基本概念" class="headerlink" title="HHTP 基本概念"></a>HHTP 基本概念</h3><p>客户端发送一个请求报文给服务器，服务器根据请求报文中的信息进行处理，并将处理结果放入响应报文中返回给客户端。</p><p><strong>请求报文：</strong></p><ul><li><p>第一行请求方法、URL、协议版本；</p></li><li><p>多行请求首部 header，每个首部都有一个名称，以及对应的值</p></li><li><p>空行分隔首部与主体</p></li><li><p>请求内容主体</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">GET http://www.example.com/ HTTP/1.1Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9,en;q=0.8Cache-Control: max-age=0Host: www.example.comIf-Modified-Since: Thu, 17 Oct 2019 07:18:26 GMTIf-None-Match: "3147526947+gzip"Proxy-Connection: keep-aliveUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 xxxparam1=1&amp;param2=2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p><strong>响应报文：</strong></p><ul><li><p>第一行包含协议版本、状态码以及描述</p></li><li><p>多行是首部内容</p></li><li><p>空行分隔首部与主体</p></li><li><p>响应的主体</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">HTTP/1.1 200 OKAge: 529651Cache-Control: max-age=604800Connection: keep-aliveContent-Encoding: gzipContent-Length: 648Content-Type: text/html; charset=UTF-8Date: Mon, 02 Nov 2020 17:53:39 GMTEtag: "3147526947+ident+gzip"Expires: Mon, 09 Nov 2020 17:53:39 GMTKeep-Alive: timeout=4Last-Modified: Thu, 17 Oct 2019 07:18:26 GMTProxy-Connection: keep-aliveServer: ECS (sjc/16DF)Vary: Accept-EncodingX-Cache: HIT<span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token name">doctype</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Example Domain<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>// 省略... <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p><strong>URL与URI</strong></p><p>HTTP 使用 URL（ Uniform Resource Locator，统一资源定位符）来定位资源，它是 URI（Uniform Resource Identifier，统一资源标识符）的子集，URL 在 URI 的基础上增加了定位能力。</p><h3 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h3><ol><li><strong>GET</strong>：获取资源</li><li><strong>HEAD</strong>：获取报文头部</li><li><strong>POST</strong>：传输实体主体</li><li><strong>PUT</strong>：上传文件</li><li><strong>PATCH</strong>：对资源进行部分修改</li><li><strong>DELETE</strong>：删除文件</li><li><strong>OPTIONS</strong>：查询支持的方法</li><li><strong>CONNECT</strong>：要求在与代理服务器通信时建立隧道</li><li><strong>TRACE</strong>：追踪路径</li></ol><h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h3><div class="table-container"><table><thead><tr><th>响应码</th><th>类别</th><th>含义</th></tr></thead><tbody><tr><td>1XX</td><td>信息性状态码</td><td>接收的请求正在处理</td></tr><tr><td>2XX</td><td>成功状态码</td><td>请求正常处理完毕</td></tr><tr><td>3XX</td><td>重定向状态码</td><td>需要进行附加操作以完成请求</td></tr><tr><td>4XX</td><td>客户端错误状态吗</td><td>服务器无法处理请求</td></tr><tr><td>5XX</td><td>服务器错误状态码</td><td>服务器处理请求出错</td></tr></tbody></table></div><h3 id="HTTP-长连接，短连接"><a href="#HTTP-长连接，短连接" class="headerlink" title="HTTP 长连接，短连接"></a>HTTP 长连接，短连接</h3><ul><li>HTTP/1.0 默认使用短连接，HTTP/1.1默认使用长连接</li><li>短连接：客户端和服务器每进行一次 HTTP 操作就建立一次连接，任务结束就中断连接；长连接：当一个网页打开后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，客户端再次访问服务器时，会继续使用这一条连接。</li><li>HTTP 协议的长连接和短连接实质上是 TCP 协议的长连接和短连接</li></ul><h3 id="HTTP-1-0-和-HTTP-1-1-的区别"><a href="#HTTP-1-0-和-HTTP-1-1-的区别" class="headerlink" title="HTTP/1.0 和 HTTP/1.1 的区别"></a>HTTP/1.0 和 HTTP/1.1 的区别</h3><ul><li>长连接与短连接</li><li>状态码：HTTP/1.1 增加了一些状态码</li><li>缓存处理：HTTP/1.0 中主要使用 if-Modified-Since，HTTP/1.1 引入了更多的缓存控制策略，如：if-None-Match等</li><li>带宽优化及网络连接的使用：HTTP/1.0 中存在一些浪费带宽的现象，不支持断点续传；HTTP/1.1 在请求头中引入了 range 头域，允许只请求资源的某个部分，可以充分利用带宽</li></ul><h3 id="HTTP-2-0-和-HTTP-1-X-的区别"><a href="#HTTP-2-0-和-HTTP-1-X-的区别" class="headerlink" title="HTTP/2.0 和 HTTP/1.X 的区别"></a>HTTP/2.0 和 HTTP/1.X 的区别</h3><ul><li>新的二进制格式：HTTP/1.x 的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认 0 和 1 的组合。基于这种考虑 HTTP/2.0 的协议解析决定采用二进制格式，实现方便且健壮。</li><li>多路复用：即连接共享，即每一个request都是是用作连接共享机制的。一个 request 对应一个 id，这样一个连接上可以有多个 request，每个连接的 request 可以随机的混杂在一起，接收方可以根据 request 的 id 将 request 再归属到各自不同的服务端请求里面。</li><li>header 压缩：HTTP/1.x 的 header 带有大量信息，而且每次都要重复发送，HTTP/2.0 使用 encoder 来减少需要传输的 header 大小，通讯双方各自 cache 一份 header fields 表，既避免了重复 header 的传输，又减小了需要传输的大小。</li><li>服务端推送：例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了。</li></ul><h2 id="cookies"><a href="#cookies" class="headerlink" title="cookies"></a>cookies</h2><p>HTTP协议是无状态的，为了让HTTP协议尽可能简单，使它能够处理大量事务。HTTP/1.1 引入了Cookies来保存状态信息。</p><p>Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。</p><p>Cookie 曾一度用于客户端数据的存储，因为当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API（本地存储和会话存储）或 IndexedDB。</p><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><ul><li>会话状态管理（如用户登陆状态、购物车、游戏分数或其他需要记录的信息）</li><li>个性化设置（如用户自定义设置、主题等）</li><li>浏览器行为跟踪（如跟踪分析用户行为等）</li></ul><h3 id="创建过程"><a href="#创建过程" class="headerlink" title="创建过程"></a>创建过程</h3><ol><li>服务器发送的响应报文包含 Set-Cookie 首部字段，客户端得到响应报文后把Cookie 内容保存到浏览器中</li><li>客户端之后对同一服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 Cookie 请求首部字段发送给服务器</li></ol><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li>会话期 Cookie：浏览器关闭以后会被自动删除</li><li>持久性 Cookie：指定过期时间或有效期之后就成为了持久性的 Cookie</li></ul><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>Domain 标识指定了哪些主机可以接受 Cookie。如果不指定，默认为当前文档的主机（不包含子域名）。如果指定了 Domain，则一般包含子域名。</p><p>Path 标识指定了主机下的哪些路径可以接受 Cookie（该路径必须存在于请求 URL 中）</p><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><p>在 JavaScript 中通过 <code>document.cookie</code> 属性，你可以创建、维护和删除 cookie。创建 cookie 时该属性等同于 <code>Set-Cookie</code> 消息头，而在读取 cookie 时则等同于 <code>Cookie</code> 消息头。在创建一个 cookie 时，你需要使用和 <code>Set-Cookie</code> 期望格式相同的字符串：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">document<span class="token punctuation">.</span>cookie<span class="token operator">=</span><span class="token string">"name=Nicholas;domain=nczonline.net;path=/"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>设置 <code>document.cookie</code> 属性的值并不会删除存储在页面中的所有 cookie。它只简单的创建或修改字符串中指定的 cookie。下次发送一个请求到服务器时，通过 <code>document.cookie</code> 设置的 cookie 会和其它通过 <code>Set-Cookie</code> 消息头设置的 cookie 一并发送至服务器。这些 cookie 并没有什么明确的不同之处。</p><h3 id="HttpOnly"><a href="#HttpOnly" class="headerlink" title="HttpOnly"></a>HttpOnly</h3><p>标记为 HttpOnly 的 Cookie 不能被 JavaScript 脚本调用。跨站脚本攻击(XSS)常常使用 JavaScript 的<code>document.cookie</code>API 窃取用户的 Cookie 信息，因此使用 HttpOnly 标记可以在一定程度上避免 XSS 攻击</p><h3 id="Secure"><a href="#Secure" class="headerlink" title="Secure"></a>Secure</h3><p>标记为 Secure 的 Cookie 只能通过被 HTTPS 协议加密过的请求发送给服务端。但即使设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确实的安全保障。</p><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。</p><p>Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。</p><p>使用 Session 维护用户登录状态的过程如下：</p><ol><li><p>用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中</p></li><li><p>服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID</p></li><li><p>服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中</p></li><li><p>客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。</p></li></ol><p>应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。</p><h3 id="浏览器禁用-Cookie"><a href="#浏览器禁用-Cookie" class="headerlink" title="浏览器禁用 Cookie"></a>浏览器禁用 Cookie</h3><p>此时无法使用 Cookie 来保存用户信息，只能使用 Session。除此之外，不能再将 Session ID 存放到 Cookie 中，而是使用 URL 重写技术，将 Session ID 作为 URL 的参数进行传递。</p><h3 id="Cookie-和-Session-选择"><a href="#Cookie-和-Session-选择" class="headerlink" title="Cookie 和 Session 选择"></a>Cookie 和 Session 选择</h3><ul><li>Cookie 只能存储 ASCII 码字符串；Session 可以存储任何类型的字符串</li><li>Cookie 存储在浏览器中，容易被恶意查看。如果是隐私数据，建议加密</li><li>对于大型网站，如果用户所有信息全部存储在 Session 中，那么开销会很大</li></ul><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>缓解服务器压力</li><li>降低客户端获取资源的延迟：缓存通常放在内存中，读取缓存速度快</li></ul><h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><ul><li>让代理服务进行缓存</li><li>让客户端浏览器进行缓存</li></ul><h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p>HTTP/1.1 通过 Cache-Control 首部字段来控制缓存</p><ol><li><p>进制进行缓存</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">Cache-Control: no-store<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>no-store 指令规定不能对请求或响应的任何一部分进行缓存</p></li><li><p>强制确认缓存</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">Cache-Control: no-cache<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>no-cache 指令规定缓存服务器需要先向源服务器验证资源的有效性，只有当缓存资源有效时才能使用该缓存对客户端的请求进行响应。</p></li><li><p>私有缓存和公共缓存</p><p>private 指令规定了将资源作为私有缓存，只能被单独用户使用，一般存储在用户浏览器</p><p>public 指令规定了将资源作为公共缓存，可以被多个用户使用，一般存储在代理服务器中</p></li><li><p>缓存过期机制</p><p>max-age 指令出现在请求报文中，并且缓存资源的缓存时间小于该指令指定的时间，那么就接受该缓存</p><p>max-age 指令出现在响应报文中，表示缓存资源在缓存服务器中保存的时间</p></li></ol><h3 id="缓存验证"><a href="#缓存验证" class="headerlink" title="缓存验证"></a>缓存验证</h3><p>需要先了解 ETag 首部字段的含义，它是资源的唯一标识。URL 不能唯一表示资源，例如 <a href="http://www.google.com/">http://www.google.com/</a> 有中文和英文两个资源，只有 ETag 才能对这两个资源进行唯一标识。</p><p>可以将缓存资源的 ETag 值放入 If-None-Match 首部，服务器收到该请求后，判断缓存资源的 ETag 值和资源的最新 ETag 值是否一致，如果一致则表示缓存资源有效，返回 304 Not Modified。</p><p>Last-Modified 首部字段也可以用于缓存验证，它包含在源服务器发送的响应报文中，指示源服务器对资源的最后修改时间。但是它是一种弱校验器，因为只能精确到一秒，所以它通常作为 ETag 的备用方案。如果响应首部字段里含有这个信息，客户端可以在后续的请求中带上 If-Modified-Since 来验证缓存。服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 200 OK。如果请求的资源从那时起未经修改，那么返回一个不带有实体主体的 304 Not Modified 响应报文。</p><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>HTTP 有以下安全性问题：</p><p>使用明文进行通信，内容可能会被窃听；<br>不验证通信方的身份，通信方的身份有可能遭遇伪装；<br>无法证明报文的完整性，报文有可能遭篡改。<br>HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。</p><p>通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p><img src="https://www.runoob.com/wp-content/uploads/2018/09/https-intro.png" alt="HTTPS工作原理" style="zoom: 67%;"></p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>HTTPS 协议多次握手，导致页面加载时间延长50%</li><li>HTTPS 链接缓存不如 HTTP 高效，会增加开销和功耗</li><li>申请 SSL 需要钱，功能越强大，证书费用越高</li><li>SSL 设计安全算法会消耗 CPU 资源，对服务器资源消耗较大</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://leetcode-cn.com/leetbook/read/tech-interview-cookbook/op9epv/">https://leetcode-cn.com/leetbook/read/tech-interview-cookbook/op9epv/</a></li><li><a href="https://www.kancloud.cn/kancloud/http-cookies-explained/48333">https://www.kancloud.cn/kancloud/http-cookies-explained/48333</a></li><li><a href="https://www.runoob.com/w3cnote/http-vs-https.html">https://www.runoob.com/w3cnote/http-vs-https.html</a></li><li><a href="https://zhuanlan.zhihu.com/p/72616216">https://zhuanlan.zhihu.com/p/72616216</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 常识 </category>
          
          <category> http </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统知识点总结</title>
      <link href="/posts/29583.html"/>
      <url>/posts/29583.html</url>
      
        <content type="html"><![CDATA[<h1 id="计算机操作系统"><a href="#计算机操作系统" class="headerlink" title="计算机操作系统"></a>计算机操作系统</h1><p><img src="https://gitee.com/sehowyoung/images/raw/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.png" alt="操作系统"></p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h3><ul><li><p>并发：</p><ul><li><p>并发：在一段时间内可以运行多个程序。关键是：有处理多个任务的能力</p></li><li><p>并行：有多个任务执行单元，从物理上就可以多个任务一起执行。关键是：同时处理多个任务</p></li><li><p>举例：</p><blockquote><p>你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。<br>你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。<br>你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。</p></blockquote></li></ul></li><li><p>共享：</p><ul><li>共享是指系统中的资源可以被多个并发进程共同使用。</li><li>有两种共享方式：互斥共享和同时共享。</li><li>互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。</li></ul></li><li>虚拟<ul><li>虚拟技术将一个物理实体转换为多个逻辑实体</li><li>两种虚拟技术：<ul><li>时分复用技术：多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。</li><li>空分复用技术：虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。</li></ul></li></ul></li><li>异步：<ul><li>同步交互：指发送一个请求,需要等待返回,然后才能够发送下一个请求，有个等待过程；</li><li>异步交互：指发送一个请求,不需要等待返回,随时可以再发送下一个请求，即不需要等待。 </li><li>区别：一个需要等待，一个不需要等待，在部分情况下，我们的项目开发中都会优先选择不需要等待的异步交互方式。</li></ul></li></ul><h3 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h3><ol><li>进程管理：进程控制、进程通信、进程同步、死锁处理等</li><li>内存管理：内存分配、地址映射、虚拟内存等</li><li>文件管理：存储空间管理、目录管理、文件读写管理等</li><li>设备管理：缓冲管理、设备分配等</li></ol><h3 id="宏内核与微内核"><a href="#宏内核与微内核" class="headerlink" title="宏内核与微内核"></a>宏内核与微内核</h3><ol><li>宏内核：<ol><li>宏内核将操作系统功能作为一个紧密结合的整体放到内核</li><li>由于模块共享信息，性能很高</li></ol></li><li>微内核：<ol><li>由于操作系统不断复杂，因此将一部分系统功能移除内核，降低复杂性。移除的部分会根据分层原则划分成若干服务，相互独立。</li><li>在微内核结构下，操作系统被划分成小的、定义良好的模块，只有微内核这一个模块运行在内核态、其余模块运行在用户态。</li><li>因为需要频繁地在用户态和核心态之间进行切换，所以会有一定的性能损失。</li></ol></li></ol><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2_14_microkernelArchitecture.jpg" alt="微内核" style="zoom: 80%;"></p><h3 id="中断分类"><a href="#中断分类" class="headerlink" title="中断分类"></a>中断分类</h3><ol><li>外中断：由CPU执行指令意外的事件引起，如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。</li><li>异常：由CPU执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。</li><li>陷入：在用户程序中使用系统调用</li></ol><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><ul><li>进程：<ul><li>进程是资源分配的基本单位</li><li>进程控制块(Process Control Block)描述了进程的基本信息和运行状态</li></ul></li><li>线程：<ul><li>线程是独立调用的基本单位</li><li>一个进程可以有多个线程，他们共享进程资源</li></ul></li><li>区别：<ul><li>拥有资源：进程是资源分配的基本单位；线程不拥有资源，当可以访问资源</li><li>调度：线程是调度的基本单位。同一进程中，线程的切换不会引起进程的切换；从一个进程的线程中切换到另一个进程的线程中会引起进程的切换</li><li>系统开销：由于创建或撤销进程时，系统会分配或回收资源，因此所付出的开销远大于创建或撤销进程的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。</li><li>通信方面：线程间可以通过直接读写同一进程中的数据进行通信，当进程通信需要借助 IPC（进程通信） 。</li></ul></li></ul><h3 id="进程状态的切换"><a href="#进程状态的切换" class="headerlink" title="进程状态的切换"></a>进程状态的切换</h3><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ProcessState.png" alt="进程状态切换图" style="zoom:50%;"></p><p><strong>进程五大状态</strong>：</p><ul><li>新建状态(new/created)</li><li>就绪状态(ready)：等待被调度</li><li>运行状态(running)</li><li>阻塞状态(waiting)：等待资源</li><li>终止状态(terminated)</li></ul><p><strong>注意：</strong></p><ul><li>只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。</li><li>阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。</li></ul><h3 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h3><ol><li><p>先来先服务(FCFS)</p><ul><li>非抢占式调度算法，按请求的顺序进行调度</li><li>有利于长作业，不利于短作业</li></ul></li><li><p>短作业优先(SJF)</p><ul><li>非抢占式调度算法，按预估时间最短排序</li><li>长作业可能会饿死</li></ul></li><li><p>最短剩余时间优先(shortest remaining time next, SRTN)</p><ul><li>最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</li></ul></li><li><p>时间片轮转</p><ul><li>将所有就绪进程按FCFS排队，每次调度时，将CPU时间分配给队首进程，该进程执行一个时间片，当时间片用完，放置队尾，继续分配给队首进程，不断循环</li><li>时间片轮转算法的效率与时间片的大小有关</li></ul></li><li><p>优先级调度</p><ul><li>为每个进程分配一个优先级，按优先级进行调度</li><li>为防止低优先级的进程等不到调度，可以随着时间推移增加等待进程的优先级</li></ul></li><li><p>多级反馈队列</p><ul><li><p>多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。</p></li><li><p>每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。</p></li><li><p>可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/042cf928-3c8e-4815-ae9c-f2780202c68f.png" alt="多级反馈队列调度算法"></p></li></ul></li></ol><h3 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h3><ul><li>临界区：<ul><li>对临界资源进行访问的那段代码成为<code>临界区</code></li><li>为了互斥访问临界资源，每个资源在进入临界区之前，都需要进行检查</li></ul></li><li>同步与互斥<ul><li>同步：多个进程因为合作产生的直接制约关系，使的进程有一定的先后执行关系</li><li>互斥：多个进程在同一时刻只有一个进程能进入临界区</li></ul></li><li>信号量<ul><li>信号量(Semaphore)是一个整型变量，可以对其执行 down 和 up 操作，即 P 和 V 操作<ul><li><strong>down</strong>：如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0 ，进程睡眠，等待信号大于 0 </li><li><strong>up</strong>：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作</li></ul></li><li>down 和 up 被设计成原语，不可分割，通常的做法使在执行这些操作的时候屏蔽中断</li><li>如果信号量的取值只能为 0 或者 1，那么就成为了 <strong>互斥量（Mutex）</strong>，0 表示临界区已经加锁，1 表示临界区解锁。</li></ul></li><li>管程<ul><li>使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。</li><li>管程有一个重要特性：<strong>在一个时刻只能有一个进程使用管程</strong>。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。</li><li>管程引入了 条件变量 以及相关的操作：wait() 和 signal() 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程</li></ul></li></ul><h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p>进程同步与进程通信的区别：</p><ul><li>进程同步：控制多个进程按一定的顺序执行</li><li>进程通信：进程间传输信息</li></ul><p>进程同步的方式：</p><ol><li><p>管道（匿名管道）</p><p>管道通过调用 pipe 函数创建，fd[0] 用于读，fd[1] 用于写</p><pre class="line-numbers language-C" data-language="C"><code class="language-C"># include &lt;unistd.h&gt;int pipe(int fd[2]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>限制：</p><ul><li>只支持半双工通道(单项交替传输)</li><li>只能在父子进程或者兄弟进程中使用</li></ul><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/53cd9ade-b0a6-4399-b4de-7f1fbd06cdfb.png" alt="匿名管道" style="zoom:50%;"></p></li><li><p>有名管道 (FIFO)</p><p>匿名管道，由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道(FIFO)。</p><p>有名管道不同于匿名管道之处在于它提供了一个路径名与之关联，<strong>以有名管道的文件形式存在于文件系统中</strong>，这样，<strong>即使与有名管道的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过有名管道相互通信</strong>，因此，通过有名管道不相关的进程也能交换数据。值的注意的是，有名管道严格遵循<strong>先进先出(first in first out)</strong>,对匿名管道及有名管道的读总是从开始处返回数据，对它们的写则把数据添加到末尾。它们不支持诸如lseek()等文件定位操作。<strong>有名管道的名字存在于文件系统中，内容存放在内存中。</strong></p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/2ac50b81-d92a-4401-b9ec-f2113ecc3076.png" alt="有名管道" style="zoom:50%;"></p></li><li><p>消息队列</p><p>消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示。</p><p>相比于 FIFO ，消息队列具有以下优点：</p><ul><li>消息队列可独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难</li><li>避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法</li><li>读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认的接收</li></ul></li><li><p>信号量</p><p>它是一个计数器，用于为多个进程提供对共享数据对象的访问</p></li><li><p>共享存储</p><p>允许多个进程共享以一个给定的存储区。因为数据不需要在进程间复制，所以这是最快的一种<strong>IPC</strong></p><p>需要使用信号量用来同步对共享存储的访问</p><p>多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存，另外 XSI 共享内存不是使用文件，而是使用内存的匿名段</p></li><li><p>套接字</p><p>与其他通信机制不同的是，它可以用于不同机器间的进程通信。</p></li></ol><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h3><ol><li>互斥：每个资源要么已经分配给了一个进程，要么就是可用的</li><li>占有并等待：已经得了某个资源的进程可以再请求新的资源</li><li>不可抢占：已经等配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显示释放</li><li>环路等待：有两个或两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源</li></ol><h3 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h3><h4 id="鸵鸟策略"><a href="#鸵鸟策略" class="headerlink" title="鸵鸟策略"></a>鸵鸟策略</h4><ul><li>措施：把头埋在沙子里，假装根本没发生。</li><li>原因：因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。</li><li>适用条件：死锁不会对用户造成多大影响或发生死锁概率很低</li><li>大部分操作系统处理死锁使用的就是鸵鸟策略</li></ul><h4 id="死锁检测与死锁恢复"><a href="#死锁检测与死锁恢复" class="headerlink" title="死锁检测与死锁恢复"></a>死锁检测与死锁恢复</h4><ul><li>措施：不试图阻止死锁，而是当死锁发生时，采取措施进行恢复</li><li>算法：<ul><li>每种类型一个资源的死锁检测：通过检测有向图是否存在环来实现，从一个接待你出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。</li><li>每种类型多个资源的死锁检测：每个进程最开始都不被标记，执行过程有可能被标记。但算法结束时，任何没有被标记的进程都是死锁进程。<ol><li>寻找一个没有标记的进程 $P_{i}$，它所请求的资源小于等于资源剩余量</li><li>如果找到这样一个进程，那么将该进程所拥有的资源数量加到资源剩余量中，标记该进程并返回1</li><li>如果没有这样一个进程，算法终止</li></ol></li></ul></li><li>死锁恢复<ul><li>利用抢占资源</li><li>利用回滚回复</li><li>通过杀死进程恢复</li></ul></li></ul><h4 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h4><ul><li>描述：在程序运行之前预防发生死锁</li><li>措施：<ul><li>破坏互斥条件</li><li>破坏占有并等待条件：规定所有进程在开始执行前请求所需要的全部资源</li><li>破坏不可抢占条件、</li><li>破坏环路并等待：给资源编号，进程只能按编号顺序来请求资源</li></ul></li></ul><h4 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h4><ul><li>安全状态：<ul><li>定义：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序使得每一个进程都能运行完毕，则称改状态是安全的</li><li>安全状态的检测与死锁检测类似，因为安全状态必须要求不能发生死锁</li></ul></li><li>银行家算法</li></ul><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><ul><li>目的：让物理内存扩大成更大的逻辑内存，从而让程序获得更多的可用内存</li><li>为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但<strong>不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中</strong>。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。</li><li>虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，即一个程序不需要全部调入内存就可以运行。例如：一个内存为32KB的计算机允许运行64KB的程序</li></ul><h3 id="分页系统地址映射"><a href="#分页系统地址映射" class="headerlink" title="分页系统地址映射"></a>分页系统地址映射</h3><ul><li><p>内存管理单元(MMU)管理着地址空间和物理内存的转换，其中的页表(Page Table)存储着页（程序地址空间）和页框（物理内存空间）的映射表。</p></li><li><p>一个虚拟地址分为两部分，一部分存储页面号，一部分存储偏移量</p></li><li><p>例如：下图的页表存放着 16 个页，这 16 个页需要用 4 个比特位来进行索引定位。例如对于虚拟地址（0010 000000000100），前 4 位是存储页面号 2，读取表项内容为（110 1），页表项最后一位表示是否存在于内存中，1 表示存在。后 12 位存储偏移量。这个页对应的页框的地址为 （110 000000000100）。</p><p><img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/cf4386a1-58c9-4eca-a17f-e12b1e9770eb.png" alt="虚拟地址"></p></li></ul><h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><p>在程序运行过程中，如果要访问的页面不在内存中，就会发生缺页中断从而将该页调入内存中。如果内存没有闲置空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。</p><p>页面置换算法和缓存淘汰策略类似，可以将内存堪称磁盘的缓存。在缓存系统中，缓存大小有限，当有新的缓存到达时，需要淘汰一部分已经存在的缓存，这样才有空间存放新的缓存数据。</p><p>目标：使页面置换频率最低</p><h4 id="最佳-OPT-Optimal-replacement-algorithm"><a href="#最佳-OPT-Optimal-replacement-algorithm" class="headerlink" title="最佳 OPT(Optimal replacement algorithm)"></a>最佳 OPT(Optimal replacement algorithm)</h4><ul><li>算法描述：所选择的被置换出的页面是最长时间内不在被访问，通常可以保证获得最低的缺页率。</li><li>是一种理论上的算法，因为无法知道一个页面多长时间内不在被访问</li></ul><h4 id="最近最久未使用-LRU-Leastest-Recently-Used"><a href="#最近最久未使用-LRU-Leastest-Recently-Used" class="headerlink" title="最近最久未使用 LRU(Leastest Recently Used)"></a>最近最久未使用 LRU(Leastest Recently Used)</h4><ul><li>算法描述：为了实现 LRU ，需要在内存中维护一个所有页面的表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面时最近最久未访问的。</li><li>每次访问都需要更新链表，因此代价很高</li></ul><h4 id="先进先出-FIFO-First-in-First-out"><a href="#先进先出-FIFO-First-in-First-out" class="headerlink" title="先进先出 FIFO(First in First out)"></a>先进先出 FIFO(First in First out)</h4><ul><li>算法描述：选择最先进入的页面进行置换</li><li>该算法会将那些经常被访问的页面置换出去，导致缺页率升高</li></ul><h3 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h3><p>虚拟内存采用分页技术，也就是将地址空间划分成固定大小的页，每一个再与物理内存进行映射。但是在某些需要动态增长的程序中，分页技术会导致覆盖问题的出现，因此采用分段技术。</p><p>分段技术：将表分成段，一个段构成一个独立的地址空间。每个段的长度可以不同，并且动态增长。</p><h3 id="段页式"><a href="#段页式" class="headerlink" title="段页式"></a>段页式</h3><p>程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样即拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能</p><h3 id="分页和分段的比较"><a href="#分页和分段的比较" class="headerlink" title="分页和分段的比较"></a>分页和分段的比较</h3><ul><li>对程序员的透明性：分页透明，但是分段需要程序员显性划分</li><li>地址空间的维度：分页一维，分段二维</li><li>大小是否可变：页的大小不可变，段的大小可动态改变</li><li>出现原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有利于共享和保护</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.jianshu.com/p/c1015f5ffa74">https://www.jianshu.com/p/c1015f5ffa74</a></li><li><a href="https://leetcode-cn.com/leetbook/read/tech-interview-cookbook/">https://leetcode-cn.com/leetbook/read/tech-interview-cookbook/</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 常识 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList扩容机制分析</title>
      <link href="/posts/55582.html"/>
      <url>/posts/55582.html</url>
      
        <content type="html"><![CDATA[<h1 id="ArrayList扩容机制分析"><a href="#ArrayList扩容机制分析" class="headerlink" title="ArrayList扩容机制分析"></a>ArrayList扩容机制分析</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>ArrayList</code>是动态数组，它的底层是数组队列，它的前身是<code>Vector</code>，和Java中的数组相比，他最大的优势就是能动态增长。</p><p><code>ArrayList</code>继承于<code>AbstractList</code>类，实现了<code>List</code>，<code>RandomAccess</code>，<code>Cloneable</code>，<code>java.io.Serializable</code>类。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable{    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>其中：</p><ul><li><code>RandomAccess</code>：这个接口里面什么都没有，是一个标志接口，表明实现这个接口的List集合支持快速访问。</li><li><code>Cloneable</code>：一个类实现了Cloneable接口，以向Object.clone()方法指示该方法制作该类实例的字段对字段副本是合法的。即表示<code>ArrayList</code>可以被克隆。</li><li><code>Serializable</code>：<code>ArrayList</code>实现了这个接口，表明<code>ArrayList</code>支持序列化，可以通过序列化传输内容</li></ul><h2 id="ArrayList扩容机制分析（jdk8）"><a href="#ArrayList扩容机制分析（jdk8）" class="headerlink" title="ArrayList扩容机制分析（jdk8）"></a>ArrayList扩容机制分析（jdk8）</h2><h3 id="ArrayList的构造函数"><a href="#ArrayList的构造函数" class="headerlink" title="ArrayList的构造函数"></a>ArrayList的构造函数</h3><p>ArrayList提供了三种构造函数，分别是无参构造函数、初始容量构造函数、容器构造函数。<strong>以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"> /**  * 默认初始容量大小  */ private static final int DEFAULT_CAPACITY = 10; /**  * 空数组（用于空实例）。  */ private static final Object[] EMPTY_ELEMENTDATA = {}; //用于默认大小空实例的共享空数组实例。 //我们把它从EMPTY_ELEMENTDATA数组中区分出来，以知道在添加第一个元素时容量需要增加多少。 private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; /**  * 默认构造函数，使用初始容量10构造一个空列表(无参数构造)  */ public ArrayList() {     this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; } /**  * 带初始容量参数的构造函数。（用户自己指定容量）  */ public ArrayList(int initialCapacity) {     if (initialCapacity &gt; 0) {//初始容量大于0         //创建initialCapacity大小的数组         this.elementData = new Object[initialCapacity];     } else if (initialCapacity == 0) {//初始容量等于0         //创建空数组         this.elementData = EMPTY_ELEMENTDATA;     } else {//初始容量小于0，抛出异常         throw new IllegalArgumentException("Illegal Capacity: "+                                            initialCapacity);     } }/** * 构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回 * 如果指定的集合为null，throws NullPointerException。 */  public ArrayList(Collection&lt;? extends E&gt; c) {     elementData = c.toArray();     if ((size = elementData.length) != 0) {         // c.toArray might (incorrectly) not return Object[] (see 6260652)         if (elementData.getClass() != Object[].class)             elementData = Arrays.copyOf(elementData, size, Object[].class);     } else {         // replace with empty array.         this.elementData = EMPTY_ELEMENTDATA;     } }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="扩容分析"><a href="#扩容分析" class="headerlink" title="扩容分析"></a>扩容分析</h3><p>我们首先创造一个无参的<code>ArrauList</code>，然后调用<code>ArrayList.add()</code>方法</p><h4 id="ArrayList-add"><a href="#ArrayList-add" class="headerlink" title="ArrayList.add()"></a>ArrayList.add()</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * 将指定的元素追加到此列表的末尾。 */public boolean add(E e) {    //添加元素之前，先调用ensureCapacityInternal方法，得到最小扩容量    ensureCapacityInternal(size + 1);  // Increments modCount!!    //这里看到ArrayList添加元素的实质就相当于为数组赋值    elementData[size++] = e;    return true;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="ArrayList-ensureCapacityInternal"><a href="#ArrayList-ensureCapacityInternal" class="headerlink" title="ArrayList.ensureCapacityInternal()"></a>ArrayList.ensureCapacityInternal()</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">//得到最小扩容量private void ensureCapacityInternal(int minCapacity) {    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {        // 获取默认的容量和传入参数的较大值        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);    }//判断是否需要扩容    ensureExplicitCapacity(minCapacity);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当要add第一个元素时，<code>minCapacity</code>为1，通过<code>Math.max()</code>比较后，<code>minCapacity</code>为10。</p><h4 id="ArrayList-ensureExplicitCapacity"><a href="#ArrayList-ensureExplicitCapacity" class="headerlink" title="ArrayList.ensureExplicitCapacity()"></a>ArrayList.ensureExplicitCapacity()</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">//判断是否需要扩容private void ensureExplicitCapacity(int minCapacity) {    modCount++;    // overflow-conscious code    if (minCapacity - elementData.length &gt; 0)        //调用grow方法进行扩容，调用此方法代表已经开始扩容了        grow(minCapacity);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当调用<code>ArrayList.ensureCapacityInternal()</code>的方法时，一定会调用<code>ArrayList.ensureExplicitCapacity()</code>来判断是否需要进行扩容。</p><p>我们来看一下添加元素的过程：</p><ul><li>当我们添加第一个元素时，<code>elementData.length</code>为0，执行<code>ArrayList.ensureCapacityInternal()</code>方法，得到结果<code>minCapacity</code>为10，此刻进入<code>ArrayList.ensureExplicitCapacity()</code>后，<code>inCapacity - elementData.length &gt; 0</code>成立，然后调用<code>ArrayList.grow()</code>方法进行扩容。</li><li>然而当我们添加第二、三、…、十个元素时，因为<code>inCapacity - elementData.length &gt; 0</code>不成立，不会执行<code>ArrayList.grow()</code>方法进行扩容。</li></ul><h4 id="ArrayList-grow"><a href="#ArrayList-grow" class="headerlink" title="ArrayList.grow()"></a>ArrayList.grow()</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * 要分配的最大数组大小 */private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;/** * ArrayList扩容的核心方法。 */private void grow(int minCapacity) {    // oldCapacity为旧容量，newCapacity为新容量    int oldCapacity = elementData.length;    //将oldCapacity 右移一位，其效果相当于oldCapacity /2，    //我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);    //然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，    if (newCapacity - minCapacity &lt; 0)        newCapacity = minCapacity;   // 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，   //如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)        newCapacity = hugeCapacity(minCapacity);    // minCapacity is usually close to size, so this is a win:    elementData = Arrays.copyOf(elementData, newCapacity);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们再来看一下添加元素的过程：</p><ul><li>当我们添加第一个元素时，<code>elementData.length</code>为0，即<code>oldCapacity</code>为0，<code>newCapacity</code>为<code>oldCapacity</code>的1.5倍，因此也为0，<code>minCapacity</code>为10，第一个条件判断成立，第二个条件判断不成立，因此数组容量为10，size 为1，添加成功，返回 true。</li><li>当我们添加第11个元素时，<code>newCapacity</code>为 15，比 <code>minCapacity</code>（为 11）大，第一个 if 判断不成立。新容量没有大于数组最大 size，不会进入 <code>hugeCapacity</code>方法。数组容量扩为 15，size 变为11，添加元素成功，返回 true。</li><li>以此规则往复即可。</li></ul><h4 id="ArrayList-hugeCapacity"><a href="#ArrayList-hugeCapacity" class="headerlink" title="ArrayList.hugeCapacity()"></a>ArrayList.hugeCapacity()</h4><p>从上面的代码我们知道<code>MAX_ARRAY_SIZE</code>大小是有限的，那如果<code>newCapacity</code>大于<code>MAX_ARRAY_SIZE</code>怎么办？这就用到了<code>ArrayList.hugeCapacity()</code>方法了。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">private static int hugeCapacity(int minCapacity) {    if (minCapacity &lt; 0) // overflow        throw new OutOfMemoryError();    //对minCapacity和MAX_ARRAY_SIZE进行比较    //若minCapacity大，将Integer.MAX_VALUE作为新数组的大小    //若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小    //MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;    return (minCapacity &gt; MAX_ARRAY_SIZE) ?        Integer.MAX_VALUE :        MAX_ARRAY_SIZE;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="复制数组的方法"><a href="#复制数组的方法" class="headerlink" title="复制数组的方法"></a>复制数组的方法</h3><p>由上面的代码我们可以知道，添加元素实质上就是不断复制原数组、不断扩容的过程，对于复制数组用到了<code>System.arraycopy()</code> 和 <code>Arrays.copyOf()</code>方法。</p><h4 id="System-arraycopy"><a href="#System-arraycopy" class="headerlink" title="System.arraycopy()"></a>System.arraycopy()</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">// 我们发现 arraycopy 是一个 native 方法,接下来我们解释一下各个参数的具体意义/***   复制数组* @param src 源数组* @param srcPos 源数组中的起始位置* @param dest 目标数组* @param destPos 目标数组中的起始位置* @param length 要复制的数组元素的数量*/public static native void arraycopy(Object src,  int  srcPos,                                    Object dest, int destPos,                                    int length);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * 在此列表中的指定位置插入指定的元素。 * 先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大； * 再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。 */public void add(int index, E element) {    rangeCheckForAdd(index);    ensureCapacityInternal(size + 1);  // Increments modCount!!    //arraycopy()方法实现数组自己复制自己    //elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量；    System.arraycopy(elementData, index, elementData, index + 1, size - index);    elementData[index] = element;    size++;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Arrays;/** * @Author How-Young * @ClassName Test * @Time 16:34 */public class Test {    public static void main(String[] args) {        int[] a = {0,1,2,3,4,0,0,0,0,0};        System.arraycopy(a, 2, a, 3, 3);        a[2] = 33;        System.out.println(Arrays.toString(a));    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">[0, 1, 33, 2, 3, 4, 0, 0, 0, 0]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="Arrays-copyOf"><a href="#Arrays-copyOf" class="headerlink" title="Arrays.copyOf()"></a>Arrays.copyOf()</h4><p>源码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static int[] copyOf(int[] original, int newLength) {    // 申请一个新的数组    int[] copy = new int[newLength];// 调用System.arraycopy,将源数组中的数据进行拷贝,并返回新的数组    System.arraycopy(original, 0, copy, 0,                     Math.min(original.length, newLength));    return copy;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">/**  以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; 返回的数组的运行时类型是指定数组的运行时类型。  */ public Object[] toArray() { //elementData：要复制的数组；size：要复制的长度     return Arrays.copyOf(elementData, size); }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="区别与联系"><a href="#区别与联系" class="headerlink" title="区别与联系"></a>区别与联系</h4><p>联系：</p><p><code>Arrays.copyOf()</code>实际上就是调用了<code>System.arraycopy()</code></p><p>区别：</p><ul><li><code>arraycopy()</code> 需要目标数组，将原数组拷贝到你自己定义的数组里或者原数组，而且可以选择拷贝的起点和长度以及放入新数组中的位置 </li><li><code>copyOf()</code> 是系统自动在内部新建一个数组，并返回该数组。</li></ul><h3 id="ArrayList-ensureCapacity"><a href="#ArrayList-ensureCapacity" class="headerlink" title="ArrayList.ensureCapacity()"></a>ArrayList.ensureCapacity()</h3><p>在源码中，这个方法始终没有被调用过，因此这个方法肯定是留给咱们用户使用的，它的作用主要是：在有必要的情况下，增加此 ArrayList 实例的容量，以确保它至少可以容纳由minimum capacity参数指定的元素数。</p><p>其实说白了，就是在大量增加元素之前，调用这个方法，更改<code>minCapacity</code>的值，减少运行时间。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入了解深克隆与浅克隆</title>
      <link href="/posts/18234.html"/>
      <url>/posts/18234.html</url>
      
        <content type="html"><![CDATA[<h1 id="深入了解深克隆与浅克隆"><a href="#深入了解深克隆与浅克隆" class="headerlink" title="深入了解深克隆与浅克隆"></a>深入了解深克隆与浅克隆</h1><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><blockquote><p>原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。</p></blockquote><p>原型模式依靠 clone 来实现，在Java中 clone 的方式有两种——深克隆与浅克隆，本文将详细的讲解深克隆与浅克隆。</p><h2 id="浅克隆"><a href="#浅克隆" class="headerlink" title="浅克隆"></a>浅克隆</h2><p>浅克隆比较好实现，只需实现<code>Cloneable</code>接口即可，我们通过一个示例来详细的了解一下浅克隆机制。</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210628130300273.png" alt="浅克隆类图"></p><p>Student类：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package DeepCloneAndSimpleClone.Simple;/** * @Author How-Young * @ClassName Student * @Time 10:34 */public class Student{    private int age;    private String name;    private int num;    public Student() {    }    public Student(int age, String name, int num) {        this.age = age;        this.name = name;        this.num = num;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getNum() {        return num;    }    public void setNum(int num) {        this.num = num;    }    @Override    public String toString() {        return "Student{" +                "age=" + age +                ", name='" + name + '\'' +                ", num=" + num +                '}';    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Teacher类：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package DeepCloneAndSimpleClone.Simple;/** * @Author How-Young * @ClassName Teacher * @Time 10:40 */public class Teacher implements Cloneable {    private String name;    private int age;    private Student student;    public Teacher() {    }    public Teacher(String name, int age, Student student) {        this.name = name;        this.age = age;        this.student = student;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    public Student getStudent() {        return student;    }    public void setStudent(Student student) {        this.student = student;    }    @Override    public String toString() {        return "Teacher{" +                "name='" + name + '\'' +                ", age=" + age +                ", student=" + student +                '}';    }    @Override    protected Object clone() throws CloneNotSupportedException {        return super.clone();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试类：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package DeepCloneAndSimpleClone.Simple;/** * @Author How-Young * @ClassName Main * @Time 10:36 */public class Simple {    public static void main(String[] args) {        Student student = new Student(18, "张三", 1203123);        try {            Teacher teacher1 = new Teacher("李芳", 38, student);            Teacher teacher2 = (Teacher) teacher1.clone();            System.out.println(teacher1.equals(teacher2));            System.out.println(teacher1.getStudent().equals(teacher2.getStudent()));            student.setAge(36);            System.out.println(teacher1.getStudent().toString());            System.out.println(teacher2.getStudent().toString());        } catch (CloneNotSupportedException e) {            e.printStackTrace();        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果：</p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">falsetrueStudent{age=36, name='张三', num=1203123}Student{age=36, name='张三', num=1203123}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>由输出结果我们可以试着分析一下：</p><ul><li>首先，我们创建了一个Stundet的实例<code>student</code></li><li>然后我们又创建了一个Teacher的实例<code>teacher1</code></li><li>之后我们clone了t1生成了<code>teacher2</code></li><li>之后我们判断<code>teacher1</code>和<code>teacher2</code>以及这两个对象的<code>student</code>属性是否相同</li></ul><p>由输出结果我们可以看到<code>clone</code>是在内存中又开辟了一块空间，分配给了<code>teacher2</code>，但是两个对象的<code>student</code>属性还是指向同一个地址。因此，当我们尝试改变<code>student</code>的时候，两个值全部都改变了。<img src="https://gitee.com/sehowyoung/images/raw/master/image-20210628114406213.png" alt="浅克隆内存分析图" style="zoom: 50%;"></p><h2 id="深克隆"><a href="#深克隆" class="headerlink" title="深克隆"></a>深克隆</h2><p>深克隆与浅克隆最大的不同就是在于：将其所引用的对象也全部复制了一遍。话不多说，直接上代码。</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210628132114613.png" alt="深克隆类图"></p><p>Student类：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package DeepCloneAndSimpleClone.deep;import java.io.Serializable;/** * @Author How-Young * @ClassName Student * @Time 10:34 */public class Student implements Serializable {    private final static long serialVersionUID = 3838472827384L;    private int age;    private String name;    private int num;    public Student() {    }    public Student(int age, String name, int num) {        this.age = age;        this.name = name;        this.num = num;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getNum() {        return num;    }    public void setNum(int num) {        this.num = num;    }    @Override    public String toString() {        return "Student{" +                "age=" + age +                ", name='" + name + '\'' +                ", num=" + num +                '}';    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Teacher类：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package DeepCloneAndSimpleClone.deep;import java.io.*;/** * @Author How-Young * @ClassName Teacher * @Time 10:40 */public class Teacher implements Serializable {    private final static long serialVersionUID = 3838472827384L;    private String name;    private int age;    private Student student;    public Teacher() {    }    public Teacher(String name, int age, Student student) {        this.name = name;        this.age = age;        this.student = student;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    public Student getStudent() {        return student;    }    public void setStudent(Student student) {        this.student = student;    }    @Override    public String toString() {        return "Teacher{" +                "name='" + name + '\'' +                ", age=" + age +                ", student=" + student +                '}';    }    @Override    protected Teacher clone(){        try {            ByteArrayOutputStream bao = new ByteArrayOutputStream();            ObjectOutputStream objectOutputStream = new ObjectOutputStream(bao);            objectOutputStream.writeObject(this);            ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bao.toByteArray());            ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);            return (Teacher) objectInputStream.readObject();        } catch (IOException | ClassNotFoundException e) {            e.printStackTrace();        }        return null;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示例类：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package DeepCloneAndSimpleClone.deep;/** * @Author How-Young * @ClassName Deep * @Time 10:46 */public class Deep {    public static void main(String[] args) {        Student student = new Student(18, "张三", 2390239);        Teacher teacher1 = new Teacher("李芳", 36, student);        Teacher teacher2 = teacher1.clone();        System.out.println(teacher1.equals(teacher2));        System.out.println(teacher1.getStudent().equals(teacher2.getStudent()));    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">falsefalse<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>我们首先创建了一个Student的实例<code>student</code></li><li>然后我们创建了一个Teacher类的实例<code>teacher1</code></li><li>之后我们克隆了<code>teacher1</code>生成了<code>teacher2</code></li><li>最后我们分别对这两个实例以及实例的<code>student</code>属性是否相同进行了判断</li></ul><p>由结果我们可以看出：不仅这两个对象不同，而且这两个对象的<code>student</code>属性也不同。</p><p>大致克隆的过程就是：对<code>teacher1</code>和<code>student</code>进行克隆，并在内存中为它们开辟一块空间，因此当我们尝试改变原来的<code>student</code>的数据时，克隆的<code>student</code>不受影响。</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210628133440520.png" alt="深克隆内存分析图"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目管理课后题</title>
      <link href="/posts/38171.html"/>
      <url>/posts/38171.html</url>
      
        <content type="html"><![CDATA[<h1 id="课堂习题"><a href="#课堂习题" class="headerlink" title="课堂习题"></a>课堂习题</h1><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><ol><li>==项目==是为创造一种产品、服务或者结构而进行的临时性努力。</li><li>全球生产总值中大概有==25%==花费在项目上。</li><li>项目组合管理强调达到==战略==目标，项目管理专注于==战术==目标</li><li>==项目管理==是将知识、技能、工具和技术应用到项目活动，以达到组织的要求。</li><li>为相同的功能组合而实施的一系列应用开发项目，作为==项目群==的一部分，或许能够得到更好的管理</li><li>项目的三约束包括==范围==、==时间==、==费用==</li><li>PMI提供的认证项目叫==Project Management Professional（PMP）==</li></ol><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><ol><li>==可交付成果==是作为项目的一部分所提供的一件产品或者服务。</li><li>阶段出口又叫做==终止点==</li><li>人员在==矩阵型==组织结构中通常向两个或更多的上级报告</li><li>组织4个框架中，==标志框架==涉及如何举行会议、员工衣着样式和预期工作时间。</li><li>系统管理的三维模型有==业务==、==技术==、==组织==</li><li>项目工作通常在这样的组织文化中最易成功，该文化具有很高的特性，除了==控制==</li><li>==系统开发生命周期==是用来描述系统开发不同阶段的框架</li><li>IT项目的性质不同于许多其他行业的项目，因为他们是很==多样的==</li><li>==离岸外包==可以用来描述组织从国外寻找外部资源以获得需要的产品或原材料。</li></ol><h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><ol><li>==过程==是针对某一特定结果的一系列活动。</li><li>==实施==过程包括协调人及其他资源，以全面观测落实项目计划，输出项目或项目阶段的产品、服务</li><li>==实施==过程组通常是最需要资源和时间。 </li><li>工作分解结构、项目进度表、成本预算是==计划==过程的结果。</li><li>==监控==包括根据项目目标来衡量项目进度，并采取纠正措施。</li><li>==计划==过程涉及九个知识领域</li><li>==方法论==描述了事情应该怎样去做，并且不同的组织通常采用不同的方式</li><li>启动过程包括制定一个项目章程和项目初步范围说明书，这涉及项目==集成==管理知识。</li><li>项目小组做==经验总结报告==来总结项目对在哪里、错在哪里</li><li>很多人在编制各种项目管理文件时都是用==模板==作为标准格式</li></ol><h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><ol><li>在选择IT项目时，4个阶段规划过程的最后一步是==资源分配==</li><li>==项目章程==是一份正式认可项目存在的文件，并为项目目标和管理提供方向。</li><li>项目产生的文档清单、终止项目文件以及历史资料都是==过程资产==的例子</li><li>如果一个项目总的折现后的收益是120000美元，总的折现后的费用是100000美元，则回报率（ROI）是==20%==</li><li>项目经理通过==配置管理==来在整个项目生命周期内识别、估计和管理变更。</li><li>一项新的政府法令要求组织以新的方式报告数据。一个提供这种数据的新的信息系统项目应归为==指令==</li></ol><h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><ol><li>==范围==指包括生产项目产品及用于生产产品的过程中的所有工作</li><li>在需求收集阶段，==访谈==成本最高且耗时最长</li><li>==WBS==是一个项目中以可交付成果为导向的涉及所有工作的一种分组，它定义了项目的整体范围</li><li>创建WBS时，==心智图法==是以非线条格式将想法写出或画出</li><li>假设你有一个项目，该项目的主要条目为计划、分析、设计和测试，那么这些事项处于WBS中的层级是==2==</li><li>范围说明书是作为==范围规划==部分的产物</li><li>范围==验证==通常是通过客户检查来完成，然后以关键的可交付成果收尾。</li><li>项目管理软件可帮助构建==WBS==，它可为制作甘特图、分配资源以及分摊成本打下基础</li></ol><h2 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h2><ol><li>编制项目进度的第一个过程是==活动定义==</li><li>紧前活动、紧后活动、逻辑关系、提前和滞后、资源需求、约束条件、强制日期和活动相关的假设都是==活动属性==中的内容</li><li>在其他人拟定完糟糕之前，你不能开始编辑一项技术报告，这个关系模型是==完成—开始==</li><li>==追踪甘特图==显示了计划和实际的项目进度信息</li><li>==计划评审技术==是一种网络图技术，用于预测整个项目的工期</li><li>一般用甘特图中的==白钻石==符号表示延误的里程碑</li><li>==关键链进度编制法==是一种进度编制方法。当指定项目进度是，该方法考虑了资源的有限性，并设置了时间缓冲以保证项目按时完成。</li></ol><h2 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h2><ol><li>==成本==是为了达到一个具体的目标而牺牲或用过的资源，或为了交换而放弃的一些事情</li><li>==在允许的预算内完成一个项目==是成本管理的主要目标</li><li>如果一家公司因为某一个产品，再每100美元的收入中损失5美元，这个产品的利润率是==-5%==</li><li>你正基于一个房子的地点、目的、平米数和其它特点来进行成本估计，那你使用的是==参数==估计技术。</li><li>==项目成本预算==涉及将项目成本估计分配给单个工作条目</li><li>==挣值分析==项目绩效衡量方法包括了范围、时间和成本数据</li><li>如果一个项目完成了一半，并且它的进度绩效指数是110%，成本绩效指数95%，它的进展状况是==它提前于进度，超出了预算==。</li><li>==管理==储备主要考虑的是将来不可预期的情况</li></ol><h2 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h2><ol><li>==质量==是指满足一定系列内在特征的程度</li><li>==标杆管理==是通过与组织内或组织外的项目进行对比，对比它们的项目实践或者产品特性，未知量改进提供想法和建议的一种技术</li><li>你可以使用==散点图==来看两个变量值之间存在某种关系</li><li>你可以使用==控制图==判断一个过程处于控制中还是失控了</li><li>$6\sigma$追求的完美目标是每百万个机会中有不超过==3.4==个缺陷、误差或错误</li><li>七点运行定律是指，如果在一个质量控制图的一行上有7个数据点都低于平均值或高于平均值，或者都是上升的或都是下降的，这个过程就需要因为==飞随机==问题而接受检查</li><li>IT项目实施测试的首选顺序是==单元测试、集成测试、系统测试、用户验收测试==</li><li>PMI的OPM3是一个==成熟度==模型或框架的例子，用以帮助组织改进其过程和系统</li></ol><h2 id="第九章"><a href="#第九章" class="headerlink" title="第九章"></a>第九章</h2><ol><li>==内在动机==驱使人们为了自身的兴趣参与一项活动</li><li>马斯洛需求层次理论金子岩的最底层的需求是==生理==需求</li><li>根据麦克利兰的获取需求理论，那些渴望与他人建立和睦关系并被周围的人所接受的人是高==亲和==需求的人</li><li>==参照==权利建立在个人魄力和榜样的基础之上</li><li>==责任分配矩阵==可用来图解表示</li></ol><h2 id="知识补充"><a href="#知识补充" class="headerlink" title="知识补充"></a>知识补充</h2><h3 id="项目生命周期"><a href="#项目生命周期" class="headerlink" title="项目生命周期"></a>项目生命周期</h3><ul><li>概念阶段：制定项目总体计划</li><li>开发阶段：制定更详细的项目计划</li><li>实施阶段：执行项目计划，并对其进行监督与控制</li><li>收尾阶段：项目验收与工作总结</li></ul><h3 id="继承变更控制生命周期"><a href="#继承变更控制生命周期" class="headerlink" title="继承变更控制生命周期"></a>继承变更控制生命周期</h3><p>集成变更控制( integrated change control) 涉及在整个项目的生命周期中==识别、估计和管理变更== 。</p><h3 id="项目管理过程组全过程"><a href="#项目管理过程组全过程" class="headerlink" title="项目管理过程组全过程"></a>项目管理过程组全过程</h3><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210624091847432.png" alt="image-20210624091847432"></p><ul><li>启动过程：定义一个新项目或现有项目的一个新阶段，授权开始该项目或阶段的一组过程<ul><li>概念阶段成果：形成一个项目章程和选择一位项目经理</li><li>新阶段成果：对阶段进入条件的评估与确认</li></ul></li><li>计划过程：包括制订和维护一个可执行的计划，以保证项目满足组织的要求。<ul><li>成果：工作分解结构和范围说明书、项目进度和项目成本估计</li></ul></li><li>执行过程：包括协调人力和其他资源来执行项目的计划，以产生项目或者项目阶段的产品、服务或者结果。<ul><li>成果：按计划完成项目工作</li></ul></li><li>监控过程：包括有规律地测量和监视项目进程以保证项目团队能够满足项目目标。<ul><li>理想成果：通过交付满足时间、成本和质量约束的项目来成功地完成项目。</li></ul></li><li>收尾过程：包括对项目或者项目阶段的正式验收，并有效地终止，使项目或项目阶段任务有序、圆满的完成。<ul><li>关键结果：工作的正式验收和以及项目审计和项目经验总结报告等一些总结性文件的编写、提交、审定和归档。</li></ul></li></ul><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210624100236676.png" alt="九大知识领域与五大过程"></p><h3 id="九大知识领域"><a href="#九大知识领域" class="headerlink" title="九大知识领域"></a>九大知识领域</h3><h4 id="项目集成管理"><a href="#项目集成管理" class="headerlink" title="项目集成管理"></a>项目集成管理</h4><ul><li>项目集成管理：为确保项目各项工作能够有机地协调和配合所开展的综合性和全局性的项目管理工作和过程。</li><li>主要工作：<ul><li>制定项目章程：正式批准项目的文件——项目章程</li><li>创建初步的项目规范说明书</li><li>制定项目管理计划：用来协调所有项目计划文件和帮助引导项目的执行与控制。</li><li>指导和管理项目实施</li><li>监控项目工作</li><li>整体变更控制</li><li>项目收尾</li></ul></li><li>筛选信息技术项目过程：<ul><li>IT战略计划</li><li>业务分析</li><li>项目计划</li><li>资源分配</li></ul></li><li>SWOT：优劣机遇挑战</li></ul><p>净现值（NPV）：未来资金流入和资金流出的差额</p><h4 id="项目范围管理"><a href="#项目范围管理" class="headerlink" title="项目范围管理"></a>项目范围管理</h4><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210624143340158.png" alt="image-20210624143340158"></p><ul><li><p>项目范围管理：指对项目包括什么与不包括什么的定义与控制过程。</p></li><li><p>五阶段：</p><ul><li>范围规划：范围说明书、详细依据、范围管理计划</li><li>范围定义：工作分解结构、范围说明书更新</li><li>工作结构分解</li><li>范围验证：正式接受</li><li>范围控制</li></ul></li></ul><h4 id="项目时间管理"><a href="#项目时间管理" class="headerlink" title="项目时间管理"></a>项目时间管理</h4><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210624164540182.png" alt="image-20210624164540182"></p><ul><li>项目计划：指导项目实施和控制的一系列文件</li><li>进度计划：表达项目中各项工作的开展顺序、开始及完成时间及相互衔接关系的计划</li><li>活动或任务：是项目进行期间</li><li>活动排序：<ul><li>ADM箭线图法</li><li>AOA双代号网络图法</li><li>PDM-AON前导图法——单代号网络</li></ul></li><li>进度安排：<ul><li>甘特图</li><li>关键路径法</li><li>计划评审技术</li></ul></li></ul><h4 id="项目成本管理"><a href="#项目成本管理" class="headerlink" title="项目成本管理"></a>项目成本管理</h4><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210624183646937.png" alt="image-20210624183646937"></p><ul><li>成本：未达到一个特定的目标而花费或者用掉的资源</li><li>项目成本：实现项目目标所消耗资源的资源形成的费用</li><li>学习曲线理论：当重复生产许多产品时，那些生产产品的单位成本随着数量的增多成规律性递减。</li><li>储备金：包含于成本估算中的、为减轻未来难以预测轻型带来的成本风险而准备的那部分资金</li><li>项目成本管理：包括保障项目实际发生成本不超过预算而开展的项目成本估算、成本预算和成本控制等方面的管理需求</li><li>挣值方法：对项目范围、进度和成本进行综合控制的一种有效方法</li></ul><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210624192334583.png" alt="image-20210624192334583"></p><ul><li><p>两个偏差：</p><ul><li>CV：$CV=EV-AC$</li><li>SV： $SV=EV-PV$</li></ul></li><li><p>两个绩效指标：</p><ul><li><p>CPI：$CPI=\frac {EV} {AC}$</p></li><li><p>SPI：$SPI=\frac {EV} {PV}$</p></li></ul></li><li><p>三个基本参数：</p><ul><li>实际成本：$ACWP=AC$</li><li>预算成本：$BCWS=$</li><li>已完成的预算成本：$BCWP=$</li></ul></li></ul><h4 id="项目质量管理"><a href="#项目质量管理" class="headerlink" title="项目质量管理"></a>项目质量管理</h4><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210624213303648.png" alt=""></p><ul><li>质量管理：在质量方面指挥和控制组织的协调活动</li><li>项目质量管理：为了保障产物能够满足客户以及各相关利益者的需要所开展的对于项目产物的质量和项目工作质量的全面管理工作</li><li>软件质量特性：功能性、可靠性、易用性、效率、可维护性、可移植性</li><li>质量发展四个阶段：<ul><li>传统质量管理阶段</li><li>统计质量管理阶段</li><li>全面质量管理阶段</li><li>现代质量管理阶段</li></ul></li><li>PDCA：plan、do、check、act</li><li>质量控制——5M1E：<ul><li>materials材料</li><li>machine机器设备</li><li>man人</li><li>method方法</li><li>environment环境</li></ul></li></ul><h4 id="项目人力资源管理"><a href="#项目人力资源管理" class="headerlink" title="项目人力资源管理"></a>项目人力资源管理</h4><h4 id="项目沟通管理"><a href="#项目沟通管理" class="headerlink" title="项目沟通管理"></a>项目沟通管理</h4><h4 id="项目风险管理"><a href="#项目风险管理" class="headerlink" title="项目风险管理"></a>项目风险管理</h4><h4 id="项目采购管理"><a href="#项目采购管理" class="headerlink" title="项目采购管理"></a>项目采购管理</h4>]]></content>
      
      
      <categories>
          
          <category> 资料总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSU </tag>
            
            <tag> 软件项目组织管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>github加速访问的几种方法</title>
      <link href="/posts/14750.html"/>
      <url>/posts/14750.html</url>
      
        <content type="html"><![CDATA[<h1 id="github加速访问的几种方法"><a href="#github加速访问的几种方法" class="headerlink" title="github加速访问的几种方法"></a>github加速访问的几种方法</h1><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>有些同学在做实验时需要在github上下载一些文件，但是github又被墙了，因此老是询问我如何去github上下载，本文我就记述了几种加速访问github的方法。</p><h2 id="github镜像访问"><a href="#github镜像访问" class="headerlink" title="github镜像访问"></a>github镜像访问</h2><p>下面是两个github的镜像网站，网站是跟github完全同步的，可以在这些网站里面进行下载克隆等操作：</p><ul><li><a href="https://github.com.cnpmjs.org/">https://github.com.cnpmjs.org/</a></li><li><a href="https://hub.fastgit.org/">https://hub.fastgit.org/</a></li></ul><h2 id="CDN文件访问加速"><a href="#CDN文件访问加速" class="headerlink" title="CDN文件访问加速"></a>CDN文件访问加速</h2><p>利用 Cloudflare Workers 对 github release 、archive 以及项目文件进行加速，部署无需服务器且自带CDN：</p><ul><li><a href="https://gh.api.99988866.xyz/">https://gh.api.99988866.xyz/</a></li><li><a href="https://ghproxy.com/">https://ghproxy.com/</a></li></ul><p>我们可以复制某个github页面的URL，然后粘贴到这些网站里面，即可实现访问下载。</p><p>虽说二者皆可实现下载，但是第一个大小限制为20MB，第二个暂不清楚。</p><h2 id="github加速下载"><a href="#github加速下载" class="headerlink" title="github加速下载"></a>github加速下载</h2><p>除了上述的方式，还可以使用下面这个链接进行加速下载：</p><ul><li><a href="http://toolwa.com/github/">http://toolwa.com/github/</a></li></ul><h5 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h5><ol><li>打开你要下载的 <a href="https://github.com/">GitHub</a> 仓库页面</li><li>点击右侧的绿色按钮 “Code” &gt; “Download ZIP”</li><li>等浏览器弹出下载框后复制下载框中的链接地址并粘贴到以上输入框</li><li>点击加速下载</li></ol><h2 id="加速你的Github"><a href="#加速你的Github" class="headerlink" title="加速你的Github"></a>加速你的Github</h2><p><a href="https://github.zhlh6.cn/">https://github.zhlh6.cn/</a></p><p>输入 Github 仓库地址，使用生成的地址进行 git ssh 等操作.</p><h2 id="github加速插件"><a href="#github加速插件" class="headerlink" title="github加速插件"></a>github加速插件</h2><p>可以在浏览器的插件市场里面搜索<code>Enhanced GitHub</code>，打开就可以很快的访问github</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210621151756506.png" alt="Enhanced GitHub"></p><p>也可以点击我这个链接直接进行下载，然后打开浏览器拓展—&gt;<code>开发者模式</code>—&gt;将改文件拖进去进行安装。<a href="https://cdn.jsdelivr.net/gh/sehowyoung/DataRepository@main/Enhanced%20GitHub.crx">https://cdn.jsdelivr.net/gh/sehowyoung/DataRepository@main/Enhanced%20GitHub.crx</a></p><h2 id="github-raw-加速"><a href="#github-raw-加速" class="headerlink" title="github raw 加速"></a>github raw 加速</h2><p>GitHub raw 域名并非 github.com 而是 raw.githubusercontent.com，上方的 GitHub 加速如果不能加速这个域名，那么可以使用 Static CDN 提供的反代服务。</p><p>将 raw.githubusercontent.com 替换为 raw.staticdn.net 即可加速。</p><h2 id="jsdeliver-加速"><a href="#jsdeliver-加速" class="headerlink" title="jsdeliver 加速"></a>jsdeliver 加速</h2><p>jsdelivr 唯一美中不足的就是它不能获取 exe 文件以及 Release 处附加的 exe 和 dmg 文件，同时也不能下载超过20MB的文件。</p><p>也就是说如果 exe 文件是附加在 Release 处但是没有在 code 里面的话是无法获取的。所以只能当作静态文件 cdn 用途，而不能作为 Release 加速下载的用途。</p><h3 id="使用方法：-1"><a href="#使用方法：-1" class="headerlink" title="使用方法："></a>使用方法：</h3><p><a href="https://cdn.jsdelivr.net/gh/你的用户名/你的仓库名@发布的版本号/文件路径">https://cdn.jsdelivr.net/gh/你的用户名/你的仓库名@发布的版本号/文件路径</a></p><p>例如：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">https://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@1.0/images/trhx.pnghttps://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@2.0.1/css/style.css  https://cdn.jsdelivr.net/gh/moezx/cdn@3.1.3//The%20Pet%20Girl%20of%20Sakurasou.mp4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>注意：版本号不是必需的，是为了区分新旧资源，如果不使用版本号，将会直接引用最新资源，除此之外还可以使用某个范围内的版本，查看所有资源等，具体使用方法如下：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">// 加载任何Github发布、提交或分支https://cdn.jsdelivr.net/gh/user/repo@version/file// 加载 jQuery v3.2.1https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/dist/jquery.min.js// 使用版本范围而不是特定版本https://cdn.jsdelivr.net/gh/jquery/jquery@3.2/dist/jquery.min.js   https://cdn.jsdelivr.net/gh/jquery/jquery@3/dist/jquery.min.js // 完全省略该版本以获取最新版本https://cdn.jsdelivr.net/gh/jquery/jquery/dist/jquery.min.js // 将“.min”添加到任何JS/CSS文件中以获取缩小版本，如果不存在，将为会自动生成https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/src/core.min.js // 在末尾添加 / 以获取资源目录列表https://cdn.jsdelivr.net/gh/jquery/jquery/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Gitee进行仓库迁移"><a href="#Gitee进行仓库迁移" class="headerlink" title="Gitee进行仓库迁移"></a>Gitee进行仓库迁移</h2><p>访问 gitee 网站：<a href="https://gitee.com/">https://gitee.com/</a> 并登录，在顶部选择“从 GitHub/GitLab 导入仓库”</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210610194849360.png" alt="从GitHub/GitLab导入仓库"></p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210610194922761.png" alt="选择仓库进行导入"></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ol><li><a href="https://segmentfault.com/a/1190000038298623">提高国内访问 github 速度的 9 种方法！</a></li><li><a href="https://zhuanlan.zhihu.com/p/76951130">免费CDN：jsDelivr+Github 使用方法</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件项目组织管理资料总结—CSU</title>
      <link href="/posts/13116.html"/>
      <url>/posts/13116.html</url>
      
        <content type="html"><![CDATA[<h1 id="软件项目管理"><a href="#软件项目管理" class="headerlink" title="软件项目管理"></a>软件项目管理</h1><p>PDF版下载地址：<a href="https://cdn.jsdelivr.net/gh/sehowyoung/DataRepository@main/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%BB%84%E7%BB%87%E7%AE%A1%E7%90%86%E8%B5%84%E6%96%99%E6%80%BB%E7%BB%93%E2%80%94CSU.pdf">点此下载</a></p><h2 id="走进项目管理"><a href="#走进项目管理" class="headerlink" title="走进项目管理"></a>走进项目管理</h2><h3 id="项目的基本概念"><a href="#项目的基本概念" class="headerlink" title="项目的基本概念"></a>项目的基本概念</h3><p>活动的三个基本特点：</p><ul><li>目的性：为了达到预期的目的而活动</li><li>依存性：分工越来越细，依存越来越紧密</li><li>知识性：在实践与经验中学习，形成知识体系</li></ul><p>两种人类有组织的活动：</p><ul><li>作业（Operations 运行 运营）：连续不断、周而复始的活动，例：企业日常的生产产品的活动、财务人员的日常记账工作等</li><li>项目（Projects）：临时性的、一次性的活动，例：企业开发新产品、企业的技术改造活动等</li></ul><p>项目是实现价值、成就事业的载体；项目管理既是项目成功的要素，也是项目失败的根源。</p><p>项目是为完成某一独特的产品或服务而进行的一次性努力。</p><p>项目的特征：</p><ul><li>项目有一个独特的目的(功能指标、产出物指标、项目工作指标、范围、时间、成本、质量目标)</li><li>一次性：不存在完全相同的项目</li><li>项目需要来自不同领域的各种各样的资源</li><li>整体性：不是一项项孤立活动的堆积</li><li>临时性：有规定的时间段</li><li>不确定性：目标的复杂性和可变性</li><li>多变性：资源需求动态、多变、不确定</li><li>随着发展逐渐进行细化,渐进明晰(过程性)</li><li>具有发起人：提供目标和资金</li></ul><p>项目的组成要素：</p><ul><li>时间：完成该项目需要多长时间?项目进度应该怎样安排？</li><li>范围：项目的任务是什么?顾客或发起人要通过项目获得什么样的产品或服务？</li><li>费用：完成该项目需要花费多少？</li></ul><p>项目管理是指在项目活动中运用相关的知识、技能、工具和方法，以实现或超过项目干系人的需要和期望。</p><p>IT项目的定义：利用有限资源、在一定的时间内，完成满足一系列特定的IT信息化目标的多项相关工作。</p><p>软件项目管理：为了使软件项目能够按照预定的范围、成本、进度、质量顺利完成，而对范围、费用、时间、质量、人力资源、风险、采购等进行分析和管理的活动。</p><p>软件项目失败的原因：一是软件项目的复杂性，二是缺乏合格的软件项目管理人才。缺乏有效的项目管理是导致软件项目失控的直接原因。</p><p>项目的利益相关者：</p><ul><li>参与项目或受项目影响的个人或组织——项目 <code>干系人</code></li><li>主要的 <code>项目利益相关者</code> ：<ul><li>项目经理</li><li>客户</li><li>项目执行组织</li><li>项目团队成员</li><li>项目发起人、出资方</li></ul></li><li><code>管理工具与方法</code><ul><li>识别各干系人，确定项目干系人需求和渴望</li><li>管理和影响项目干系人的期望以确保项目成功。</li></ul></li></ul><p>项目管理和作业管理的区别：</p><ul><li><p>| 项目管理             | 作业管理                       | 项目组合管理         |<br>| —————————— | ——————————————— | —————————— |<br>| 充满不确定性         | 注重对效率和质量的考核         | 战略目标             |<br>| 有严格的时间期限要求 | 注重当前执行情况与前期进行比较 | 项目组合的投资回报   |<br>| 跨越部门的界限       |                                | 资源约束下的项目选择 |</p></li><li><p>项目管理：通过不完全确定的过程，在确定的期限内生产出不完全确定的产品。</p></li><li><p>作业管理：管理结构须以任务（活动）定义为基础来建立，以便进行时间、费用和人力的预算控制，并对技术、风险进行管理。</p></li></ul><h3 id="项目管理知识体系"><a href="#项目管理知识体系" class="headerlink" title="项目管理知识体系"></a>项目管理知识体系</h3><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210621105545697.png" alt="基于PMBOK的项目管理框架" style="zoom:67%;"></p><h3 id="项目管理九大知识领域"><a href="#项目管理九大知识领域" class="headerlink" title="项目管理九大知识领域"></a>项目管理九大知识领域</h3><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210621105433640.png" alt="项目管理九大知识领域" style="zoom:50%;"></p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210621105943730.png" alt="项目管理九大知识领域" style="zoom: 67%;"></p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210621105450557.png" alt="项目管理工具和技术" style="zoom:67%;"></p><h3 id="IT项目管理知识体系"><a href="#IT项目管理知识体系" class="headerlink" title="IT项目管理知识体系"></a>IT项目管理知识体系</h3><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210621110916272.png" alt="iPMBOK三维结构模型" style="zoom:50%;"></p><h3 id="项目群和项目组合管理"><a href="#项目群和项目组合管理" class="headerlink" title="项目群和项目组合管理"></a>项目群和项目组合管理</h3><p>项目群（program）：多个相互关联项目的集合，且多个项目间有如下两大基本特征：</p><ul><li>相互关联</li><li>每个项目相互间有一定的相似性</li></ul><p>项目群管理（program Management）：一组相互关联的项目，使用协同方法进行管理来获得收益和进行控制，而这种收益和控制在单独管理这些项目时是不易获得的。</p><p>项目群管理强调：</p><ul><li>集成（如IT项目的弱电集成项目）</li><li>协同与资源优化</li></ul><p>项目组合管理——对由项目和项目群有机组合的整体所开展的管理。</p><p>项目组合的目的——实现组织战略和愿景，也称战略项目组合。</p><p>项目管理和项目组合管理的不同之处：最主要的区别在各自致力于达到的目标上，战术目标还是战略目标。（战术目标更具体,时间短；战略目标重点强调一组织的长期目标），如下图所示：</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210621111556738.png" alt="项目管理和项目组合管理的不同之处" style="zoom:50%;"></p><h3 id="项目经理"><a href="#项目经理" class="headerlink" title="项目经理"></a>项目经理</h3><p>项目群经理对项目组内的项目进行领导并指明方向。协调项目团队，职能部门，供应商和运营员，以支持项目达到产品和过程的最大收益。</p><p>项目经理首要职责是在预算范围内按时优质地领导项目小组完成全部项目工作内容，并使客户满意。</p><p>项目经理应掌握的技能：</p><ul><li>领导技能：在激励人们达到目标时专注于长期以及整体的目标。</li><li>管理技能：常关注为达到具体目标所需要的日常细节。</li></ul><h3 id="项目管理发展阶段"><a href="#项目管理发展阶段" class="headerlink" title="项目管理发展阶段"></a>项目管理发展阶段</h3><p>项目管理大致经历了潜意识阶段、传统项目管理阶段、项目管理的传播阶段和现代项目管理的发展阶段。</p><h2 id="项目管理与信息技术环境"><a href="#项目管理与信息技术环境" class="headerlink" title="项目管理与信息技术环境"></a>项目管理与信息技术环境</h2><h3 id="项目管理的系统观点"><a href="#项目管理的系统观点" class="headerlink" title="项目管理的系统观点"></a>项目管理的系统观点</h3><p>系统方法：产生于20世纪50年代, 描述一种在解决复杂问题时所需的整体性和分析性的方法。</p><p>包括三部分：</p><ul><li>系统哲学 — 将事情作为系统考虑的整体模型</li><li>系统分析 — 解决问题的方法</li><li>系统管理 — 解决与系统的创建、维持和变更相关的业务上、技术上和组织上的问题</li></ul><h3 id="组织"><a href="#组织" class="headerlink" title="组织"></a>组织</h3><p>环境：组织外不存在的一切客观因素和条件</p><p>组织：按照一定目的、任务和刑事加以编制的群体</p><p>组织环境：存在于组织外部，和组织密切联系，决定组织存在和发展的自然、经济、技术、政治、社会的各种因素和条件的总和。任何一个组织都离不开外部因素和条件而独立存在。</p><p>组织的四个框架：</p><ol><li>结构框架：用来解决组织结构化的问题着眼于不同部门的角色、责任，以满足最高管理层设定的目标和政策（重点用于协调、控制）</li><li>人力资源框架：重点在于促成组织需求和个人需求之间的平衡与协调</li><li>政治框架：处理组织和人的政治问题；假定组织是由各种人和利益集团组成的联合体；冲突和权力是中心问题</li><li>标志框架：主要指与事件相关的符号和含义；文化很重要</li></ol><p>三种组织结构：</p><ul><li><p>职能型：职能经理向CEO汇报</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210621163317917.png" alt="职能型组织" style="zoom:50%;"></p></li><li><p>项目型：项目经理对CEO负责</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210621163338089.png" alt="项目型组织" style="zoom:50%;"></p></li><li><p>矩阵型：介于职能型组织和项目型组织之间，需要向两个或多个上级汇报，分为弱矩阵、平衡矩阵和强矩阵</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210621163404898.png" alt="弱矩阵型组织" style="zoom:50%;"></p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210621163549393.png" alt="平衡矩阵型组织" style="zoom:50%;"></p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210621163618317.png" alt="强矩阵型组织" style="zoom:50%;"></p></li></ul><h3 id="项目阶段和项目生命周期"><a href="#项目阶段和项目生命周期" class="headerlink" title="项目阶段和项目生命周期"></a>项目阶段和项目生命周期</h3><p>项目生命周期是项目阶段的集合，负责定义</p><ul><li>每个阶段要完成哪些工作</li><li>制造哪些可交付的成果, 及何时提交</li><li>每个阶段有哪些参与人员</li><li>每个阶段如何控制管理和批准已制造的工作</li></ul><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210621164235571.png" alt="项目生命周期基本框架" style="zoom:50%;"></p><p>四个阶段主要任务：</p><ul><li>概念阶段：主要任务是制定高水平的总体计划/总体方案/项目建议书</li><li>开发阶段：主要任务是规划项目怎么做？谁来做？项目组要根据总体计划/总体方案，制定出更为详细的项目计划/项目规划。</li><li>实施阶段：主要工作是执行项目计划，并进行项目的监督和控制。其目的就是把计划/规划中的内容完成。</li><li>收尾阶段：主要任务完成项目的验收与工作总结，为后续的项目提供经验、教训和帮助。 </li></ul><p>管理评审被称为阶段出口或终止点：</p><ul><li>在每个项目阶段结束后发生</li><li>评估项目进度、成功可能性以及项目与商业目标持续的兼容性</li></ul><p>项目管理评审的目的是要判断项目是否应该继续、重新定位或终止。每个阶段的管理评审，对后阶段的工作起指导性的作用，务必严格执行。</p><h3 id="IT项目环境"><a href="#IT项目环境" class="headerlink" title="IT项目环境"></a>IT项目环境</h3><p>虚拟团队是虚拟组织中一种新型的工作组织形式，是一些人由于具有共同理想、共同目标或共同利益，结合在一起所组成的团队。从狭义上说，虚拟团队仅仅存在于虚拟的网络世界中；广义来说，虚拟团队早已应用在真实的团队建设世界里。虚拟团队只要通过电话、网络、传真或可视图文来沟通、协调，甚至共同讨论、交换文档，便可以分工完成一份事先拟定好的工作。</p><p>换句话说，虚拟团队就是在虚拟的工作环境下，由进行实际工作的真实的团队人员组成，并在虚拟企业的各成员相互协作下提供更好的产品和服务。虚拟团队作为一种新型的组织形态，具有不少优于传统团队的特征。</p><h3 id="项目管理过程组"><a href="#项目管理过程组" class="headerlink" title="项目管理过程组"></a>项目管理过程组</h3><p>过程——是为实现某个特定目标而进行的一系列活动。</p><p>项目管理过程组：是从启动到计划、执行（实施）、控制（监控）和收尾的一系列活动。</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210621170831633.png" alt="项目管理过程组在活动水平、时间上的相互叠加关系" style="zoom:50%;"></p><p>各过程组的成果：</p><ul><li>启动过程成果：<ul><li>开始阶段：是形成一个项目章程和选择一位项目经理。</li><li>新阶段：是对阶段进入条件的评估与确认</li></ul></li><li>计划过程成果：包括完成工作分解结构和范围说明书、项目进度和项目成本估计</li><li>执行过程成果：按计划完成项目工作，即项目实际工作的交付。</li><li>监控过程成果：理想产出是通过交付满足时间、成本和质量约束的项目来成功地完成项目。</li><li>收尾过程成果：关键结果是工作的正式验收和以及项目审计和项目经验总结报告等一些总结性文件的编写、提交、审定和归档。</li></ul><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210621171709136.png" alt="九九归一" style="zoom: 50%;"></p><div class="table-container"><table><thead><tr><th>知识领域</th><th>启动过程</th><th>计划过程</th><th>实施过程</th><th>监控过程</th><th>收尾过程</th></tr></thead><tbody><tr><td>项目集成管理</td><td>制定项目章程</td><td>制定项目管理计划</td><td>指导和管理项目实施</td><td>监控项目工作、整体变更控制</td><td>项目收尾</td></tr><tr><td>项目范围管理</td><td></td><td>需求收集、范围定义和创建工作分解结构</td><td></td><td>范围核实、范围控制</td><td></td></tr><tr><td>项目时间管理</td><td></td><td>活动定义、活动排序、活动资源估算、活动工期估算、生成进度表</td><td></td><td>进度控制</td><td></td></tr><tr><td>项目成本管理</td><td></td><td>成本估算、成本预算</td><td></td><td>成本控制</td><td></td></tr><tr><td>项目质量管理</td><td></td><td>质量计划</td><td>实施质量保证</td><td>实施质量控制</td><td></td></tr><tr><td>项目人力资源管理</td><td></td><td>开发人力资源计划</td><td>项目团队组建、项目团队建设</td><td>项目团队管理</td><td></td></tr><tr><td>项目沟通管理</td><td>识别利益相关者</td><td>沟通计划</td><td>信息发布</td><td>绩效报、告利益相关者管理</td><td></td></tr><tr><td>项目风险管理</td><td></td><td>风险管理计划、风险识别、定型风险估计、定量风险分析、风险应对计划</td><td></td><td>风险监控</td><td></td></tr><tr><td>项目采购管理</td><td></td><td>采购与获取计划、发包计划</td><td>询价、选择卖方</td><td>采购管理</td><td>采购终止</td></tr></tbody></table></div><h2 id="项目集成管理"><a href="#项目集成管理" class="headerlink" title="项目集成管理"></a>项目集成管理</h2><p>项目集成管理是指为确保项目各项工作能够有机地协调和配合所开展的综合性和全局性的项目管理工作和过程。</p><p>七个过程：</p><ol><li>指定项目章程</li><li>创建初步的项目范围说明书</li><li>制定项目管理计划</li><li>指导和管理项目实施：这个阶段主要完成交付物、变更请求、工作绩效信息、被实施的变更请求、纠正措施、预防措施和缺陷修复。</li><li>监控项目工作：这个阶段主要完成惩治和预防措施建议、缺陷修复建议以及变更请求。</li><li>整体变更控制：这个阶段的任务包括被批准和被拒绝的变更请求、被批准的纠正和预防措施、被批准和生效的缺陷修复、交付物、项目管理计划和项目范围说明书的更新。</li><li>项目收尾：这个阶段包括最终产品、服务或者成果，行政上和合同上的终止于续，以及对组织运营资产的更新。</li></ol><p>战略计划(strategic planning) 包括通过分析组织的优势和劣势，研究在商业环境中的机会和威胁，<code>预测未来的趋势</code> ，以及预测对新产品和服务的需求来 <code>确定长期的目标</code>。</p><p>SWOT 即基于内外部竞争环境和竞争条件下的态势分析，就是将与研究对象密切相关的各种主要<code>内部优势、劣势和外部的机会和威胁</code>等，通过调查列举出来，并依照 <code>矩阵</code> 形式排列，然后用<code>系统分析</code>的思想，把各种因素相互匹配起来加以分析，从中得出一系列相应的结论，而结论通常带有一定的决策性。</p><p>运用这种方法，可以对研究对象所处的情景进行 <code>全面、系统、准确</code>的研究，从而根据研究结果制定相应的 <code>发展战略、计划以及对策</code>等。</p><h3 id="筛选信息技术项目过程"><a href="#筛选信息技术项目过程" class="headerlink" title="筛选信息技术项目过程"></a>筛选信息技术项目过程</h3><ol><li><p>关注整个组织的需求</p><ol><li>项目越能符合整个组织的需求，其成功的概率就越大。</li><li>基于整个组织的需求选择项目的方法之一是：判断它们是否符合三个重要的标准：“ <code>需求、资金和意愿</code>”。</li></ol><p>注意：随着项目的推进，组织必须重新评估每个项目的这三个标准以决定项目是否继续或重新定义或是终止。</p></li><li><p>对IT项目进行分类</p><p>以各种分类方法为基础进行项目筛选</p><ol><li>评价项目是否可以 <code>解决某个问题</code>，或是抓住 <code>某种机会</code>，或迎合 <code>某个指示要求</code>；</li><li><code>基于时间</code> 的考虑筛选项目，可能是完成项目所需的工期时间，也可能是项目必须满足的截止日期；</li><li>将待选 <code>项目按高、中、低</code>三个次序进行整体综合排序，首先进行最重要的项目。</li></ol></li><li><p>进行财务分析：</p><ol><li>净现值（NPV）：是计算项目所产生的现金净流量，以资金成本为贴现率折现后与原始投资额现值的差额。</li><li>投资收益率（ROI）：投资回报率/投资回报(retum on investment , ROI) 是项目的收益减去成本后，再除以成本的结果</li><li>投资回收期：以现金流的方式，将在项目中的总投资全部收回的时间。</li></ol></li></ol><h3 id="项目章程"><a href="#项目章程" class="headerlink" title="项目章程"></a>项目章程</h3><p>项目章程是指一份正式确认项目存在的文件。它指明了项目的目标和管理的方向，授权项目经理利用组织的资源去完成项目。</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210621185624216.png" alt="项目章程示例" style="zoom:67%;"></p><p>项目管理计划是一个用来<code>协调</code> 所有其他计划，以 <code>指导项目执行和控制</code>的可操作的文件。</p><p>一个项目计划主要包括：<code>整体介绍、组织描述、管理程序、技术程序、任务范围、时间进度、经费预算</code> 等。</p><h3 id="集成变更控制"><a href="#集成变更控制" class="headerlink" title="集成变更控制"></a>集成变更控制</h3><p>集成变更控制( integrated change control) 涉及在整个项目的生命周期中<code>识别、估计和管理变更</code>。</p><p>目的：</p><ul><li>控制可能造成变更的因素，以确保变更都是有益的。</li><li>确认变更已经发生。</li><li>管理发生的变更。</li></ul><p>变更控制系统是一个<code>正式的、文档化的</code>过程。</p><p>变更控制系统三要素：</p><ol><li>建立变更控制组织</li><li>强化配置管理</li><li>及时进行沟通</li></ol><h2 id="项目范围管理"><a href="#项目范围管理" class="headerlink" title="项目范围管理"></a>项目范围管理</h2><h3 id="项目需求与范围管理的重要性"><a href="#项目需求与范围管理的重要性" class="headerlink" title="项目需求与范围管理的重要性"></a>项目需求与范围管理的重要性</h3><p>软件企业与IT项目应用企业信息化成功的基本保证是对项目范围的确切圈定，为此必须强调：</p><ul><li>三类人的获取<ul><li>需求专家</li><li>咨询专家</li><li>概要设计专家</li></ul></li><li>三要素的把握<ul><li>企业需求</li><li>管理理论</li><li>竞争压力</li></ul></li></ul><p>软件企业对三类人（需求专家、概要设计专家、咨询专家）的获取和培养，以及项目应用企业对项目范围三要素（企业需求、管理理论、竞争压力）的有效把握，是软件企业与IT项目应用企业信息化成功的 <code>基本保证</code>！</p><h3 id="项目范围管理相关概念"><a href="#项目范围管理相关概念" class="headerlink" title="项目范围管理相关概念"></a>项目范围管理相关概念</h3><p>范围是指开展项目产品所包括的所有工作及产生这些产品经过的所有过程。</p><p>项目范围是以其组成的所有产品范围定义为基础，但又不限于产品范围，还包括为实现这些产品范围内的工作必须要做的管理工作（进度管理等）</p><p>项目范围管理是指对项目包括什么与不包括什么的定义与控制过程。</p><blockquote><p>项目范围管理中的“范围”是指产品范围和项目范围两个概念的总和。</p></blockquote><p>项目范围管理的作用：</p><ul><li>为项目实施提供任务范围的框架</li><li>对项目的实施提供有效的控制</li><li>为项目最终交付提供依据</li></ul><p>项目范围管理的作用：保证了项目干系人对项目的结果以及产生结果的过程的共同理解；同时，也为项目的控制提供的依据。</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210621191222332.png" alt="项目范围管理的过程" style="zoom:50%;"></p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210621191311571.png" alt="项目范围管理的主要工作" style="zoom:50%;"></p><p>项目范围管理五阶段：</p><ol><li><p>范围规划</p><p>包括确定如何定义、验证并控制项目范围以及如何构建工作分解结构。</p><p>输出：项目范围管理计划 </p></li><li><p>范围定义</p><p>评审启动过程编制的项目章程和初步范围说明书，并随着需求的扩展及变更请求得到批准，在规划过程中增加更多的信息。<br>输出：项目范围说明、项目变更要求、项目范围管理计划的更新</p></li><li><p>工作结构分解</p><p>将主要的项目可交付成果分解成更小和更易管理的部分。<br>输出：WBS、WBS词典、范围基线、项目管更请求、项目范围说明书和项目管理计划的更新</p></li><li><p>范围验证</p><p>将项目范围的认可正式化。关键的利益相关者进行审查，然后正式接受项目的可交付成果。如果不接受会请求作出变更，并提出采取纠正措施的建议。<br>输出：接受的可交付成果、变更要求、建议的纠正措施</p></li><li><p>范围控制</p><p>对项目范围的变化进行控制。<br>输出：变更请求，建议的纠正措施，项目范围说明书，WBS及WBS词典、范围基线、项目管理几乎及组织过程资产的更新</p></li></ol><h3 id="工作分解结构"><a href="#工作分解结构" class="headerlink" title="工作分解结构"></a>工作分解结构</h3><p>工作分解结构（WBS）是一种以结果为导向的分析方法，用于分析项目所涉及到的工作，所有这些工作构成了项目的整个范围。</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210621192109784.png" alt="WBS的作用" style="zoom: 67%;"></p><p>WBS的特点：</p><ul><li>常用于建立或确立对项目范围达成共识</li><li>通常以图表的形式表示—树型图法、列表法、气泡法等</li><li>BS中的每一项元素通常被赋予唯一的标识</li><li>WBS的最低一层元素一般被称为工作包</li><li>WBS字典：描述WBS每项条目详细信息的文件，一般包含工作包的描述+其它计划信息：预期、工期、人员安排…….</li></ul><p>建立WBS的方法：</p><ul><li>类比法（WBS模板法）：选取相似项目的WBS作为参考</li><li>分解法（项目目标→项目产出物→可交付物→WBS）：从上至下、从下至上</li></ul><p>范围基线：项目范围说明书及相关的WBS、WBS词典构成，是实现项目范围目标的绩效的依据</p><h2 id="项目时间管理"><a href="#项目时间管理" class="headerlink" title="项目时间管理"></a>项目时间管理</h2><h3 id="项目进度计划的重要性"><a href="#项目进度计划的重要性" class="headerlink" title="项目进度计划的重要性"></a>项目进度计划的重要性</h3><p>项目计划 是指导项目实施和控制的一系列纲领性文件，是经高层管理批准的项目正式文档。</p><p>进度计划 是表达项目中各项工作（活动）的开展顺序、开始及完成时间及相互衔接关系的计划。进度计划是进度控制和管理的依据；同时引导项目其他类型的计划工作。</p><p>项目时间管理包括为确保项目按时完成所需要的各个过程。主要过程：活动定义、活动排序、活动资源估算、活动历时估算、项目进度计划编制、以及进度跟踪与控制过程。</p><p>活动或任务:是项目进行期间需要完成的工作单元，它们有预期的历时、成本和资源要求。</p><hr><p>分解用于活动定义时，最后结果是Activities；分解用于范围定义时，最后结果为Deliverables。</p><h3 id="活动排序"><a href="#活动排序" class="headerlink" title="活动排序"></a>活动排序</h3><p>依赖关系或关系反映了项目活动或任务的顺序。一个没有明确活动之间关系的项目是不可能成功的。</p><ul><li>强制依赖关系（硬逻辑关系）是项目工作固有的特性(行业逻辑）。</li><li>自由依赖关系（软逻辑关系）是由项目团队来定义的(是否签字）。</li><li>外部依赖关系 涉及项目与非项目活动之间的关系（操作系统供应商）。 </li></ul><p>活动排序的工具：</p><ul><li><p>箭线图法(ADM)-双代号网络(AOA)：用箭线表示活动，用节点表示活动间的相互依赖关系</p><ul><li><p>只使用一种活动之间的逻辑关系：FS</p></li><li><p>作图要求</p><p>每一个事件必须有唯一的事件号 </p><p>每一个活动用唯一的紧前事件和紧后事件描述</p><p>紧前事件编号要小于紧后事件编号</p></li><li><p>是唯一使用虚活动的活动排序工具。</p></li></ul><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210621223139031.png" alt="箭线图法——双代号网络例图" style="zoom: 50%;"></p><ul><li>虚线表示虚活动：<ul><li>虚活动没有历时，不需要资源</li><li>箭线图网络表示活动关系的需要</li><li>用带箭头的虚线表示</li></ul></li></ul></li><li><p>前导图法（PDM）— 单代号网络（AON）：一种使用<code>节点表示活动工作、箭线表示活动间依赖关系</code> 的项目网络图。这种网络图通常称为<code>单代号网络</code> （简称AON）,这种方法是大多数项目管理软件包所使用的方法。</p><ul><li>AON使用多种活动逻辑关系，其中FS关系用得最多</li><li>没有虚活动</li></ul><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210621223512069.png" alt="前导图法——单代号网络例图" style="zoom:50%;"></p><ul><li><p>四种依赖关系：</p><ul><li>完成—开始：“A”活动必须在“B”活动开始之前完成，图1</li><li>开始—开始：“A”活动只有在“B”活动开始的时候开始，图2</li><li>完成—完成： “A”活动必须在“B”活动完成之前完成，图3</li><li>开始—完成： “A”活动必须在“B”活动完成之前开始，图4</li></ul><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210621225530606.png" alt="图1                                图2                                 图3                         图4" style="zoom:50%;"></p><p>它对加强某种类型时间关系的可视性很有帮助。</p></li><li><p>PDM法的优点：</p><ol><li>大多数项目管理软件使用PDM法</li><li>PDM法避免了使用虚活动</li><li>PDM法反映了人物之间的各种依赖关系</li></ol></li></ul></li></ul><h3 id="进度安排"><a href="#进度安排" class="headerlink" title="进度安排"></a>进度安排</h3><p>制定进度计划的最终目标是：建立一个现实的项目进度计划，为监控项目的时间进展情况提供一个基础。</p><p>进度安排的的工具:</p><ul><li><p>甘特图：显示项目信息最常用的工具；</p></li><li><p>关键路径分析：也称为关键路径分析，是预测总体项目历时的网络分析技术，是帮助我们分析与解决进度拖延的一种重要工具。</p><ul><li>关键路径：是指一系列决定项目最早完成时间的活动。它是项目网络图中最长的路径，并且有最少的浮动时间或时差。 </li><li>关键路径法（CPM）：根据制定的网络顺序逻辑关系和单一历时估算，计算每一个活动的唯一、具体的最早和最迟开始及完成日期。其核心是计算浮动时间，确定哪些活动的进度安排灵活性最小。</li><li><p>步骤：</p><ul><li>绘制网络图 AON、AOA</li><li>确定项目的开始时间和结束时间</li><li>不考虑资源约束的条件下，计算项目的工期，包括：网络的关键路径、各个活动的自由浮动时间</li><li>计算资源需求计划</li></ul></li><li><p>特点：</p><ul><li>关键路径是最长的路径。</li><li>关键路径反映了项目所花费的最短的时间。</li><li>关键路径上的活动超时，总体进度就要拖延。</li><li>关键路径只与项目的时间有关与关键活动无关。</li><li>关键路径它与选择最短的路径无关。     </li><li>一个项目可能会有超过一条的关键路径。</li><li>一个项目的关键路径可能会发生变化。</li></ul></li><li><p>应用：</p><ul><li>利用关键路径分析平衡进度计划</li><li>缩短路径上的活动历时</li><li>关注与及时更新关键路径数据</li></ul><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210621230840151.png" alt="关键路径法示例" style="zoom:67%;"></p></li></ul></li><li><p>计划评审技术分析（PERT）：评价项目进度风险的一种手段。 </p><ul><li>PERT 是项目时间管理的另一项技术。</li><li>PERT将关键路径法应用于加权平均历时估算。</li><li>PERT 采用乐观的、最可能的、悲观的活动历时估计进行项目历时估计。</li><li>$PERT加权平均=\frac {乐观时间 + 4 \times 最可能的时间+ 悲观时间} {6}$</li></ul></li></ul><p>浮动时间：反映活动的机动性，是一个活动在不影响整个项目完成时间的情况下，可以延迟的时间量。因而，也称为最大的机动时间。   <code>TF＝LS－ES＝LF-EF</code></p><p>自由浮动时间：是指可以在不推迟任何后续活动最早开始时间的情况下，本活动可以推迟的时间。一般情况下，FF＜TF。自由浮动时间的计算方法为：<code>FF＝后续活动的ES－本活动的EF</code></p><h3 id="缩短项目工期的方法"><a href="#缩短项目工期的方法" class="headerlink" title="缩短项目工期的方法"></a>缩短项目工期的方法</h3><ul><li>在进度计划制订后，可能项目结束日期不满足要求，需要进一步缩短进度计划的项目工期。</li><li>可以采用赶工（Crashing,通过增加资源）或快速跟进（Fast tracking,通过并行施工）等方法。</li></ul><h2 id="项目成本管理"><a href="#项目成本管理" class="headerlink" title="项目成本管理"></a>项目成本管理</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>成本：伟大到一个特定的目标而花费或者用掉的资源</li><li>项目成本：实现项目目标所消耗资源而形成的费用</li><li>可变成本：随生产量或工作量而变。如物料、供应品、工资等。</li><li>固定成本：不随生产的变化而变化的非重复成本。如设备费、租赁费等。</li><li>直接成本：与生产项目和服务直接相关的成本。如差旅费、工资、项目使用的物料等。</li><li>间接成本：间接地和完成的项目相关。如税金、额外福利和保卫费用等。</li><li>无形成本：很难用货币来衡量的成本和收益。</li><li>有形成本：能够容易的用货币来衡量的那些价值。</li><li>沉没成本：在过去已经发生，在未来不可能取消的成本，应该像永远不能收回的沉船一样考虑它。</li><li>机会成本：如果选择另一项目放弃这一项目的收益所引发的成本。</li><li>学习曲线理论：当重复生产许多产品时，那些产品的单位成本随着数量的增多成规律性递减。学习曲线理论用来估计生产大量产品的项目之成本。</li><li>储备金是包含于成本估算中的、为减轻未来难以预测情形带来的成本风险而准备的那部分资金。</li><li>项目成本管理 包括为保障项目实际发生成本不超过项目预算而开展的项目成本估算、成本预算和成本控制等方面的管理活动。</li><li>项目成本管理的目的：确保项目在批准的预算内完成,实现项目价值最大化。</li><li>成本估算：对完成项目各活动项目所需人员、材料、设备等资源费用的近似值。</li></ul><h3 id="成本估算"><a href="#成本估算" class="headerlink" title="成本估算"></a>成本估算</h3><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210622135349354.png" alt="项目成本管理过程" style="zoom:50%;"></p><p>成本估算工具与技术：</p><ul><li>类比估算法：也叫自上而下估算法，它是使用以前的、相似项目的实际成本作为目前项目成本估算的根据，这是一种专家判断法，该方法较其他方法更节省，但不是很精确。</li><li>自下而上估计法：估算单个工作项和汇总单个工作项成整体项目，单个工作项的大小和估算人员的经验决定估算的精度。</li><li>参数模型估算法：是在数学模型中应用项目特征(参数)以估算项目成本。 </li><li>计算机化的工具：像电子数据表和项目管理软件等计算机化工具能够进行不同的成本估算，它是一种更容易的成本估算工具。  </li></ul><p>估算类型与主要输出</p><div class="table-container"><table><thead><tr><th>估算类型</th><th>何时做</th><th>为什么做</th><th>精确度如何</th></tr></thead><tbody><tr><td>粗略的量级估算</td><td>在项目生命周期中非常早，通常是在项目完成前3 — 5年</td><td>为项目选择决策提供成本估算</td><td>-25％— +75％</td></tr><tr><td>预算估算</td><td>早，项目完成前 1 — 2年</td><td>将资金拨入预算计划</td><td>-10％— +25％</td></tr><tr><td>最终估算</td><td>项目的后期，在项目完成前不足1年</td><td>为采购提供详情,估算实际成本</td><td>-5％— +10％</td></tr></tbody></table></div><h3 id="成本预算"><a href="#成本预算" class="headerlink" title="成本预算"></a>成本预算</h3><p>成本预算：项目成本预算是给每一项独立工作分配全部费用，以获得度量项目执行的费用基线。</p><p>两个要点：</p><ul><li>把成本估算分配到项目生命期中的每一个活动（或工作包）中。</li><li>建立成本控制基准线（ＢＣＷＳ或ＰＶ）－用来度量项目执行清况。</li></ul><p>成本预算的主要工作：</p><ul><li>确定项目的总预算</li><li>确定项目各项活动的预算</li><li>确定项目各项活动预算的投入时间</li><li>给出项目成本预算的“S”曲线</li></ul><p><strong>成本估算和预算的联系</strong></p><p>运用类比估算、参数模型、自下而上等工具和技术；都是以 WBS为基础的。</p><p><strong>成本估算和预算的区别</strong></p><p>估算成本：对完成项目活动所需资金进行近似估算；估算成本输出是成本估算，这种估算并未得到管理层的批准；成本估算的精确程序以工作包为基础；</p><p>制定预算：汇总所有单个活动或工作包的估算成本，建立一个经批准的成本基准；成本预算将基于工作包的成本估算分配到每项活动及相应时间段；成本预算输出的是成本基准计划即经过批准的成本预算。</p><h3 id="成本控制——挣值分析"><a href="#成本控制——挣值分析" class="headerlink" title="成本控制——挣值分析"></a>成本控制——挣值分析</h3><ol><li><p>挣值分析是项目管理领域中一个特有的、非常有效的成本控制工具。</p></li><li><p>挣值法实际上是一种分析目标实施与目标期望之间差异的方法。故而它又被称为偏差分析法。</p></li><li><p>挣值法通过测量和计算已完成的工作的预算费用和实际费用以及计划工作的预算费用得到计划实施的进度和费用的偏差，达到判断项目预算和进度计划执行情况。 </p></li><li><p>挣值方法是对项目范围、进度和成本进行综合控制的一种有效方法。它对于计划完成的工作、实际挣得的利益、实际花费的成本进行比较，以确定成本和进度是否按计划进行。</p></li><li><p>项目挣值：指已完成作业量的计划成本的中间变量。</p></li><li><p>挣值方法核心要素</p><ul><li>三个关键变量：PV、AC、EV</li><li>两个偏差：CV、SV</li><li>两个绩效指标：CPI、SPI</li></ul></li><li><p>挣值管理基本术语</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210622153612409.png" alt="挣值管理基本术语表" style="zoom:67%;"></p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210622154058038.png" alt="三个基本参数" style="zoom: 50%;"></p></li><li><p>挣值法的三个基本参数：</p><ol><li>计划工作量的预算成本(BCWS) ，即（Budgeted Cost for Work Scheduled) 。BCWS是指计划要求完成的工作量所需的预算工时/费用。<br>BCWS = 计划工作量 * 预算定额          PV</li><li>已完成工作的实际成本(ACWP) ，即（Actual  Cost for Work Performed)。 ACWP是指实际完成的工作量所消耗的工时/费用。      AC </li><li>已完成工作量的预算成本(BCWP) ，即（ Budgeted Cost for Work Performed)。BCWP是指实际完成的工作量按预算定额计算的工时/费用。<br>   BCWP =实际工作量 *预算定额       EV</li></ol></li><li><p>挣值法的四个评价指标</p><ol><li><p>两个偏差</p><ol><li><p>成本偏差(Cost Variance-CV) ：已完成工作的预算成本减去已完成工作的实际成本。CV是指检查期间EV与AC之间的差异，计算公式为：$CV= EV –AC$</p><p>当CV为负值时表示执行效果不佳，即实际消费人工(或费用)超过预算值即超支。反之当CV为正值时表示实际消耗人工(或费用)低于预算值，表示有节余或效率高。</p></li><li><p>进度偏差(Schedule Variance-SV)：已完成工作的预算成本减去计划工作的预算成本。<br>SV是指检查日期EV与PV之间的差异。其计算公式为：$SV= EV - PV $<br>当SV为正值时表示进度提前，SV为负值表示进度延误。</p></li></ol></li><li><p>成本执行指数：已完成工作的预算成本与已完成工作的实际成本的比值</p></li><li><p>两个绩效指标：</p><ol><li>费用绩效指标(Cost Performed Index-CPI)：CPI是指预算费用与实际费用值之比(或工时值之比)：$CPI=EV／AC$<br>当 CPI＞1表示低于预算C；PI＜1表示超出预算；CPI＝1表示实际费用与预算费用吻合</li><li>进度绩效指标(SPI －Schedule Performed Index/SCI)：SPI/SCI是指项目挣值与计划值之比，即 $SPI=EV／PV$<br>当 SPI＞1表示进度提前S；PI＜1表示进度延误S；PI＝1表示实际进度等于计划进度</li></ol></li></ol></li><li><p>| 序号 | 三参数关系                    | 分析                         | 措施                                   |<br>| —— | ——————————————- | —————————————— | ——————————————————— |<br>| 1    | ACWP&gt;BCWS&gt;BCWPSV &lt; 0  CV &lt; 0  | 效率低、进度较慢、投入超前   | 用工作效率高的人员更换工作效率低的人员 |<br>| 2    | BCWP&gt;BCWS&gt;ACWP SV &gt; 0  CV &gt; 0 | 效率高、进度较快、投入延后   | 若偏离不大，维持现状                   |<br>| 3    | BCWP&gt;ACWP&gt;BCWSSV &gt; 0  CV &gt; 0  | 效率较高、进度快、投入超前   | 抽出部分人员，放慢进度                 |<br>| 4    | ACWP&gt;BCWP&gt;BCWSSV &gt; 0  CV &lt; 0  | 效率较低、进度较快、投入超前 | 抽出部分人员，增加少量骨干人员         |<br>| 5    | BCWS&gt;ACWP&gt;BCWPSV &lt; 0  CV &lt; 0  | 效率较低、进度慢、投入延后   | 增加高效人员投入                       |<br>| 6    | BCWS&gt;BCWP&gt;ACWPSV &lt; 0  CV &gt; 0  | 效率较高、进度较慢、投入延后 | 迅速增加人员投入                       |</p></li></ol><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210622155213530.png" alt="例图" style="zoom:50%;"></p><h2 id="项目质量管理"><a href="#项目质量管理" class="headerlink" title="项目质量管理"></a>项目质量管理</h2><h3 id="软件质量"><a href="#软件质量" class="headerlink" title="软件质量"></a>软件质量</h3><ul><li><p>软件质量问题的严重性：软件质量不佳引发的事故已直接伤害到生命和社会安全。</p></li><li><p>软件质量问题的重要性：</p><ul><li>软件已深入到生活之中</li><li>软件越来越事关重大</li><li>人们对软件的期望与日俱增</li><li>软件出错的范围和可能越来越大</li><li>软件出错后没有第二次机会</li><li>合格且主动的进行质量控制的企业和员工太少</li><li>人们对软件的依赖性越来越大</li><li>软件质量问题带来的危害也越来越严重</li><li>软件产品质量正在牵动着社会的命脉</li></ul></li><li><p>质量的传统和新认识：</p><ul><li>传统：质量定义从产品延伸服务和过程时，质量是指产品、服务或过程各自对客户需求的适应性，即满足客户需求的能力。</li><li>新的认识：<ul><li>满意性质量 全面顾客满意</li></ul></li></ul></li><li><p>质量与等级：</p><ul><li>等级：相同功能用途，而技术参数不同的实体进行分类或排序。</li></ul></li><li><p>PMI定义：质量是满足双方一致同意的客户需求。</p></li><li><p>ISO定义：质量是反映实体满足明确和隐含需要的能力的特性总和。</p></li><li><p>质量管理：在质量方面指挥和控制组织的协调活动。</p></li><li><p>软件项目质量管理：是指软件企业为了使其软件产品质量能满足不断更新的市场与用户的质量要求而开展的策划、组织、计划、实施、控制、改进活动的总和。</p></li><li><p>软件质量：是将客户的隐性需求转换为明确需求,并且满足所有明确需求。</p></li><li><p>项目质量管理是指为满足项目质量目标要求所需要的管理过程；包括：质量计划 质量保证 质量控制</p></li><li><p>质量管理发展的四个阶段：</p><ul><li>传统质量管理阶段：以检验为基本内容，方式是严格把关。</li><li>统计质量控制阶段：以数理统计方法与质量管理相结合，通过对过程中影响因素的控制达到控制质量的目的。</li><li>全面质量管理阶段：以“三全为主要特征，即：管理对象是全面的、全过程的、全员的。</li><li>现代质量管理阶段：以顾客满意为中心，重视与企业职工、社会、交易伙伴、股东等顾客以外的利益相关者的关系。重视中长期预测与规划和经营管理层的领导能力。重视人及信息等经营资源，使组织充满自律、学习、速度、柔韧性和创造性。</li></ul><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210622185829346.png" alt="项目质量管理过程" style="zoom:50%;"></p></li><li><p>戴明改进质量管理</p><ul><li>高质量 —&gt; 高生产率，低成本</li><li>PDCA循环：计划、执行、检查、处理</li><li>四个特性：<ul><li>周而复始</li><li>大环带小环</li><li>阶梯式上升</li><li>统计的工具</li></ul></li></ul><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210622190150215.png" alt="PDCA循环图" style="zoom:50%;"></p></li></ul><div class="table-container"><table><thead><tr><th>阶 段</th><th>步 骤</th><th>备 注</th></tr></thead><tbody><tr><td>计划阶段</td><td>1.分析现状，找出问题3.找出造成问题的原因3.找出其中的主要原因4.针对主要原因，制定措施计划表</td><td>本阶段要明确六个问题，简称5W1H:.为何制定此计划？（WHY）.计划的目标是什么？（WHAT）.何处执行此计划？（WHERE）.何时执行此计划？（WHEN）.何人执行此计划？（WHO）.如何执行此计划？（HOW）</td></tr><tr><td>执行阶段</td><td>5.按措施计划执行</td><td></td></tr><tr><td>检查阶段</td><td>6.检查计划执行情况</td><td></td></tr><tr><td>处理阶段</td><td>7.对检查结果座标准化处理8.不能座标准化处理的，转入下一轮循环</td></tr></tbody></table></div><h3 id="质量规划"><a href="#质量规划" class="headerlink" title="质量规划"></a>质量规划</h3><ol><li>项目质量计划是指为确定项目应该达到的质量标准（项目质量的规定指标）和如何达到这些项目质量标准而做的项目质量的计划与安排工作。</li><li>项目质量计划编制方法（工具与技术）<ul><li>成本收益分析法</li><li>项目质量标杆法</li><li>项目质量图表法</li><li>项目实验设计法</li></ul></li></ol><h3 id="质量控制"><a href="#质量控制" class="headerlink" title="质量控制"></a>质量控制</h3><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210622190935964.png" alt="影响项目质量因素的控制"></p><p>质量控制的工具和方法：</p><ul><li><p>排列图：</p><ul><li><p>帕累托图（排列图）是“根据优先次序表达信息的一种图形，能够突出关键因素，以引起必要的关注”</p></li><li><p>步骤：</p><ol><li>将要处置的事，以状况（现象）或原因加以区别</li><li>纵轴可以表示件数，但最好以金额表示</li><li>决定搜集资料的期间，自何时至何时，作为帕拉图资料的依据。期间尽可能定期</li><li>各项目依照事件之大小顺位自左至右排列在横轴上</li><li>绘上柱状图</li><li>连接累计曲线  </li></ol></li><li><p>Pareto 图应用方法</p><ol><li>选择和确定用于分析问题的排列项目</li><li>选择用于分析的度量单位</li><li>选择用于分析的数据的时间周期</li><li>按度量单位的量值，以递减的顺序从左至右在横坐标上列出排列项目、</li><li>在横坐标两端画两个纵坐标</li><li>在每个项目上画长方形，表示该项目的量值</li><li>自左向右累加每一项的量值，画累计频数线</li><li>图形分析</li></ol></li><li><p>Pareto 图的作用</p><ol><li>为决定改善目标而使用</li><li>确认改善效果时使用</li><li>调查不良原因及故障原因时使用</li><li>对整理报告和记录时有帮助</li></ol></li></ul><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210622191351492.png" alt="排列图示例" style="zoom:67%;"></p></li><li><p><code>控制图</code> </p><ul><li><p>用来确认项目过程和结果是否处于受控状态用来确认项目过程和结果是否处于受控状态</p></li><li><p>控制图实施程序：</p><ol><li>定时定量随机抽取样本</li><li>抽取样本做特性的测量</li><li>将结果绘制于控制图上</li><li>判别有无工程异常或偶发性事件</li><li>对偶发性事故或工程异常采取措施<ol><li>找寻原因</li><li>改善对策、应急对策</li><li>防止再发根本对策</li></ol></li></ol><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210622191949334.png" alt="控制图实施程序" style="zoom: 67%;"></p></li></ul><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210622191808877.png" alt="控制图例图" style="zoom:50%;"></p></li><li><p>因果图</p><ul><li>因果图揭示造成问题的多种原因与结果之间的关系<ul><li>一种有创意的方法来揭示问题的原因或其潜在原因</li><li>鼓励组织内部的思考和讨论</li></ul></li></ul><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210622192125715.png" alt="因果图" style="zoom:67%;"></p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210622192213785.png" alt="因果图示例" style="zoom: 67%;"></p></li><li><p>关联图</p><ul><li>用于原因—结果关系分析</li><li>分析复杂因素交织在一起的问题</li><li>抓住关键问题</li><li>便于成员取得一致意见</li></ul><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210622192555700.png" alt="关联图示例"></p></li><li><p><code>散布图</code> </p><ul><li>散点图（Scatter Plot or Scatter Chart)，也叫散布图，顾名思义就是由一些散乱的点组成的图表，这些点在哪个位置，是由其X值和Y值确定的。所以也叫做XY散点图。它将所有的数据以点的形式展现在直角坐标系上，以显示变量之间的相互影响程度，点的位置由变量的数值决定。</li><li>可以显示两个变量之间是否有关系。一条斜线上的数据点距离越近，两个变量之间的相关性就越密切。</li></ul><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210622192710413.png" alt="散点图示例"></p></li><li><p><code>6西格玛（$6 \sigma$）</code></p><ul><li><p>理解$6 \sigma$</p><ul><li>6σ是一种哲理，它运用结构化的，系统化的方法来表达几乎零缺陷的优异营运结果。</li><li>6σ是管理系统，可将对公司影响最大的问题和机会，交给最优秀的人，通过专案团队的运作方式获得突破性的成果。当然，管理层要给予适时的支援，同时允诺协助其排除障碍。</li><li>6σ是一个积极的目标，从长期目标而言，每百万产品或服务或工作，只有3.4个瑕疵，当然，短期要追求零缺陷的完美表现。</li><li>6σ是一系列的工具组，在不同的阶段有不同的工具可应用（关于工具的使用，有很多软件可以辅助）。</li><li>6σ是以顾客为尊，是一种聚焦于顾客的策略性工具，不是倾听顾客的声音，满足顾客的要求。还要让顾客获到惊喜。</li></ul></li><li><p>三个目的</p><ul><li><p>为了彻底解决现有问题</p><p>企业现有的服务或产品质量水准不高，成本不具竞争力，周期较长，流程效能或效率不佳，缺乏弹性与应变能力，个人或整体生产力未达理想等。这部分约占总体的70%左右。</p></li><li><p>希望通过6σ系统能有效地执行企业策略，以进一步提升获利能力，降低营运风险，快速回应市场与客户需求，增强产品或服务之附加价值，提升市场占有率，以及强化公司整体竞争力与顾客满意度。这部分约占总体的20%左右。</p></li><li><p>由6σ系统成功以改变企业变化，包括建立共通语言（面对问题的思考逻辑与解决式）与世界级企业同步，建立愿景共识，增强员工同心力；构建企业知识库，提升顾客忠诚度，追求企业公民的社会价值及典范。</p></li></ul></li><li><p>$6 \sigma$核心方法论——DMAIC</p><p>6σ管理着重<code>从流程的角度来看待企业绩效和改进绩效</code> ，当然，对流程的描述和管理就成为改进提高的基础。建立企业的核心流程及鉴别，顾客是企业改进的第一步。</p><p>所有的流程系统都是5部分组成的：供应商、输入、加工、输出、顾客。</p></li></ul></li><li><p>测试：</p><ul><li>广义上：软件测试是对软件需求分析、设计说明和编码进行复审等的软件质量保证工作。</li><li>狭义上：软件测试是根据软件开发各个阶段的规格说明和程序的内部结构而精心设计的一些测试用例，并利用这些测试用例去运行程序，发现错误。</li><li>根本目的：一是发现错误；二是通过测试的错误来改进软件开发过程中存在的缺陷。</li><li>测试原则</li><li>软件测试应尽早执行。<ul><li>开发和测试小组分立。</li><li>测试用例应由测试输入数据和预期输出结果这两部分组成，要兼顾有效输入与无效输入。</li><li>在对程序修改之后，要进行回归测试。</li><li>妥善保存测试计划、测试用例、出错统计和最终分析报告，为维护提供方便。</li></ul></li></ul></li></ul><h3 id="提升项目质量的方法"><a href="#提升项目质量的方法" class="headerlink" title="提升项目质量的方法"></a>提升项目质量的方法</h3><p>IT项目质量提高空间非常大，包括强有力的领导、提供好的工作环境、选用具体的规范、标准、模型都是提高项目质量的有效方法。  </p><h2 id="项目人力资源管理"><a href="#项目人力资源管理" class="headerlink" title="项目人力资源管理"></a>项目人力资源管理</h2><ul><li><p>人力资源的含义：人类可用于生产产品或提供各种服务的活力、技能、知识和可提供的商誉价值。</p></li><li><p>人力资源具有的特征：</p><ul><li>可再生的生物性资源：它以人身为天然载体，是一种“活”的资源，并与人的自然生理特征相联系。</li><li>居于主导地位的动能性资源：人类不同于自然界其他生物之处在于人具有目的性、主观能动性和社会意识。</li><li>具有时效性的资源：人力资源的形成、开发、使用都具有时间方面的制约。</li></ul></li><li><p>项目人力资源管理可以定义为根据项目目标，采用科学的方法，对项目组织成员进行合理的选拔、培训、考核、激励，使其融合到组织之中，并充分发挥其潜能，从而保证高效实现项目目标的过程。</p></li><li><p>项目人力资源管理是通过不断的获得人力资源，把得到的人力整合到项目中并融为一体，保持和激励他们对项目的忠诚和积极性，控制他们的工作绩效并作出相应的调整，尽量发挥他们的潜能，以支持项目目标的实现，这样的一些活动、职能、责任和过程叫项目人力资源管理。</p></li><li><p>管理员工的关键所在：</p><ul><li><p>激励理论</p><ul><li><p>内在动机：驱使人们为满足自身的乐趣而参与某项活动。</p></li><li><p>外在动机：驱使人们为获得利益或者避免惩罚而参加一些活动。</p></li><li><p>马斯洛的需求层次理论：</p><ul><li>人类的行为是由一系列的需求引起或者驱动的。</li><li>认为最独特的性质是：爱、自尊、归属感、自我表现以及创造力。这些独一无二的性质使人们做出独立的选择，从而使他们能自己掌握自己的命运。</li></ul><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210622204036446.png" alt="马斯洛的需求层次" style="zoom:67%;"></p></li><li><p>赫茨伯格的双因素理论：</p><ul><li>在考虑工作激励时区别了激励因素和保健因素，把影响工作满意的因素称为激励因素，把导致不满的因素称为保健因素。</li><li>他发现人们工作的主要激励因素来自于个人成绩表现以及由此获得的认可度。赫茨伯格总结出激励因素包括工作成就、认可度、工作本身、责任、晋升和发展。</li></ul><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210622204234952.png" alt="赫茨伯格的双因素理论" style="zoom: 67%;"></p></li></ul></li><li><p>权利理论</p><ul><li>权力的5种主要类型：强制权力、合法权力、专家权力、奖励权力、参照权力。</li></ul></li><li><p>习惯</p></li></ul></li></ul><h3 id="项目人力资源管理过程"><a href="#项目人力资源管理过程" class="headerlink" title="项目人力资源管理过程"></a>项目人力资源管理过程</h3><ul><li>人力资源规划<ul><li>识别和记录项目角色、责任和汇报关系。</li><li>关键输出是：项目的角色和责任、项目的组织结构以及人员配置管理计划。</li></ul></li><li>组建项目团队<ul><li>分派好项目所需要的各种人员，让其为项目工作。</li><li>关键输出是：项目人员的分派、了解资源的可用性信息和人员配置管理计划的更新。</li></ul></li><li>建设项目团队<ul><li>通过培训个人与团队的技能来改善项目绩效。</li><li>输出是：评估团队绩效。</li></ul></li><li>管理项目团队<ul><li>通过追踪团队成员的表现、激励团队成员、及时提供反馈、解决问题和矛盾、协调变化等来提高项目绩效。</li><li>输出是：变更申请、建议的修正和预防措施、组织过程资产和项目管理计划的更新。</li></ul></li></ul><h3 id="人力资源规划"><a href="#人力资源规划" class="headerlink" title="人力资源规划"></a>人力资源规划</h3><ul><li>人力资源规划包括识别和记录项目角色、责任和汇报关系。产生项目的组织结构图和人员配置管理计划，以及在责任分配矩阵中明确各人的角色和责任。</li><li>责任分配矩阵：用矩阵表格形式表示工作分解结构中的细目，以及组织分解结构的工作绩效对应的个人责任。</li></ul><h3 id="组件项目团队"><a href="#组件项目团队" class="headerlink" title="组件项目团队"></a>组件项目团队</h3><ul><li>主要途径：<ul><li>人员预先指派：项目竞标时，已保证部分特定人员会投入项目；内部项目发起时，项目章程已明确部分成员。</li><li>谈判：将所需成员从原来的工作岗位抽调到项目中，需要项目经理同职能经理谈判，同其它项目经理谈判。</li><li>虚拟团队：不同于集中办公的方式，是地理位置离散、组织边界宽泛。</li></ul></li><li>项目经理有两种方法来最有效地使用项目人员： <ul><li>资源负荷：是指在特定时段现有进度计划所需的个体资源的数量。</li><li>资源平衡：是一种用来解决资源冲突的工具(主要通过改变进度，超负荷-延，否则-加快进度)，其主要目的是更合理地分配使用的资源。</li></ul></li></ul><h3 id="开发项目团队"><a href="#开发项目团队" class="headerlink" title="开发项目团队"></a>开发项目团队</h3><ul><li><p>定义：层次合理、分工明确、任务清晰、责任到位，能将有限资源最有效的整合的机构—团队。 </p></li><li><p>目标：团队开发的主要目标就是帮助人们更有效地一起工作来提高项目绩效。</p></li><li><p>团队发展五个阶段：</p><ul><li><p>形成阶段：团队酝酿，形成测试。 测试的目的是为了辨识团队的人际边界以及任务边界。 通过测试，建立起团队成员的相互关系、团队成员与团队领导之间的关系，以及各项团队标准等。团队成员行为具有相当大的独立性。  </p><p>指导性领导</p></li><li><p>震荡阶段：形成各种观念，激烈竞争、碰撞的局面。团队获取团队发展的信心，但是存在人际冲突、分化的问题。团队成员面对其他成员的观点、见解，更想要展现个人性格特征。 对于团队目标、期望、角色以及责任的不满和挫折感被表露出来。</p><p>影响性领导</p></li><li><p>规范阶段：规则，价值，行为，方法，工具均已建立。团队效能提高，团队开始形成自己的身份识别。团队成员调适自己的行为，以使得团队发展更加自然、流畅。 有意识地解决问题，实现组织和谐。 动机水平增加。团队领导允许团队有更大的自治性。 </p><p>参与式领导。</p></li><li><p>项目成熟阶段： 人际结构成为执行任务活动的工具， 团队角色更为灵活和功能化，团队能量积聚于一体。项目团队运作如一个整体。 工作顺利、高效完成，没有任何冲突，不需要外部监督。团队成员对于任务层面的工作职责有清晰的理解。 没有监督，自治，即便在没有监督的情况下自己也能做出决策。 随处可见“我能做”的积极工作态度。 互助协作。<br>项目领导让团队自己执行必要的决策。 委任式领导。</p></li><li><p>项目解散阶段：任务完成，团队解散。</p></li></ul></li><li><p>建设团队的工具和方法</p><ul><li>团队建设活动</li><li>一般管理技术</li><li>绩效考评与奖励系统</li><li>人员配置</li><li>培训</li></ul></li></ul><h3 id="管理项目团队"><a href="#管理项目团队" class="headerlink" title="管理项目团队"></a>管理项目团队</h3><ul><li>管理项目团队的工具和方法：<ul><li>观察和交谈</li><li>项目绩效评价</li><li>冲突管理</li><li>问题日志</li></ul></li><li>项目冲突解决方法<ul><li>回避或撤出</li><li>竞争或逼迫</li><li>缓和或调停</li><li>妥协</li><li>正视</li></ul></li></ul><h2 id="项目沟通管理"><a href="#项目沟通管理" class="headerlink" title="项目沟通管理"></a>项目沟通管理</h2><h3 id="项目沟通管理的重要性"><a href="#项目沟通管理的重要性" class="headerlink" title="项目沟通管理的重要性"></a>项目沟通管理的重要性</h3><ul><li>项目成功的三个主要因素<ul><li>用户参与</li><li>主管层的支持</li><li>需求的清晰表述</li></ul></li><li>项目沟通管理的目标：及时而适当地创建、收集、发送、储存和处理项目的信息。</li></ul><h3 id="项目沟通管理的过程"><a href="#项目沟通管理的过程" class="headerlink" title="项目沟通管理的过程"></a>项目沟通管理的过程</h3><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210622210326761.png" alt="项目沟通管理的过程" style="zoom:67%;"></p><h3 id="沟通计划"><a href="#沟通计划" class="headerlink" title="沟通计划"></a>沟通计划</h3><p>内容</p><ol><li>描述信息收集和文件归档的结构。 </li><li>描述什么信息送给谁、何时送、如何送。</li><li>传送重要项目信息的格式。 </li><li>用于创建信息的日程表。 </li><li>获得信息的方法。</li><li>更新沟通管理计划的方法。</li><li>项目干系人沟通分析。</li></ol><h3 id="信息发布"><a href="#信息发布" class="headerlink" title="信息发布"></a>信息发布</h3><p><code>沟通复杂性的确定</code>：</p><ul><li>人数：<img src="https://gitee.com/sehowyoung/images/raw/master/image-20210622210624261.png" alt="人员数目对沟通渠道的影响 " style="zoom:67%;"></li><li>公式：<ul><li>沟通渠道数目计算公式：$S=\frac {n \times(n-1)} {2}$<ul><li>S：沟通渠道数目</li><li>n：参加沟通的人员个数</li></ul></li></ul></li></ul><h3 id="绩效报告"><a href="#绩效报告" class="headerlink" title="绩效报告"></a>绩效报告</h3><ul><li>作用：绩效报告使项目干系人知晓为了达到项目的目标，是如何使用资源的，这些资源的状况和对项目的贡献。</li><li>内容：项目计划和工作成果是绩效报告输入的重要内容，绩效报告的主要输出包括<code>状态报告、进度报告、项目预测和变更请求</code>。<ul><li>状态报告：项目在某一特定时间点上所处的位置。</li><li>进展报告：项目组在某一特定期间所完成的工作。</li><li>项目预测：预测项目未来的状态和进度。</li><li>变更请求：项目变更的原因，对项目目标和资源的影响，采取的措施。 </li></ul></li></ul><h3 id="管理收尾"><a href="#管理收尾" class="headerlink" title="管理收尾"></a>管理收尾</h3><p>管理收尾的主要输出是<code>项目档案、正式接受和取得的教训</code>。</p><ul><li>项目档案包括一套整理好的项目记录，提供了一个项目准确的历史。</li><li>正式接受是项目发起人或客户签发的表明他们接受项目产品的文件。</li><li>取得的教训是项目经理和他们的项目组成员经过思考写下的经验总结。</li></ul><h3 id="改善沟通的建议"><a href="#改善沟通的建议" class="headerlink" title="改善沟通的建议"></a>改善沟通的建议</h3><ol><li>利用沟通技能解决冲突——沟通调整 <ol><li>面对：直接面对冲突，允许受到影响的各方一起沟通，以消除他们之间的分歧。</li><li>妥协：各方讨价还价、使冲突各方都能满意，达到双赢/多赢。</li><li>圆滑：项目经理不再强调或避免分歧的领域，强调一致的领域。</li><li>强制：采用非输即赢的方法来解决冲突。</li><li>撤退：从一个实际的或可能的不同意见中撤退或让步。</li></ol></li><li>学习——发展更好的沟通技能 </li><li>召开有效的会议</li><li>使用项目沟通模板</li><li>建立沟通基础结构</li><li>利用软件辅助沟通</li></ol><h2 id="项目风险管理"><a href="#项目风险管理" class="headerlink" title="项目风险管理"></a>项目风险管理</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li>风险:是可能给项目的成功带来威胁或损害的可能性。</li><li>PMI的定义：项目风险是一种不确定的事件或条件，一旦发生，将对项目目标产生某种正面或负面影响。</li><li>项目风险管理是对项目风险进行识别、评估和应对的系统的过程。它包括把对于项目目标而言正面事件的概率和影响结果最大化和把负面事件的概率和影响最小化。</li><li>项目风险管理的特点：<ul><li>活动:项目风险管理是为减轻潜在的不利事件对项目的影响而采取的一项活动。</li><li>成本：风险管理是一种投资，需要成本。</li><li>成本和收益：在任何情况下，项目风险管理的成本不应超过项目潜在的收益。</li><li>平衡：需要努力在项目的各个方面寻找风险和机会之间的平衡。</li><li>风险管理是科学与艺术的结合体 </li></ul></li><li>目标：<ul><li>项目风险管理通过<code>识别、分析和应对</code>整个项目生命周期中的<code>风险</code>来最大程度地满足项目目标。</li><li>作为在项目管理中常被忽视的一个方面，其对项目的<code>最终成功起到极大的促进作用</code>。</li><li>对项目选择、项目范围的制定、制定现实可行的进度和成本估计都有<code>积极作用</code>。</li><li>可以帮助利益相关者更好理解项目的性质，让团队成员参与<code>辨识优势和劣势</code>，并有助于把其他项目管理知识结合到一起。 </li></ul></li><li>风险承受度<ul><li>风险承受度:是从潜在回报中得到满足或快乐的程度。</li><li>表现形式：一些组织或个人对风险有一种中性的承受度，一些对风险很厌恶，而另一些则追求风险。 </li><li>风险效用或者风险容忍度：指在潜在的权衡中得到满足或者愉悦的程度。</li></ul></li></ul><h3 id="项目风险管理的过程"><a href="#项目风险管理的过程" class="headerlink" title="项目风险管理的过程"></a>项目风险管理的过程</h3><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210622212237566.png" alt="项目风险管理过程" style="zoom: 67%;"></p><p>四个应对风险的基本措施是：</p><ul><li>规避：根除某一具体的威胁或风险。</li><li>接受：如果风险发生，接受其带来的后果。</li><li>减轻：将风险结果用责任转移给第三方。</li><li>转移：通过减少风险事件发生的概率来减轻风险事件的影响。  </li></ul><h2 id="项目采购管理"><a href="#项目采购管理" class="headerlink" title="项目采购管理"></a>项目采购管理</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><ul><li><p>项目采购：通过减少风险事件发生的概率来减轻风险事件的影响。  </p></li><li><p>项目采购管理：是对整个项目采购活动所进行的计划、组织、指挥、协调、控制等一系列活动，是一项管理活动。</p></li><li><p>项目采购特点：目标的唯一性，临时的一次性，逐渐完善的周期性</p></li><li><p>项目采购管理的重要性</p><ul><li><p>确保采购经济有效。（成本）</p></li><li><p>有助于掌握市场变化趋势。 </p></li><li><p>保证项目按计划实施。 </p></li><li><p>从制度上最大限度地防止腐败现象的发生。 </p></li></ul></li><li><p>项目采购管理目标：是以最低的成本及时地为项目提供满足其需要的物料、工程和服务。—T、Q、C</p></li></ul><h3 id="项目采购管理的主要过程"><a href="#项目采购管理的主要过程" class="headerlink" title="项目采购管理的主要过程"></a>项目采购管理的主要过程</h3><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210622212836651.png" alt="项目采购管理的主要过程" style="zoom:67%;"></p><h3 id="工具和技术"><a href="#工具和技术" class="headerlink" title="工具和技术"></a>工具和技术</h3><ol><li>自制或外购分析（成本平衡点分析法）</li><li>短期租赁或长期租赁权衡</li><li>专家判断：聘请一些有经验的采购专家作为顾问或邀请他们直接参加采购过程。</li><li>合同类型权衡<ol><li>固定价合同或固定总价合同</li><li>成本补偿合同</li><li>单价合同</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 资料总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSU </tag>
            
            <tag> 软件项目组织管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在gitee和GitHub中查看原始数据</title>
      <link href="/posts/30410.html"/>
      <url>/posts/30410.html</url>
      
        <content type="html"><![CDATA[<h1 id="在gitee和GitHub中查看原始数据"><a href="#在gitee和GitHub中查看原始数据" class="headerlink" title="在gitee和GitHub中查看原始数据"></a>在gitee和GitHub中查看原始数据</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>总是在别人分享的链接中看到以“raw.githubusercontent.com”为域名，便想了解一下，本文将介绍一下在gitee和GitHub中查看原始数据。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><code>raw.githubusercontent.com</code>域用于提供存储在GitHub存储库中的文件的未处理版本。如果您浏览到GitHub上的文件，然后单击Raw链接，那么您将到达。</p><h2 id="GitHub中查看"><a href="#GitHub中查看" class="headerlink" title="GitHub中查看"></a>GitHub中查看</h2><p>在<a href="github.com">GitHub</a>的官网中随便找一个仓库，随便打开里面的一个文件，我们会发现在代码模块上面有一个<code>Row</code>按钮（如图一），点击按钮之后就可以在网页中直接查看原始数据（如图二）。</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210615142224706.png" alt="图一"></p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210615142436770.png" alt="图二"></p><p>我们仔细观察一下这两个网页的URL：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># github文件https://github.com/sehowyoung/sehowyoung.github.io/blob/master/index.html# 原始数据文件https://raw.githubusercontent.com/sehowyoung/sehowyoung.github.io/master/index.html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以发现原始数据文件和GitHub文件的差异就在：</p><ul><li>域名</li><li><code>/blob/</code></li></ul><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>要在通常的github界面中查看<code>raw.githubusercontent.com/${username}/${repo-name}/${branch-name}/${path}</code>的内容：您将<code>raw.githubusercontent.com</code>替换为普通的<code>github.com</code>，然后在仓库名称和分支名称之间插入<code>blob/</code>即可。</p><p>在这种情况下，分支名称为<code>master</code>(这是一个非常常见的分支名称)，因此您将<code>/master/</code>替换为<code>/blob/master/</code>即可。</p><p>相反，如果你知道一个GitHub文件的链接，想直接查看或直接引用，将<code>github.com</code>换成<code>raw.githubusercontent.com</code>，同时删除<code>blob/</code>即可直接查看。</p><h2 id="gitee中查看原始数据"><a href="#gitee中查看原始数据" class="headerlink" title="gitee中查看原始数据"></a>gitee中查看原始数据</h2><p>在了解完GitHub查看原始数据之后，我总是在想gitee会不会有类似的操作，果不其然。</p><p>同样，打开gitee仓库的任意一个文件（如图二），发现就有<code>原始数据</code>这个按钮，直接点击就可以查看原始数据（如图四）。</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210615143445564.png" alt="图三"></p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210615143613405.png" alt="图四"></p><p>我们来分析一下二者的URL：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># gitee文件https://gitee.com/sehowyoung/Sort/blob/main/java/src/sort/Insertion.java# 原始数据文件https://gitee.com/sehowyoung/Sort/raw/main/java/src/sort/Insertion.java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这个想必GitHub就简单许多了，只是把<code>blob</code>换成<code>raw</code>即可。通过这样的切换，我们就可以直接查看、引用文件数据。</p><h3 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h3><p>要在通常的gitee界面中查看<code>gitee.com/${username}/${repo-name}/${branch-name}/${path}</code>的内容：您需要在仓库名称和分支名称之间插入<code>blob/</code>即可。</p><p>在这种情况下，分支名称为<code>master</code>(这是一个非常常见的分支名称)，因此您将<code>/master/</code>替换为<code>/blob/master/</code>即可。</p><p>相反，如果你知道一个gitee文件的链接，想直接查看或直接引用，删除<code>blob/</code>即可直接查看。</p>]]></content>
      
      
      <categories>
          
          <category> 常识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> 原始数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪心算法学习笔记</title>
      <link href="/posts/32604.html"/>
      <url>/posts/32604.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>贪心法：遵循某种规律，不断<strong>贪心</strong>的选取当前<strong>最优</strong>策略的算法设计方法。</p></blockquote><h2 id="引例"><a href="#引例" class="headerlink" title="引例"></a>引例</h2><p>有1元、5元、10元、20元、100元、200元的钞票无穷多张。现使用这些钞票支付ⅹ元，<strong>最少</strong>需要多少张？<br>例如,X=628<br>最佳支付方法：<br>3张200块的,1张20块的,1张5块的,3张1块的<br>共需要3+1+1+3=8张<br>直觉告诉我们：<strong>尽可能多</strong>的使用<strong>面值较大</strong>的钞票</p><p>那么为何这么做一定是对的?<br>面额为1元、5元、10元、20元、100元、200元，任意面额是比自己小的面额的倍数关系，所以当使用一张较大面额钞票时，若用较小面额钞票替换，一定需要更多的其他面额的钞票。<br>例如：<br>5=1+1+1+1+1<br>10=5+5<br>20=10+10<br>100=20+20+20+20+20<br>200=100+100<br>故,<strong>当前最优解</strong>即为<strong>全局最优解</strong>,贪心成立</p><blockquote><p>思考：如果增加7元面额，贪心还成立吗?</p></blockquote><h2 id="例1：分发饼干"><a href="#例1：分发饼干" class="headerlink" title="例1：分发饼干"></a>例1：分发饼干</h2><blockquote><p>来源：<a href="https://leetcode-cn.com/problems/assign-cookies/">LeetCode 455.分发饼干</a></p><p>题目描述：</p><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p><p>对每个孩子 <code>i</code>，都有一个胃口值 <code>g[i]</code><sub>，</sub>这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 <code>j</code>，都有一个尺寸 <code>s[j]</code><sub> </sub>。如果 <code>s[j] &gt;= g[i]</code>，我们可以将这个饼干 <code>j</code> 分配给孩子 <code>i</code> ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><p><strong>示例 1:</strong></p><pre class="line-numbers language-none"><code class="language-none">输入: g = [1,2,3], s = [1,1]输出: 1解释:你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。所以你应该输出1。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例2：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入: g = [1,2], s = [1,2,3]输出: 2解释:你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。你拥有的饼干数量和尺寸都足以让所有孩子满足。所以你应该输出2.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提示：</strong></p><ul><li>1 &lt;= g.length &lt;= 3 * 10^4^</li><li>0 &lt;= s.length &lt;= 3 * 10^4^</li><li>1 &lt;= g[i], s[j] &lt;= 2^31^ - 1</li></ul></blockquote><p><strong>核心目标：</strong>让更多孩子得到满足,有如下规律:</p><ol><li>某个饼干如果不能满足某个孩子,则该饼干也一定不能满足需求因子更大的孩子。<br>如：饼干1(s=1)不能满足孩子1(g=2)，则不能满足孩子2、孩子3、…、孩子n<pre><code>   饼干2(s=3)不能满足孩子2(g=5)，则不能满足孩子3、孩子4、...、孩子n</code></pre></li><li>某个孩子可以用更小的饼干满足，则没必要用更大饼干满足，因为可以保留更大的饼干满足需求因子更大的孩子。(贪心!)<br>如：孩子1(g=2)，可以被饼干2(s=3)满足，则没必要用饼干3、饼干4、饼干5满足；<pre><code>   孩子2(g=5)，可以被饼干3(s=6)满足，则没必要用饼干4、饼干5满足</code></pre></li><li>孩子的需求因子更小则其更容易被满足，故优先从需求因子小的孩子尝试，可以得到确的结果。因为我们追求更多的孩子被满足，所以用一个饼干满足需求因子较小的或较大的孩子<br>都是一样的)。</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Arrays;public class Solution {    public int findContentChildren(int[] g, int[] s) {        Arrays.sort(g);        Arrays.sort(s);        int index_g = 0;        int index_s = 0;        while ((index_g &lt; g.length) &amp;&amp; (index_s &lt; s.length)){            if (s[index_s] &gt;= g[index_g]){                index_g++;            }            index_s++;        }        return index_g;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="例2：摆动序列"><a href="#例2：摆动序列" class="headerlink" title="例2：摆动序列"></a>例2：摆动序列</h2><blockquote><p>来源：<a href="https://leetcode-cn.com/problems/wiggle-subsequence/">376. 摆动序列</a></p><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 <strong>摆动序列 。</strong>第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。</p><ul><li>例如， <code>[1, 7, 4, 9, 2, 5]</code> 是一个 <strong>摆动序列</strong> ，因为差值 <code>(6, -3, 5, -7, 3)</code> 是正负交替出现的。</li><li>相反，<code>[1, 4, 7, 2, 5]</code> 和 <code>[1, 7, 4, 5, 5]</code> 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</li></ul><p><strong>子序列</strong> 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。</p><p>给你一个整数数组 <code>nums</code> ，返回 <code>nums</code> 中作为 <strong>摆动序列</strong> 的 <strong>最长子序列的长度</strong> 。</p><p><strong>示例 1：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：nums = [1,7,4,9,2,5]输出：6解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>示例 2：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：nums = [1,17,5,10,13,15,10,5,16,8]输出：7解释：这个序列包含几个长度为 7 摆动序列。其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>示例 3：</strong></p><pre class="line-numbers language-none"><code class="language-none">输入：nums = [1,2,3,4,5,6,7,8,9]输出：2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>0 &lt;= nums[i] &lt;= 1000</code></li></ul></blockquote><p><strong>贪心规律：</strong></p><p>当序列有一段连续的递增(或递减)时，为形成摇摆子序列，我们只需要保留这段连续的递增(或递减)的首尾元素，这样更可能使得尾部的后一个元素成为摇摆子序列的下一个元素。</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210613123353118.png" alt="image-20210613123353118"></p><p><strong>算法设计：</strong></p><p>设置最长摇摆子序列长度为 max length，从头至尾扫描原始序列。这个过程中设置三种状态，即起始、上升、下降；不同的状态中,根据当前数字与前一个数字的比较结果进行累加 max length计算或者状态切换。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git学习笔记</title>
      <link href="/posts/14696.html"/>
      <url>/posts/14696.html</url>
      
        <content type="html"><![CDATA[<h1 id="Git学习笔记"><a href="#Git学习笔记" class="headerlink" title="Git学习笔记"></a>Git学习笔记</h1><h2 id="Git概述"><a href="#Git概述" class="headerlink" title="Git概述"></a>Git概述</h2><p>git官网：<a href="https://git-scm.com/">https://git-scm.com/</a></p><blockquote><p>Git 是一个<a href="https://git-scm.com/about/free-and-open-source">免费的开源</a> 分布式版本控制系统，旨在快速高效地处理从小到大的所有项目。</p><p>Git<a href="https://git-scm.com/doc">易于学习</a>， <a href="https://git-scm.com/about/small-and-fast">占用空间小，性能极快</a>。它的性能优于 Subversion、CVS、Perforce 和 ClearCase 等 SCM 工具，具有<a href="https://git-scm.com/about/branching-and-merging">便宜的本地分支</a>、方便的<a href="https://git-scm.com/about/staging-area">暂存区</a>和 <a href="https://git-scm.com/about/distributed">多个工作流等功能</a>。</p></blockquote><h3 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h3><ul><li>版本控制是一种记录文件内容变化，一边将来查阅特定版本修订情况的系统。</li><li>版本控制其实最重要的是可以记录文件修改历史记录，从而让用户能够查看历史版本，方便版本切换。</li></ul><h3 id="版本控制工具"><a href="#版本控制工具" class="headerlink" title="版本控制工具"></a>版本控制工具</h3><h4 id="分布式版本控制工具"><a href="#分布式版本控制工具" class="headerlink" title="分布式版本控制工具"></a>分布式版本控制工具</h4><ul><li>像Git这种分布式版本控制工具，客户端提取的不是最新版本的文件快照，而是把代码仓库完整地镜像下来(本地库)。这样任何一处协同工作用的文件发生故障，事后都可以用其他客户端的本地仓库进行恢复。因为每个客户端的每一次文件提取操作，实际上都是一次对整个文件仓库的完整备份。</li><li>分布式的版本控制系统出现之后解决了集中式版本控制系统的缺陷：<ul><li>服务器断网的情况下也可以进行开发(因为版本控制是在本地进行的)</li><li>每个客户端保存的也都是整个完整的项目(包含历史记录，更加安全)</li></ul></li></ul><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210610082741008.png" alt="分布式版本控制架构图"></p><h4 id="集中式版本控制工具"><a href="#集中式版本控制工具" class="headerlink" title="集中式版本控制工具"></a>集中式版本控制工具</h4><ul><li>集中化的版本控制系统诸如CVS、SWN等,都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。多年以来，这已成为版本控制系统的标准做法。把集中管理的服务器看作是图书馆，当你要修改一本书时，要先从图书馆借出来，然后修改完成之后在还回去。</li><li>这种做法带来了许多好处，每个人都可以在一定程度上看到项目中的其他人正在做些什么。而管理员也可以轻松掌控每个开发者的权限,并且管理一个集中化的版本控制系统，要远比在各个客户端上维护本地数据库来得轻松容易。</li><li>事分两面，有好有坏。这么做显而易见的缺点是中央服务器的单点故障。如果服务器宕机一小时，那么在这一小时内，谁都无法提交更新,也就无法协同工作。</li></ul><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210610082041030.png" alt="集中式版本控制架构图"></p><h3 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h3><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210610085134741.png" alt="Git工作机制"></p><p>在工作区和暂存区可以进行删除，在本地库形成历史版本后将无法删除。</p><h3 id="代码托管中心"><a href="#代码托管中心" class="headerlink" title="代码托管中心"></a>代码托管中心</h3><p>代码托管中心是基于网络服务器的远程代码仓库，一般称为远程库</p><h2 id="Git常用命令"><a href="#Git常用命令" class="headerlink" title="Git常用命令"></a>Git常用命令</h2><p>Git手册：<a href="https://git-scm.com/book/zh/v2">https://git-scm.com/book/zh/v2</a></p><p>Git常用命令及其方法大全：<a href="https://blog.csdn.net/web_csdn_share/article/details/79243308">https://blog.csdn.net/web_csdn_share/article/details/79243308</a></p><div class="table-container"><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>git init</td><td>初始化本地仓库</td></tr><tr><td>git add [file1] [file2]</td><td>添加到暂存区</td></tr><tr><td>git status</td><td>查看本地库状态</td></tr><tr><td>git commi -m “[log]”[name]</td><td>提交到本地库</td></tr><tr><td>git reflog</td><td>查看历史记录</td></tr><tr><td>git reset --hard 版本号</td><td>版本穿梭</td></tr><tr><td>git clone url</td><td>从url克隆项目</td></tr></tbody></table></div><h2 id="Git分支"><a href="#Git分支" class="headerlink" title="Git分支"></a>Git分支</h2><p>在版本控制过程中，同时推进多个任务，为每个任务，我们就可以创建每个任务的单独分支。使用分支意味着程序员可以把自己的工作从开发主线上分离开来，开发自己分支的时候，不会影响主线分支运行。对于初学者而言，分支可以简单理解为副本，一个分支就是一个单独的副本。(分支底层其实也是指针的引用)</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210610115238291.png" alt="分支示例图"></p><p>分支的好处：</p><ul><li>同时并行推进多个功能开发，提高开发效率</li><li>各个分支在开发过程中，如果某一个分支开发失败，不会对其他分支有任何影响。失败<br>的分支删除重新开始即可。  </li></ul><h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">git branch [name]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">git branch -v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">git checkout [name]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 把指定分支合并到当前分支上git merge [name]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>合并分支可能会产生冲突：</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210610115652425.png" alt="冲突"></p><p><strong>冲突产生的原因</strong>：<br>合并分支时，两个分支在同一个文件的同一个位置有两套完全不同的修改。 Git 无法替我们决定使用哪一个。所以必须人为决定新代码内容  。</p><p><strong>解决冲突</strong>：</p><ol><li><p>编辑有冲突的文件，删除特殊符号，决定要使用的内容</p><p>特殊符号：</p><p><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;HEAD</code> 当前分支的代码 <code>==========</code> 合并过来的代码 <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;XXXXX</code></p></li><li><p>添加到暂存区</p></li><li><p>执行提交（<font color="red">注意：此时使用<code>git commit</code>命令时不能带文件名</font>）</p></li></ol><h3 id="创建和切换分支图解"><a href="#创建和切换分支图解" class="headerlink" title="创建和切换分支图解"></a>创建和切换分支图解</h3><p> <img src="https://gitee.com/sehowyoung/images/raw/master/image-20210610125544172.png" alt="创建和切换分支图解"></p><ul><li>master、 hotfix 其实都是指向具体版本记录的指针。当前所在的分支，其实是由<code>head</code>决定的。所以创建分支的本质就是多创建一个指针。</li><li><code>head</code>如果指向 master，那么我们现在就在 master 分支上。<br><code>head</code> 如果执行 hotfix，那么我们现在就在 hotfix 分支上。  </li><li>所以切换分支的本质就是移动head指针</li></ul><h2 id="Git团队协作机制"><a href="#Git团队协作机制" class="headerlink" title="Git团队协作机制"></a>Git团队协作机制</h2><h3 id="团队内协作"><a href="#团队内协作" class="headerlink" title="团队内协作"></a>团队内协作</h3><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210610125755981.png" alt="团队内协作"></p><h3 id="跨团队协作"><a href="#跨团队协作" class="headerlink" title="跨团队协作"></a>跨团队协作</h3><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210610125854069.png" alt="跨团队协作"></p><h2 id="GitHub操作"><a href="#GitHub操作" class="headerlink" title="GitHub操作"></a>GitHub操作</h2><h3 id="远程仓库操作"><a href="#远程仓库操作" class="headerlink" title="远程仓库操作"></a>远程仓库操作</h3><div class="table-container"><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>git remote -v</td><td>查看当前所有远程地址别名</td></tr><tr><td>git remote add 别名 远程地址</td><td>起别名</td></tr><tr><td>git push 别名 分支</td><td>推送本地分支上的内容到远程仓库</td></tr><tr><td>git clone 远程地址</td><td>将远程仓库的内容克隆到本地</td></tr><tr><td>git pull 远程地址别名 远程分支名</td><td>将远程仓库对于分支最新内容拉下来后与当前本地分支直接合并</td></tr></tbody></table></div><h3 id="SSH免密登录"><a href="#SSH免密登录" class="headerlink" title="SSH免密登录"></a>SSH免密登录</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh-keygen -t rsa -C xxxxxx@XXXX.XXX   # 你的邮箱，下面一路回车就行<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Generating public/private rsa key pair.Enter file in which to save the key (/c/Users/Layne/.ssh/id_rsa):Created directory '/c/Users/Layne/.ssh'.Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in /c/Users/Layne/.ssh/id_rsa.Your public key has been saved in /c/Users/Layne/.ssh/id_rsa.pub.The key fingerprint is:SHA256:7CPfRLITKcYDhaqpEDeok7Atvwh2reRmpxxOC6dkY44atguiguyueyue@aliyun.comThe key's randomart image is:+---[RSA 2048]----+| .. || .. || . .. ||+ + o . . ||oO . = S . ||X . .. + = ||+@ * .. = . ||X.&amp;o+. o = ||Eo+Oo . . |+----[SHA256]-----+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cat ~/.ssh/id_rsa.pub<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>复制 id_rsa.pub 文件内容，登录 GitHub，点击用户头像→Settings→SSH and GPG keys  </p><p><img src="https://gitee.com/sehowyoung/images/raw/master/%E9%85%8D%E7%BD%AE.gif" alt="git与GitHub连接配置"></p><h2 id="IDEA集成Git"><a href="#IDEA集成Git" class="headerlink" title="IDEA集成Git"></a>IDEA集成Git</h2><h3 id="配置git忽略文件"><a href="#配置git忽略文件" class="headerlink" title="配置git忽略文件"></a>配置git忽略文件</h3><p>忽略IDEA自动生成的<code>.idea</code>和<code>xxxx.iml</code>文件</p><blockquote><ol><li><p>为什么要忽略他们？</p><p>与项目的实际功能无关，不参与服务器上部署运行。把它们忽略掉能够屏蔽 IDE 工具之<br>间的差异。  </p></li><li><p>怎么忽略？</p><ol><li><p>创建忽略规则文件 xxxx.ignore（前缀名随便起，建议是 git.ignore）这个文件的存放位置原则上在哪里都可以，为了便于让~/.gitconfig 文件引用，建议也放在用户家目录下。<br>git.ignore 文件模版内容如下：</p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">\# Compiled class file*.class  # Log file*.log# BlueJ files*.ctxt# Mobile Tools for Java (J2ME).mtj.tmp/# Package Files #*.jar*.war*.nar*.ear*.zip*.tar.gz*.rar# virtual machine crash logs, seehttp://www.java.com/en/download/help/error_hotspot.xmlhs_err_pid*.classpath.project.settingstarget.idea*.iml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>在.gitconfig文件中引用忽略配置文件</p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">[user]name = Layneemail = Layne@atguigu.com[core]excludesfile = C:/Users/asus/git.ignore<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>==注意：这里要使用“正斜线（/）”，不要使用“反斜线（\）”==</p></li></ol></li></ol></blockquote><h3 id="定位git程序"><a href="#定位git程序" class="headerlink" title="定位git程序"></a>定位git程序</h3><p><code>File</code>—&gt;<code>Settings</code>—&gt;<code>Version Control</code>—&gt;<code>Git</code>—&gt;<code>Path to Git executable：</code>选择自己的git安装目录—&gt;<code>Test</code></p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210610150457470.png" alt="IDEA定位Git"></p><h3 id="初始化本地库"><a href="#初始化本地库" class="headerlink" title="初始化本地库"></a>初始化本地库</h3><p><code>VCS</code>—&gt;<code>Import into Version Control</code>—&gt;<code>Create Git Respository</code>—&gt;选择要创建Git本地仓库的工程/项目</p><h3 id="添加到暂存区"><a href="#添加到暂存区" class="headerlink" title="添加到暂存区"></a>添加到暂存区</h3><p>右键点击项目，选择<code>Git</code>—&gt;<code>Add</code>将项目添加到暂存区</p><h3 id="提交到本地库"><a href="#提交到本地库" class="headerlink" title="提交到本地库"></a>提交到本地库</h3><p><code>Git</code>—&gt;<code>Commit Directory</code>—&gt;<code>Commit Message</code>—&gt;<code>Commit</code></p><h3 id="切换版本"><a href="#切换版本" class="headerlink" title="切换版本"></a>切换版本</h3><p>在IDEA左下角，点击<code>Version Control</code>—&gt;<code>Log</code>查看版本—&gt;右键选择要切换的版本—&gt;菜单里点击<code>Checkout Revision</code></p><h3 id="创建分支-1"><a href="#创建分支-1" class="headerlink" title="创建分支"></a>创建分支</h3><p>选择<code>Git</code>—&gt;<code>Respoitory</code>—&gt;<code>Branches</code>—&gt;<code>New Branch</code>—&gt;填写分支名称—&gt;<code>ok</code>—&gt;右下角看到分支名称，即代表创建成功，并且已切换到分支。</p><h3 id="切换分支-1"><a href="#切换分支-1" class="headerlink" title="切换分支"></a>切换分支</h3><p>IDEA右下角，切换到master分支，右下角看到分支名称，即代表已切换到分支。</p><h3 id="合并分支-1"><a href="#合并分支-1" class="headerlink" title="合并分支"></a>合并分支</h3><p>IDEA右下角，将xxx分支合并到当前master分支。</p><p>如果代码没有冲突， 分支直接合并成功，分支合并成功以后，代码自动提交，无需手动提交本地库。  </p><h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><ol><li>点击 Conflicts 框里的 Merge 按钮，进行手动合并代码。  </li><li>手动合并完代码以后，点击右下角的 Apply 按钮  </li><li>代码冲突解决，自动提交本地库  </li></ol><h2 id="IDEA集成GitHub"><a href="#IDEA集成GitHub" class="headerlink" title="IDEA集成GitHub"></a>IDEA集成GitHub</h2><h3 id="设置GitHub账号"><a href="#设置GitHub账号" class="headerlink" title="设置GitHub账号"></a>设置GitHub账号</h3><p><code>File</code>—&gt;<code>Settings</code>—&gt;<code>Version Control</code>—&gt;<code>GitHub</code>—&gt;<code>+</code>—&gt;添加GitHub账号密码</p><p>如果出现连接不上的情况，可以使用token的方式。</p><h4 id="设置token"><a href="#设置token" class="headerlink" title="设置token"></a>设置token</h4><p>打开<code>github</code>—&gt;头像—&gt;<code>Settings</code>—&gt;<code>Developer settings</code>—&gt;<code>Personal access tokens</code>—&gt;<code>Generate new token</code>—&gt;学习环境权限作用域全部勾选—&gt;<code>Generate token</code></p><p>复制 token ，返回IDEA进行登录。</p><h3 id="分享到Github"><a href="#分享到Github" class="headerlink" title="分享到Github"></a>分享到Github</h3><p><code>VCS</code>—&gt;<code>Import into Version Control</code>—&gt;<code>share Project on GitHub</code>—&gt;填写仓库名，点击分享</p><h3 id="push推送本地库到远程库"><a href="#push推送本地库到远程库" class="headerlink" title="push推送本地库到远程库"></a>push推送本地库到远程库</h3><p>右击项目—&gt;<code>Git</code>—&gt;<code>Respository</code>—&gt;<code>push</code>—&gt;在 <code>Push Commits</code>里面可以创建远程链接的别名—&gt;选择别名，将项目 push 到指定的远程仓库中。</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210610152425952.png" alt="创建远程链接的别名"></p><blockquote><p>注意：</p><p>push 是将本地库代码推送到远程库，如果本地库代码跟远程库代码版本不一致，push 的操作是会被拒绝的。也就是说， 要想 push 成功，一定要保证本地库的版本要比远程库的版本高！ </p><font color="red">因此一个成熟的程序员在动手改本地代码之前，一定会先检查下远程库跟本地代码的区别！如果本地的代码版本已经落后，切记要先 pull 拉取一下远程库的代码，将本地代码更新到最新以后，然后再修改，提交，推送 ！</font></blockquote><h3 id="pull拉去远程库到本地库"><a href="#pull拉去远程库到本地库" class="headerlink" title="pull拉去远程库到本地库"></a>pull拉去远程库到本地库</h3><p>右击项目—&gt;<code>Git</code>—&gt;<code>Respository</code>—&gt;<code>pull</code>—&gt;选择分支，点击<code>Pull</code></p><blockquote><p>注意：</p><p>pull 是拉取远端仓库代码到本地，如果远程库代码和本地库代码不一致，会自动合并，如果自动合并失败，还会涉及到手动解决冲突的问题。  </p></blockquote><h3 id="clone远程库到本地"><a href="#clone远程库到本地" class="headerlink" title="clone远程库到本地"></a>clone远程库到本地</h3><p><code>VCS</code>—&gt;<code>Git</code>—&gt;<code>Clone</code>—&gt;填写url，点击<code>test</code>，点击<code>clone</code>—&gt;创建一个工程，点击<code>next</code></p><h3 id="国内代码托管中心——gitee"><a href="#国内代码托管中心——gitee" class="headerlink" title="国内代码托管中心——gitee"></a>国内代码托管中心——gitee</h3><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>众所周知， GitHub 服务器在国外， 使用 GitHub 作为项目托管网站，如果网速不好的话，严重影响使用体验，甚至会出现登录不上的情况。针对这个情况，大家也可以使用国内的项目托管网站——Gitee。  </p><h3 id="注册账号"><a href="#注册账号" class="headerlink" title="注册账号"></a>注册账号</h3><p>官网：<a href="gitee.com">gitee.com</a></p><h3 id="IDEA集成Gitee"><a href="#IDEA集成Gitee" class="headerlink" title="IDEA集成Gitee"></a>IDEA集成Gitee</h3><h4 id="IDEA安装Gitee插件"><a href="#IDEA安装Gitee插件" class="headerlink" title="IDEA安装Gitee插件"></a>IDEA安装Gitee插件</h4><p>由于IDEA默认不带码云插件，我们要使用Gitee的话，就需要安装Gitee插件。</p><p><code>File</code>—&gt;<code>settings</code>—&gt;<code>plugins</code>—&gt;<code>Marketplace</code>—&gt;搜索<code>gitee</code>—&gt;<code>Install</code>—&gt;<code>Restart IDE</code></p><p><code>File</code>—&gt;<code>Settings</code>—&gt;<code>Version Control</code>—&gt;<code>Gitee</code>—&gt;<code>+</code>—&gt;添加Gitee账号密码</p><h4 id="IDEA连接Gitee"><a href="#IDEA连接Gitee" class="headerlink" title="IDEA连接Gitee"></a>IDEA连接Gitee</h4><p>dea 连接Gitee和连接 GitHub 几乎一样，首先在 Idea 里面创建一个工程，初始化 git 工程，然后将代码添加到暂存区，提交到本地库，这些步骤上面已经讲过，此处不再赘述。  </p><h4 id="本地代码Push到Gitee"><a href="#本地代码Push到Gitee" class="headerlink" title="本地代码Push到Gitee"></a>本地代码Push到Gitee</h4><p>右击项目—&gt;<code>Git</code>—&gt;<code>Respository</code>—&gt;<code>push</code>—&gt;在 <code>Push Commits</code>里面可以创建远程链接的别名，url填入Gitee仓库的链接即可—&gt;选择别名，将项目 push 到指定的远程仓库中。</p><p>只要码云远程库链接定义好以后， 对码云远程库进行 pull 和 clone 的操作和 Github 一<br>致，此处不再赘述。  </p><h3 id="Gitee复制GitHub项目"><a href="#Gitee复制GitHub项目" class="headerlink" title="Gitee复制GitHub项目"></a>Gitee复制GitHub项目</h3><p>Gitee提供了复制GitHub项目的功能，方便我们迁移和下载。</p><p>打开gitee —&gt; 右上角<code>+</code> —&gt; 从GitHub/GitLab导入仓库 —&gt;从GitHub导入 —&gt; 选择要导入的仓库，点击导入即可。</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210610194849360.png" alt="从GitHub/GitLab导入仓库"></p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210610194922761.png" alt="选择仓库进行导入"></p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经典排序算法的分析与实现</title>
      <link href="/posts/23901.html"/>
      <url>/posts/23901.html</url>
      
        <content type="html"><![CDATA[<h1 id="经典排序算法的分析与实现"><a href="#经典排序算法的分析与实现" class="headerlink" title="经典排序算法的分析与实现"></a>经典排序算法的分析与实现</h1><p>源码：</p><ul><li>gitee：<a href="https://gitee.com/sehowyoung/Sort">https://gitee.com/sehowyoung/Sort</a></li><li>github：<a href="https://github.com/sehowyoung/Sort">https://github.com/sehowyoung/Sort</a></li></ul><h2 id="1-comparable和comparator"><a href="#1-comparable和comparator" class="headerlink" title="1.comparable和comparator"></a>1.comparable和comparator</h2><blockquote><p>1.Comparable是排序接口；若一个类实现了Comparable接口，就意味着“该类支持排序”。</p><p>（作用在实体类上）<br>2.而Comparator是比较器；我们若需要控制某个类的次序，可以建立一个“该类的比较器”来进行排序。</p><p>（作用在排序类上）</p><p>总结：Comparable相当于“内部比较器”，而Comparator相当于“外部比较器”。</p></blockquote><h2 id="2-约定"><a href="#2-约定" class="headerlink" title="2.约定"></a>2.约定</h2><p>待排序的元素需要实现 Java 的 Comparable 接口，该接口有 compareTo() 方法，可以用它来判断两个元素的大小关系。</p><p>使用辅助函数 lessThan() 和 swap() 来进行比较和交换的操作，使得代码的可读性和可移植性更好。</p><p>排序算法的成本模型是比较和交换的次数。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public abstract class Sort&lt;T extends Comparable&lt;T&gt;&gt;  {    /**     * 对目标数组进行排序     * @param array 目标数组     */    public abstract void sort(T[] array);    /**     * @param v T类型的对象     * @param w T类型的对象     * @return 如果v&lt;w，返回true，否则返回false     */    protected boolean lessThan(T v, T w){        return v.compareTo(w) &lt; 0;    }    /**     * 比较同一类型的两个示例的大小     * @param v T类型的示例     * @param w T类型的示例     * @return 如果v&gt;w，返回true，否则返回false     */    protected boolean moreThn(T v, T w){        return v.compareTo(w) &gt; 0;    }    /**     * 用于交换数组中的两个数     * @param array 目标数组     * @param i 数组下标     * @param j 数组下标     */    protected void swap(T[] array, int i, int  j){        T t = array[i];        array[i] = array[j];        array[j] = t;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-选择排序算法"><a href="#3-选择排序算法" class="headerlink" title="3.选择排序算法"></a>3.选择排序算法</h2><p><strong>原理：</strong></p><p>每次从数组中选择最小元素，将它与数组的第i个元素交换位置。</p><p>选择排序需要 ~N^2^/2 次比较和 ~N 次交换，它的运行时间与输入无关，这个特点使得它对一个已经排序的数组也需要这么多的比较和交换操作。</p><p><img src="https://i.imgur.com/fYPsoKv.gif" alt=""></p><p><strong>代码实现：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Selection&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt; {    /**     * 使用快速排序算法进行排序     * @param array 目标数组     */    @Override    public void sort(T[] array) {        int n = array.length;        for (int i = 0; i &lt; n - 1; i++) {            int min = i;            for (int j = i + 1; j &lt; n; j++) {                if (lessThan(array[j], array[i])){                    min = j;                }            }            swap(array, i, min);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-冒泡排序算法"><a href="#4-冒泡排序算法" class="headerlink" title="4.冒泡排序算法"></a>4.冒泡排序算法</h2><p><strong>原理：</strong></p><p>从左到右不断交换相邻的逆序的元素，在经过一轮的循环之后，可以让最大的元素上浮到最右边。</p><p>在一轮循环中，如果没有发生交换，那么说明数组已经是有序的，此时可以直接退出。</p><p><img src="https://i.imgur.com/vkZ5GS7.gif" alt=""></p><p><strong>代码实现：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Bubble&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt;{    /**     * 用冒泡排序算法进行排序     * @param array 目标数组     */    @Override    public void sort(T[] array) {        int n = array.length;        boolean isSorted = false;        for (int i = 0; i &lt; n - 1; i++) {            isSorted = false;            for (int j = 0; j &lt; n - i - 1; j++) {                if (lessThan(array[j + 1], array[j])){                    swap(array, j + 1, j);                    isSorted = true;                }            }            if (!isSorted){                break;            }        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-插入排序算法"><a href="#5-插入排序算法" class="headerlink" title="5.插入排序算法"></a>5.插入排序算法</h2><p><strong>原理：</strong></p><p>从数组的第i（i&gt;1）个数据开始向前比较，如果比j（j&lt;i）小，交换位置。</p><p><img src="https://i.imgur.com/bncpJ2B.gif" alt=""></p><p><strong>代码实现：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Insertion&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt; {    /**     * 使用插入排序算法进行排序     * @param array 目标数组     */    @Override    public void sort(T[] array) {        for (int i = 1; i &lt; array.length; i++) {            for (int j = i; j &gt; 0; j--) {                if (lessThan(array[j], array[j - 1])){                    swap(array, j, j - 1);                }            }        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-希尔排序算法"><a href="#6-希尔排序算法" class="headerlink" title="6.希尔排序算法"></a>6.希尔排序算法</h2><p><strong>原理：</strong></p><p>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p><p><img src="https://i.imgur.com/3ymhb30.png" alt=""></p><p><strong>代码实现：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Shell&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt; {    /**     * 使用希尔排序算法进行排序     * @param array 目标数组     */    @Override    public void sort(T[] array) {        int gap = array.length / 2;        while(gap &gt;= 1){            for (int i = gap; i &lt; array.length; i++) {                for (int j = i; j &gt; gap - 1; j -= gap) {                    if (lessThan(array[j], array[j - gap])){                        swap(array, j, j - gap);                    }                }            }            gap /= 2;        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="7-归并排序算法"><a href="#7-归并排序算法" class="headerlink" title="7.归并排序算法"></a>7.归并排序算法</h2><p><strong>原理：</strong></p><p>归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。</p><p><strong>归并部分代码：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public abstract class Marge&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt; {    /**     * 归并算法     * @param array 原数组     * @param low   需要进行归并部分的开始下标     * @param mid   需要进行归并部分的中间下标     * @param high  需要进行归并部分的结束下标     * @param aux   辅助数组     */    protected void marge(T[] array, int low, int mid, int high, T[] aux){        for (int i = low; i &lt;= high; i++) {            aux[i] = array[i];        }        //右指针        int right = mid + 1;        //左指针        int left = low;        for (int i = low; i &lt;= high; i++) {            if (left &gt; mid){                //将右序列剩余元素添加进原数组                array[i] = aux[right++];            } else if (right &gt; high){                //将左序列剩余元素添加进原数组                array[i] = aux[left++];            } else if (aux[left].compareTo(aux[right]) &lt;= 0){                //添加小的元素进入原数组                array[i] = aux[left++];            } else {                //添加小的元素进入原数组                array[i] = aux[right++];            }        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-1-自顶向上归并排序"><a href="#7-1-自顶向上归并排序" class="headerlink" title="7.1 自顶向上归并排序"></a>7.1 自顶向上归并排序</h3><p><strong>原理：</strong></p><p>自顶向下的排序算法就是把数组元素不断的二分，直到子数组的元素个数为一个，因为这个时候子数组必定是已有序的，然后将两个有序的序列合并成一个新的有序的序列，两个新的有序序列又可以合并成另一个新的有序序列，以此类推，直到合并成一个有序的数组。</p><p><img src="https://i.imgur.com/b5Dgq52.png" alt=""></p><p><img src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161218194508761-468169540.png" alt=""></p><p><img src="https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161218194621308-588010220.png" alt=""></p><p><strong>代码实现：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class UpToDownMarge&lt;T extends Comparable&lt;T&gt;&gt; extends Marge&lt;T&gt;{    /**     * 使用自顶向下归并排序算法进行排序     * @param array 目标数组     */    @Override    public void sort(T[] array) {        //创建辅助数组        T[] auxiliary = (T[]) new Comparable[array.length];        sort(array, 0, array.length - 1, auxiliary);    }    /**     * 使用递归对数组进行划分     * @param array 任意类型的原数组     * @param low   需要进行划分部分的初始下标     * @param high  需要进行划分部分的结束下标     * @param aux   辅助数组     */    private void sort(T[] array, int low, int high, T[] aux) {        if (high &lt;= low){            return;        }        int mid = (low + high) / 2;        sort(array, low, mid, aux);        sort(array, mid + 1, high, aux);        marge(array, low, mid, high, aux);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-2-自底向上归并排序"><a href="#7-2-自底向上归并排序" class="headerlink" title="7.2 自底向上归并排序"></a>7.2 自底向上归并排序</h3><p><strong>原理：</strong></p><p>自底向上的排序是归并排序的一种实现方式，将一个无序的N长数组切个成N个有序子序列，然后再两两合并，然后再将合并后的N/2（或者N/2 + 1）个子序列继续进行两两合并，以此类推得到一个完整的有序数组。下图详细的分解了自底向上的合并算法的实现过程：</p><p><img src="https://i.imgur.com/57XtOjM.jpg" alt=""></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class DownToUpMerge&lt;T extends Comparable&lt;T&gt;&gt; extends Merge&lt;T&gt; {    /**     * 使用自底向上归并排序算法进行排序     * @param array 目标数组     */    @Override    public void sort(T[] array) {        T[] auxiliary = (T[]) new Comparable[array.length];        //len表示有len个元素归并，例如len=1表示一个一个元素的进行归并        for (int len = 1; len &lt; array.length; len += len) {            //按照len的长度归并，归并后长度翻倍            for (int start = 0; start &lt; array.length - len; start += len + len) {                merge(array, start, start + len - 1, Math.min(start + len + len -1, array.length - 1), auxiliary);            }        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="8-快速排序算法"><a href="#8-快速排序算法" class="headerlink" title="8.快速排序算法"></a>8.快速排序算法</h2><h3 id="8-1-基本算法"><a href="#8-1-基本算法" class="headerlink" title="8.1 基本算法"></a>8.1 基本算法</h3><p><strong>基本思想：</strong></p><ul><li>先从数列中取出一个数作为基准数。</li><li>分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。</li><li>再对左右区间重复第二步，直到各区间只有一个数。</li></ul><p><img src="https://i.imgur.com/L1UTzxn.png" alt=""></p><ul><li>切分：取 array[low] 作为切分元素，然后从数组的左端向右端扫描知道找到第一个大于等于它的元素，再从数组的右端向左扫描找到第一个小于它的元素，交换这两个元素。不断重复进行这个过程就可以保证左指针 left 的左侧元素都不大于切分元素，右指针 right 的右侧元素都不小于切分元素。当两个指针相遇时，将切分元素 a[low] 和 a[right] 交换位置。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Quick&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt; {    /**     * 使用快速排序算法进行排序     * @param array 目标数组     */    @Override    public void sort(T[] array) {        sort(array, 0, array.length - 1);    }    /**     * 通过递归不断交换元素的位置     * @param array 被操作的数组     * @param low   从左边开始执行的元素下标     * @param high  从右边开始执行的元素下标     */    private void sort(T[] array, int low, int high) {        if (high &lt;= low){            return;        }        //获取被发生交换的元素的位置        int index = partition(array, low, high);        sort(array, low, index - 1);        sort(array, index + 1, high);    }    /**     * 对原数组进行切分，获取与array[low]进行交换的元素的下标     * @param array 操作数组     * @param low   从左边开始执行的元素下标     * @param high  从右边开始执行的元素下标     * @return 返回与array[low]进行交换的元素的下标     */    private int partition(T[] array, int low, int high) {        //左指针        int left = low + 1;        //右指针        int right = high;        T flag = array[low];        while (true){            while (lessThan(array[left], flag) &amp;&amp; left != high){                left++;            }            while (lessThan(flag, array[right]) &amp;&amp; right != low){                right--;            }            if (left &gt;= right){                break;            }            swap(array, left, right);        }        swap(array, low, right);        return right;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="8-2-性能分析"><a href="#8-2-性能分析" class="headerlink" title="8.2 性能分析"></a>8.2 性能分析</h3><p>快速排序是原地排序，不需要辅助数组，但是递归调用需要辅助栈。</p><p>快速排序最好的情况下是每次都正好将数组对半分，这样递归调用次数才是最少的。这种情况下比较次数为 CN=2CN/2+N，复杂度为 O(NlogN)。</p><p>最坏的情况下，第一次从最小的元素切分，第二次从第二小的元素切分，如此这般。因此最坏的情况下需要比较 N2/2。为了防止数组最开始就是有序的，在进行快速排序时需要随机打乱数组。</p><h3 id="8-3-算法改进"><a href="#8-3-算法改进" class="headerlink" title="8.3 算法改进"></a>8.3 算法改进</h3><h4 id="8-3-1-切换到插入排序"><a href="#8-3-1-切换到插入排序" class="headerlink" title="8.3.1 切换到插入排序"></a>8.3.1 切换到插入排序</h4><p>在面对小数组时，使用快速排序会浪费更多的时间、空间，可以学习jdk1.8的排序算法，当数组长度小于某个值时，使用插入排序算法</p><h4 id="8-3-2-三数取中算法"><a href="#8-3-2-三数取中算法" class="headerlink" title="8.3.2 三数取中算法"></a>8.3.2 三数取中算法</h4><p>在快排的过程中，每一次我们要取一个元素作为枢纽值，以这个数字来将序列划分为两部分。在此我们采用三数取中法，也就是取左端、中间、右端三个数，然后进行排序，将中间数作为枢纽值。</p><p><strong>基本原理：</strong></p><p><img src="https://i.imgur.com/KeNroIf.png" alt=""></p><p><img src="https://i.imgur.com/xnQscCO.png" alt=""></p><p><img src="https://i.imgur.com/yLQ3aMX.png" alt=""></p><p><strong>代码实现：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MiddleOfThree&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt; {    /**     * 使用三数取中快速排序算法进行排序     * @param array 目标数组     */    @Override    public void sort(T[] array) {        sort(array, 0, array.length - 1);    }    /**     * 使用递归对目标数组 array 进行排序     * @param array 目标数组     * @param low   左指针     * @param high  右指针     */    private void sort(T[] array, int low, int high) {        dealPivot(array, low, high);        //使用下列判断去除一下已经排好序的情况，节省运行时间        if (high &lt;= low + 1){            return;        }        int pivot = high - 1;        int left = low + 1;        int right = pivot - 1;        while (true){            while (lessThan(array[left], array[pivot]) &amp;&amp; left &lt; high){                left++;            }            while (right &gt; low &amp;&amp; moreThen(array[right], array[pivot])){                right--;            }            if (right &gt; left){                swap(array, left, right);            } else {                break;            }        }        swap(array, left, pivot);        sort(array, low, left - 1);        sort(array, left + 1, high);    }    /**     * 找到枢纽值，并对左端值、枢纽值、右端值进行排序，并将枢纽值放到右端值左侧     * 通过三次判断就保证了三个值的升序排列     * @param array 目标数组     * @param low   左端指针     * @param high  右端指针     */    private void dealPivot(T[] array, int low, int high) {        int mid = (low + high) / 2;        //对左端值、枢纽值、右端值三个数进行排序        if (lessThan(array[mid], array[low])){            swap(array, low, mid);        }        if (lessThan(array[high], array[mid])){            swap(array, mid, high);        }        if (lessThan(array[mid], array[low])){            swap(array, low, mid);        }        //将枢纽值放到右端值左侧        swap(array, mid, high - 1);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="8-3-3-三向切分算法"><a href="#8-3-3-三向切分算法" class="headerlink" title="8.3.3 三向切分算法"></a>8.3.3 三向切分算法</h4><p>对于有大量重复元素的数组，可以将数组切分为三部分，分别对应小于、等于和大于切分元素。</p><p>三向切分快速排序对于有大量重复元素的随机数组可以在线性时间内完成排序。</p><p><strong>基本原理：</strong></p><p>对于每次切分：从数组的左边到右边遍历一次，维护三个指针，其中lt指针使得元素（arr[0]-arr[lt-1]）的值均小于切分元素；gt指针使得元素（arr[gt+1]-arr[N-1]）的值均大于切分元素；index指针使得元素（arr[lt]-arr[index-1]）的值均等于切分元素，（arr[index]-arr[gt]）的元素还没被扫描，切分算法执行到index&gt;gt为止。每次切分之后，位于gt指针和lt指针之间的元素的位置都已经被排定，不需要再去处理了。之后将（lo,lt-1）,（gt+1,hi）分别作为处理左子数组和右子数组的递归函数的参数传入，递归结束，整个算法也就结束。</p><p><img src="https://i.imgur.com/6tWXYdr.png" alt=""></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ThreeWay&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt; {    /**     * 实现Sort的sort接口     * @param array 目标数组     */    @Override    public void sort(T[] array) {        sort(array, 0, array.length - 1);    }    /**     * 递归使用三向切分快速排序算法进行排序     * @param array 目标数组     * @param low   左指针     * @param high  右指针     */    private void sort(T[] array, int low, int high) {        if (high &lt;= low){            return;        }        //lt:less than  gt:greater than        int lt = low;        int index = low + 1;        int gt = high;        T temp = array[low];        while (index &lt;= gt){            int cmp = array[index].compareTo(temp);            if (cmp &lt; 0){                swap(array, lt++, index++);            } else if (cmp &gt; 0){                swap(array, index, gt--);            } else {                index++;            }        }        sort(array, low, lt - 1);        sort(array, gt + 1, high);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="8-4-基于切分的快速选择算法"><a href="#8-4-基于切分的快速选择算法" class="headerlink" title="8.4 基于切分的快速选择算法"></a>8.4 基于切分的快速选择算法</h4><p>快速排序的 partition() 方法，会返回一个整数 j 使得 a[l..j-1] 小于等于 a[j]，且 a[j+1..h] 大于等于 a[j]，此时 a[j] 就是数组的第 j 大元素。</p><p>可以利用这个特性找出数组的第 k 个元素。</p><p>该算法是线性级别的，假设每次能将数组二分，那么比较的总次数为 (N+N/2+N/4+..)，直到找到第 k 个元素，这个和显然小于 2N。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">/**     * 搜索数组中第k个小的元素     * @param array 目标数组     * @param k     第k个元素     * @return      第k个元素     */    public T select(T[] array, int k){        int low = 0;        int high = array.length - 1;        while (high &gt; low){            int index = partition(array, low, high);            if (index == k - 1){                return array[k - 1];            } else if (index &gt; k - 1){                high = index - 1;            } else {                low = index + 1;            }        }        return array[k - 1];    }<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="9-堆排序"><a href="#9-堆排序" class="headerlink" title="9.堆排序"></a>9.堆排序</h2><p>堆中某个节点的值总是大于等于或小于等于其子节点的值，并且堆是一颗完全二叉树。</p><p>堆可以用数组来表示，这是因为堆是完全二叉树，而完全二叉树很容易就存储在数组中。位置 k 的节点的父节点位置为 k/2，而它的两个子节点的位置分别为 2k 和 2k+1。这里不使用数组索引为 0 的位置，是为了更清晰地描述节点的位置关系。</p><p><strong>基本原理：</strong></p><ol><li>构建堆：根据初始数组去构造初始堆（构建一个完全二叉树，保证所有的父结点都比它的孩子结点数值大）。</li><li>每次交换第一个和最后一个元素，输出最后一个元素（最大值），然后把剩下元素重新调整为大根堆。 </li><li>当输出完最后一个元素后，这个数组已经是按照从小到大的顺序排列了。</li></ol><p>具体可以查看博客：<a href="https://www.cnblogs.com/chengxiao/p/6129630.html">图解排序算法(三)之堆排序</a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class HeapSort&lt;T extends Comparable&lt;T&gt;&gt; extends Sort&lt;T&gt; {    /**     * 使用堆排序算法进行排序     * @param array 目标数组     */    @Override    public void sort(T[] array) {        //构建大顶堆        int len = array.length;        for (int i = len / 2 - 1; i &gt;= 0; i--) {            //从第一个非叶子结点从下至上，从右至左调整结构            adjust(array, i, len);        }        //调整堆结构+交换堆顶元素与末尾元素        for (int i = len - 1; i &gt; 0; i--) {            swap(array, 0, i);            adjust(array, 0, i);        }    }    /**     * 对第i个节点以及其子节点进行调整调整     * @param array 目标数组     * @param i     第i个节点     * @param len   数组长度     */    private void adjust(T[] array, int i, int len) {        //获取当前值        T temp = array[i];        //从i节点的左子节点开始，即2i+1处        for (int j = i * 2 + 1; j &lt; len; j = j * 2 + 1) {            //如果存在右子节点，并且左子节点小于右子节点，j指向右子节点            if (j + 1 &lt; len &amp;&amp; lessThan(array[j], array[j + 1])){                j++;            }            //如果子节点大于父节点，将子节点值赋给父节点（不进行交换）            if (lessThan(temp, array[j])){                array[i] = array[j];                i = j;            } else {                break;            }        }        //将temp的值放到最终的位置        array[i] = temp;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>分析：</strong></p><ul><li><p>一个堆的高度为 logN，因此在堆中插入元素和删除最大元素的复杂度都为 logN。</p></li><li><p>对于堆排序，由于要对 N 个节点进行下沉操作，因此复杂度为 NlogN。</p></li><li><p>堆排序是一种原地排序，没有利用额外的空间。</p></li><li><p>现代操作系统很少使用堆排序，因为它无法利用局部性原理进行缓存，也就是数组元素很少和相邻的元素进行比较和交换。</p></li></ul><h2 id="10-上述排序算法的比较"><a href="#10-上述排序算法的比较" class="headerlink" title="10.上述排序算法的比较"></a>10.上述排序算法的比较</h2><div class="table-container"><table><thead><tr><th>算法</th><th>稳定性</th><th>时间复杂度</th><th>空间复杂度</th><th>备注</th></tr></thead><tbody><tr><td><a href="#3.选择排序算法">选择排序</a></td><td>×</td><td>N^2^</td><td>1</td><td></td></tr><tr><td><a href="#4.冒泡排序算法">冒泡排序</a></td><td>√</td><td>N^2^</td><td>1</td><td></td></tr><tr><td><a href="#5.插入排序算法">插入排序</a></td><td>√</td><td>N~N^2^</td><td>1</td><td>时间复杂度和初始顺序有关</td></tr><tr><td><a href="#6.希尔排序算法">希尔排序</a></td><td>×</td><td>N的若干倍乘于递增序列的长度</td><td>1</td><td>改进版插入排序</td></tr><tr><td><a href="#7.归并排序算法">归并排序</a></td><td>√</td><td>NlogN</td><td>N</td><td></td></tr><tr><td><a href="#8.快速排序算法">快速排序</a></td><td>×</td><td>NlogN</td><td>logN</td><td></td></tr><tr><td><a href="#8.3.2 三数取中算法">三数取中快速排序</a></td><td>×</td><td>NlogN</td><td>logN</td><td></td></tr><tr><td><a href="#8.3.3 三向切分算法">三向切分快速排序</a></td><td>×</td><td>N ~ NlogN</td><td>logN</td><td>适用于有大量重复数据</td></tr><tr><td><a href="#9.堆排序">堆排序</a></td><td>×</td><td>NlogN</td><td>1</td><td>无法利用局部性原理</td></tr></tbody></table></div><ul><li>排序算法的稳定性：俗地讲就是能保证排序前两个相等的数据其在序列中的先后位置顺序与排序后它们两个先后位置顺序相同。即：如，如果A i == A j，Ai 原来在 Aj 位置前，排序后 Ai 仍然是在 Aj 位置前。</li></ul><h2 id="11-JDK自带的DualPivotQuickSort"><a href="#11-JDK自带的DualPivotQuickSort" class="headerlink" title="11.JDK自带的DualPivotQuickSort"></a>11.JDK自带的DualPivotQuickSort</h2><p>jdk版本：1.8.0_281</p><p>DualPivotQuickSort 类实现了由 Vladimir Yaroslavskiy、Jon Bentley和Josh Bloch的Dual-Pivot Quicksort算法。该算法在许多数据集上提供了O(nlog(n))的性能，这些数据集会导致其他quicksort的性能下降到二次方，并且通常比传统的（单枢轴）Quicksort实现更快。所有暴露的方法都是包私有的，设计为在执行任何必要的数组边界检查并将参数扩展为所需形式后，从公共方法（在类Arrays中）调用。</p><p>整个算法的思路是：首先检查数组的长度，比一个阈值小的时候直接使用双轴快排。其它情况下，先检查数组中数据的顺序连续性。把数组中连续升序或者连续降序的信息记录下来，顺便把连续降序的部分倒置。这样数据就被切割成一段段连续升序的数列。</p><p>以下是int类型排序的源码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">final class DualPivotQuicksort {    /**     * 保护这个类不被实例化     */    private DualPivotQuicksort() {}    /**     * 待归并的序列的最大数量     */    private static final int MAX_RUN_COUNT = 67;    /**     * 待归并的序列的最大长度     */    private static final int MAX_RUN_LENGTH = 33;    /**     * 如果参与排序的数组长度小于这个值，优先使用快速排序而不是归并排序     */    private static final int QUICKSORT_THRESHOLD = 286;    /**     * 如果参与排序的数组长度小于这个值，优先使用插入排序而不是快速排序     */    private static final int INSERTION_SORT_THRESHOLD = 47;    /**     * 如果要排序的字节数组的长度大于这个常数，则优先使用计数排序，而不是插入排序。     */    private static final int COUNTING_SORT_THRESHOLD_FOR_BYTE = 29;    /**     * 如果要排序的短数组或char数组的长度大于这个常数，则优先使用计数排序，而不是Quicksort。     */    private static final int COUNTING_SORT_THRESHOLD_FOR_SHORT_OR_CHAR = 3200;   /**     * 如果可能的话，使用给定的工作空间数组片对数组的指定范围进行排序，以便合并。     *     * @param a         目标数组     * @param left the  第一个元素的索引，包括在内，要进行排序。     * @param right the 要排序的数组的最后一个元素的索引，包括在内。     * @param work     工作区阵列     * @param workBase  工作阵列中可用空间的来源     * @param workLen   工作阵列的可用长度     */    static void sort(int[] a, int left, int right,                     int[] work, int workBase, int workLen) {        // 在小数组上使用Quicksort        if (right - left &lt; QUICKSORT_THRESHOLD) {            sort(a, left, right, true);            return;        }        /*         * Index run[i] is the start of i-th run         * (ascending or descending sequence).         */        int[] run = new int[MAX_RUN_COUNT + 1];        int count = 0; run[0] = left;        // 检查数组是否接近排序        for (int k = left; k &lt; right; run[count] = k) {            if (a[k] &lt; a[k + 1]) { // 升序                while (++k &lt;= right &amp;&amp; a[k - 1] &lt;= a[k]);            } else if (a[k] &gt; a[k + 1]) { // 降序                while (++k &lt;= right &amp;&amp; a[k - 1] &gt;= a[k]);                for (int lo = run[count] - 1, hi = k; ++lo &lt; --hi; ) {                    int t = a[lo]; a[lo] = a[hi]; a[hi] = t;                }            } else { // equal                for (int m = MAX_RUN_LENGTH; ++k &lt;= right &amp;&amp; a[k - 1] == a[k]; ) {                    if (--m == 0) {                        sort(a, left, right, true);                        return;                    }                }            }            /*             * 数组结构不高，用Quicksort代替合并排序。             */            if (++count == MAX_RUN_COUNT) {                sort(a, left, right, true);                return;            }        }        // 检查特殊情况        // 实施说明：变量 "right "增加1。        if (run[count] == right++) { // The last run contains one element            run[++count] = right;        } else if (count == 1) { // The array is already sorted            return;        }        // 确定合并的交替基础        byte odd = 0;        for (int n = 1; (n &lt;&lt;= 1) &lt; count; odd ^= 1);        // 使用或创建临时数组b进行合并        int[] b;                 // temp array; alternates with a        int ao, bo;              // array offsets from 'left'        int blen = right - left; // space needed for b        if (work == null || workLen &lt; blen || workBase + blen &gt; work.length) {            work = new int[blen];            workBase = 0;        }        if (odd == 0) {            System.arraycopy(a, left, work, workBase, blen);            b = a;            bo = 0;            a = work;            ao = workBase - left;        } else {            b = work;            ao = 0;            bo = workBase - left;        }        // Merging        for (int last; count &gt; 1; count = last) {            for (int k = (last = 0) + 2; k &lt;= count; k += 2) {                int hi = run[k], mi = run[k - 1];                for (int i = run[k - 2], p = i, q = mi; i &lt; hi; ++i) {                    if (q &gt;= hi || p &lt; mi &amp;&amp; a[p + ao] &lt;= a[q + ao]) {                        b[i + bo] = a[p++ + ao];                    } else {                        b[i + bo] = a[q++ + ao];                    }                }                run[++last] = hi;            }            if ((count &amp; 1) != 0) {                for (int i = right, lo = run[count - 1]; --i &gt;= lo;                    b[i + bo] = a[i + ao]                );                run[++last] = right;            }            int[] t = a; a = b; b = t;            int o = ao; ao = bo; bo = o;        }    }            /**     * 使用双轴快速排序给指定数组的指定范围排序     *     * @param          目标数组     * @param left     范围内最左边的元素的位置(包括该元素)     * @param right    范围内最右边的元素的位置(包括该元素)     * @param leftmost 指定的范围是否在数组的最左边     */    private static void sort(int[] a, int left, int right, boolean leftmost) {        int length = right - left + 1;        //小数组使用插入排序        if (length &lt; INSERTION_SORT_THRESHOLD) {            if (leftmost) {                /*                 * 传统的（没有哨兵）插入排序，针对服务器虚拟机进行了优化，在最左边的情况下使用。                 */                for (int i = left, j = i; i &lt; right; j = ++i) {                    int ai = a[i + 1];                    while (ai &lt; a[j]) {                        a[j + 1] = a[j];                        if (j-- == left) {                            break;                        }                    }                    a[j + 1] = ai;                }            } else {                /*                 * 跳过开头的升序。                 */                do {                    if (left &gt;= right) {                        return;                    }                } while (a[++left] &gt;= a[left - 1]);                /*                 * 来自相邻部分的每个元素都扮演着哨兵的角色，因此，这使得我们可以避免                 * 每次迭代的左范围检查。此外，我们使用了更优化的算法，即所谓的成对插入                 * 排序，它比传统的插入排序的实现更快（在Quicksort的上下文中）。                 */                for (int k = left; ++left &lt;= right; k = ++left) {                    int a1 = a[k], a2 = a[left];                    if (a1 &lt; a2) {                        a2 = a1; a1 = a[left];                    }                    //先把两个数字中较大的那个移动到合适的位置                    while (a1 &lt; a[--k]) {                        //这里每次需要向左移动两个元素                        a[k + 2] = a[k];                    }                    a[++k + 1] = a1;  //再把两个数字中较小的那个移动到合适的位置                    while (a2 &lt; a[--k]) {                        //这里每次需要向左移动一个元素                        a[k + 1] = a[k];                    }                    a[k + 1] = a2;                }                int last = a[right];                while (last &lt; a[--right]) {                    a[right + 1] = a[right];                }                a[right + 1] = last;            }            return;        }        // length / 7的一种低复杂度实现        int seventh = (length &gt;&gt; 3) + (length &gt;&gt; 6) + 1;        /*         * 在范围内的中心元素周围（并包括中心元素）排序五个均匀间隔的元素。         * 这些元素将用于下文所述的枢轴选择。这些元素间距的选择是根据经验确定的，         * 对各种输入都能很好地发挥作用。         */        // 中间值        int e3 = (left + right) &gt;&gt;&gt; 1;         int e2 = e3 - seventh;        int e1 = e2 - seventh;        int e4 = e3 + seventh;        int e5 = e4 + seventh;        // 对这些元素使用插入排序        if (a[e2] &lt; a[e1]) { int t = a[e2]; a[e2] = a[e1]; a[e1] = t; }        if (a[e3] &lt; a[e2]) { int t = a[e3]; a[e3] = a[e2]; a[e2] = t;            if (t &lt; a[e1]) { a[e2] = a[e1]; a[e1] = t; }        }        if (a[e4] &lt; a[e3]) { int t = a[e4]; a[e4] = a[e3]; a[e3] = t;            if (t &lt; a[e2]) { a[e3] = a[e2]; a[e2] = t;                if (t &lt; a[e1]) { a[e2] = a[e1]; a[e1] = t; }            }        }        if (a[e5] &lt; a[e4]) { int t = a[e5]; a[e5] = a[e4]; a[e4] = t;            if (t &lt; a[e3]) { a[e4] = a[e3]; a[e3] = t;                if (t &lt; a[e2]) { a[e3] = a[e2]; a[e2] = t;                    if (t &lt; a[e1]) { a[e2] = a[e1]; a[e1] = t; }                }            }        }        //指针        int less  = left;  // 中间区域首个元素的下标        int great = right; // 右边区域首个元素的下标        if (a[e1] != a[e2] &amp;&amp; a[e2] != a[e3] &amp;&amp; a[e3] != a[e4] &amp;&amp; a[e4] != a[e5]) {            /*             * 使用五个排序元素中的第二个和第四个作为支点。             * 这些值是数组的第一和第二特码的廉价近似值。             * 请注意，pivot1 &lt;= pivot2。             */            int pivot1 = a[e2];            int pivot2 = a[e4];            /*             * 要排序的第一个和最后一个元素被移动到以前被枢轴占用的位置。             * 分割完成后，将枢轴换回其最终位置，并将其排除在后续排序之外。             */            a[e2] = a[left];            a[e4] = a[right];            /*             * 跳过一些队首的小于pivot1的值，跳过队尾的大于pivot2的值             */            while (a[++less] &lt; pivot1);            while (a[--great] &gt; pivot2);            /*             * Partitioning:             *             *   left part           center part                   right part             * +--------------------------------------------------------------+             * |  &lt; pivot1  |  pivot1 &lt;= &amp;&amp; &lt;= pivot2  |    ?    |  &gt; pivot2  |             * +--------------------------------------------------------------+             *               ^                          ^       ^             *               |                          |       |             *              less                        k     great             *             * Invariants:             *             *              all in (left, less)   &lt; pivot1             *    pivot1 &lt;= all in [less, k)     &lt;= pivot2             *              all in (great, right) &gt; pivot2             *             * Pointer k is the first index of ?-part.             */            outer:            for (int k = less - 1; ++k &lt;= great; ) {                int ak = a[k];                // 将a[k]移动到左部区域                if (ak &lt; pivot1) {                     a[k] = a[less];                    /*                     * Here and below we use "a[i] = b; i++;" instead                     * of "a[i++] = b;" due to performance issue.                     */                    a[less] = ak;                    ++less;                // 移动 a[k]到右侧区域                } else if (ak &gt; pivot2) {                     while (a[great] &gt; pivot2) {                        if (great-- == k) {                            break outer;                        }                    }                    // a[great] &lt;= pivot2                    if (a[great] &lt; pivot1) {                         a[k] = a[less];                        a[less] = a[great];                        ++less;                    } else { // pivot1 &lt;= a[great] &lt;= pivot2                        a[k] = a[great];                    }                    /*                     * Here and below we use "a[i] = b; i--;" instead                     * of "a[i--] = b;" due to performance issue.                     */                    a[great] = ak;                    --great;                }            }            // 交换他们最后的下标            a[left]  = a[less  - 1]; a[less  - 1] = pivot1;            a[right] = a[great + 1]; a[great + 1] = pivot2;            // 递归地对左右两部分进行排序，排除已知的支点。            sort(a, left, less - 2, leftmost);            sort(a, great + 2, right, false);            /*             * If center part is too large (comprises &gt; 4/7 of the array),             * swap internal pivot values to ends.             * 如果中心区域太大，超过数组长度的 4/7。就先进行预处理，再参与递归排序。             * 预处理的方法是把等于pivot1的元素统一放到左边，等于pivot2的元素统一             * 放到右边,最终产生一个不包含pivot1和pivot2的数列，再拿去参与快排中的递归。             */            if (less &lt; e1 &amp;&amp; e5 &lt; great) {                /*                 * 跳过等于枢轴值的元素。                 */                while (a[less] == pivot1) {                    ++less;                }                while (a[great] == pivot2) {                    --great;                }                /*                 * Partitioning:                 *                 *   left part         center part                  right part                 * +----------------------------------------------------------+                 * | == pivot1 |  pivot1 &lt; &amp;&amp; &lt; pivot2  |    ?    | == pivot2 |                 * +----------------------------------------------------------+                 *              ^                        ^       ^                 *              |                        |       |                 *             less                      k     great                 *                 * Invariants:                 *                 *              all in (*,  less) == pivot1                 *     pivot1 &lt; all in [less,  k)  &lt; pivot2                 *              all in (great, *) == pivot2                 *                 * Pointer k is the first index of ?-part.                 */                outer:                for (int k = less - 1; ++k &lt;= great; ) {                    int ak = a[k];                    if (ak == pivot1) { // Move a[k] to left part                        a[k] = a[less];                        a[less] = ak;                        ++less;                    } else if (ak == pivot2) { // Move a[k] to right part                        while (a[great] == pivot2) {                            if (great-- == k) {                                break outer;                            }                        }                        if (a[great] == pivot1) { // a[great] &lt; pivot2                            a[k] = a[less];                            /*                             * 尽管a[great]等于pivot1，但如果a[great]和                             * pivot1是不同符号的浮点零点，那么a[less]=pivot1                             * 的赋值可能是错误的。因此在浮点数和双数排序方法中，                             * 我们必须使用更准确的赋值a[less] = a[great]。                             */                            a[less] = pivot1;                            ++less;                        } else { // pivot1 &lt; a[great] &lt; pivot2                            a[k] = a[great];                        }                        a[great] = ak;                        --great;                    }                }            }            // 中心部分递归排序            sort(a, less, great, false);        } else { // 用一个枢轴进行分区            /*             * 使用五个排序元素中的第三个作为中枢。* 这个值是中位数的廉价近似值。             */            int pivot = a[e3];            /*             * Partitioning degenerates to the traditional 3-way             * (or "Dutch National Flag") schema:             *             *   left part    center part              right part             * +-------------------------------------------------+             * |  &lt; pivot  |   == pivot   |     ?    |  &gt; pivot  |             * +-------------------------------------------------+             *              ^              ^        ^             *              |              |        |             *             less            k      great             *             * Invariants:             *             *   all in (left, less)   &lt; pivot             *   all in [less, k)     == pivot             *   all in (great, right) &gt; pivot             *             * Pointer k is the first index of ?-part.             */            for (int k = less; k &lt;= great; ++k) {                if (a[k] == pivot) {                    continue;                }                int ak = a[k];                if (ak &lt; pivot) { // Move a[k] to left part                    a[k] = a[less];                    a[less] = ak;                    ++less;                } else { // a[k] &gt; pivot - Move a[k] to right part                    while (a[great] &gt; pivot) {                        --great;                    }                    if (a[great] &lt; pivot) { // a[great] &lt;= pivot                        a[k] = a[less];                        a[less] = a[great];                        ++less;                    } else { // a[great] == pivot                        /*                         * 尽管a[great]等于pivot，但如果a[great]和pivot是不同符号                         * 的浮点零点，那么a[k]=pivot的赋值可能是错误的。因此在浮点数                         * 和双数排序方法中，我们必须使用更准确的赋值a[k] = a[great]。                         */                        a[k] = pivot;                    }                    a[great] = ak;                    --great;                }            }            /*             * 左右部分递归排序。从中心部分开始的所有元素都是相等的，因此，已经进行了排序。             */            sort(a, left, less - 1, leftmost);            sort(a, great + 1, right, false);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="学习参考："><a href="#学习参考：" class="headerlink" title="学习参考："></a>学习参考：</h2><ol><li><a href="https://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80/%E7%AE%97%E6%B3%95%20-%20%E6%8E%92%E5%BA%8F.html#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F">算法-排序</a></li><li><a href="https://www.cnblogs.com/chengxiao/p/6104371.html">图解排序算法(二)之希尔排序</a></li><li><a href="https://www.cnblogs.com/chengxiao/p/6194356.html">图解排序算法(四)之归并排序</a></li><li><a href="https://www.cnblogs.com/ningvsban/p/3789479.html">自底向上的归并排序</a></li><li><a href="https://www.cnblogs.com/chengxiao/p/6262208.html">图解排序算法(五)之快速排序——三数取中法</a></li><li><a href="https://www.cnblogs.com/chengxiao/p/6129630.html">图解排序算法(三)之堆排序</a></li><li><a href="https://blog.csdn.net/weixin_41552752/article/details/90410749?spm=1001.2014.3001.5501">常用算法稳定性分析</a></li><li><a href="https://www.cnblogs.com/dion-90/articles/8547688.html">常用排序算法稳定性、时间复杂度分析</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客优化</title>
      <link href="/posts/27992.html"/>
      <url>/posts/27992.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文参考<a href="https://fenghen0918.github.io/2020/06/18/hexo/hexo-github-da-jian-matery-bo-ke-er-zhu-ti-pei-zhi-pian/#toc-heading-17">Hexo+github搭建matery博客二（主题配置篇）</a></p></blockquote><h2 id="更改主题的默认配置"><a href="#更改主题的默认配置" class="headerlink" title="更改主题的默认配置"></a>更改主题的默认配置</h2><h3 id="增加红心"><a href="#增加红心" class="headerlink" title="增加红心"></a>增加红心</h3><p>打开<code>themes\matery\layout\_partial/header.ejs</code>文件，增加：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在需要红心的地方添加以下代码：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>i</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>heartbeat<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>fa fas fa-heartbeat<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>i</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="修改页脚"><a href="#修改页脚" class="headerlink" title="修改页脚"></a>修改页脚</h3><p>打开<code>themes\matery\layout\_partial/footer.ejs</code>文件，修改成自己想要的样式：</p><pre class="line-numbers language-ejs" data-language="ejs"><code class="language-ejs">Copyright&amp;nbsp;&amp;copy;&lt;% if (theme.time.year !== new Date().getFullYear()) { %&gt;&lt;span id="year"&gt;&lt;%- theme.time.year %&gt;-&lt;%- new Date().getFullYear() %&gt;&lt;/span&gt;&lt;% } else { %&gt;&lt;span id="year"&gt;&lt;%- theme.time.year %&gt;&lt;/span&gt;&lt;% } %&gt;&lt;span id="year"&gt;&lt;%- theme.time.year %&gt;&lt;/span&gt;&lt;i id="heartbeat" class="fa fas fa-heartbeat"&gt;&lt;/i&gt;&amp;nbsp;&lt;a href="&lt;%- url_for('/about') %&gt;" target="_blank"&gt;&lt;%- config.title %&gt;&lt;/a&gt;&lt;br&gt;欢迎访问我的博客！&lt;br&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210609181455329.png" alt="页脚效果图"></p><h3 id="修改打赏二维码"><a href="#修改打赏二维码" class="headerlink" title="修改打赏二维码"></a>修改打赏二维码</h3><p>在主题文件的<code>source/medias/reward</code>文件中，替换成自己的支付宝和微信二维码即可。</p><h3 id="修改社交链接"><a href="#修改社交链接" class="headerlink" title="修改社交链接"></a>修改社交链接</h3><p>打开主题的<code>_config.yml</code>文件，找到<code>socialLink</code>，按自己的意愿修改代码：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"># 首页 banner 中的第二行个人信息配置，留空即不启用socialLink:  github:  https://github.com/sehowyoung  email: howyoung525@foxmail.com  facebook: # https://www.facebook.com/xxx  twitter: # https://twitter.com/xxx  qq: 846614051  weibo: # https://weibo.com/xxx  zhihu: # https://www.zhihu.com/xxx  rss: false # true、false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="鼠标点击增加特效"><a href="#鼠标点击增加特效" class="headerlink" title="鼠标点击增加特效"></a>鼠标点击增加特效</h3><h4 id="增加文字特效"><a href="#增加文字特效" class="headerlink" title="增加文字特效"></a>增加文字特效</h4><p>在<code>themes/matery/layout/layout.ejs</code>中，在最后增加代码如下：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span><span class="token operator">&gt;</span>    <span class="token keyword">var</span> a_idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">jQuery</span><span class="token punctuation">(</span>document<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ready</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">$</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"body"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token string">"富强"</span><span class="token punctuation">,</span> <span class="token string">"民主"</span><span class="token punctuation">,</span> <span class="token string">"文明"</span><span class="token punctuation">,</span> <span class="token string">"和谐"</span><span class="token punctuation">,</span> <span class="token string">"自由"</span><span class="token punctuation">,</span> <span class="token string">"平等"</span><span class="token punctuation">,</span> <span class="token string">"公正"</span><span class="token punctuation">,</span> <span class="token string">"法治"</span><span class="token punctuation">,</span> <span class="token string">"爱国"</span><span class="token punctuation">,</span> <span class="token string">"敬业"</span><span class="token punctuation">,</span> <span class="token string">"诚信"</span><span class="token punctuation">,</span>                              <span class="token string">"友善"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">var</span> $i <span class="token operator">=</span> <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"&lt;span/&gt;"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">text</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>a_idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            a_idx <span class="token operator">=</span> <span class="token punctuation">(</span>a_idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> a<span class="token punctuation">.</span>length<span class="token punctuation">;</span>            <span class="token keyword">var</span> x <span class="token operator">=</span> e<span class="token punctuation">.</span>pageX<span class="token punctuation">,</span>                y <span class="token operator">=</span> e<span class="token punctuation">.</span>pageY<span class="token punctuation">;</span>            $i<span class="token punctuation">.</span><span class="token function">css</span><span class="token punctuation">(</span><span class="token punctuation">{</span>                <span class="token string">"z-index"</span><span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">,</span>                <span class="token string">"top"</span><span class="token operator">:</span> y <span class="token operator">-</span> <span class="token number">20</span><span class="token punctuation">,</span>                <span class="token string">"left"</span><span class="token operator">:</span> x<span class="token punctuation">,</span>                <span class="token string">"position"</span><span class="token operator">:</span> <span class="token string">"absolute"</span><span class="token punctuation">,</span>                <span class="token string">"font-weight"</span><span class="token operator">:</span> <span class="token string">"bold"</span><span class="token punctuation">,</span>                <span class="token string">"color"</span><span class="token operator">:</span> <span class="token string">"#FF0000"</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"body"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>$i<span class="token punctuation">)</span><span class="token punctuation">;</span>            $i<span class="token punctuation">.</span><span class="token function">animate</span><span class="token punctuation">(</span><span class="token punctuation">{</span>                <span class="token string">"top"</span><span class="token operator">:</span> y <span class="token operator">-</span> <span class="token number">180</span><span class="token punctuation">,</span>                <span class="token string">"opacity"</span><span class="token operator">:</span> <span class="token number">0</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>                       <span class="token number">3000</span><span class="token punctuation">,</span>                       <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                $i<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token string">'delay()'</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">function</span> <span class="token function">delay</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">".buryit"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">removeAttr</span><span class="token punctuation">(</span><span class="token string">"onclick"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="增加爱心特效"><a href="#增加爱心特效" class="headerlink" title="增加爱心特效"></a>增加爱心特效</h4><p>在主题的<code>_config.yml</code>文件中，将<code>clicklove.enable</code>设为<code>true</code></p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">clicklove:  enable: true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210609184055104.png" alt="特效示例"></p><h3 id="动态背景科技线条"><a href="#动态背景科技线条" class="headerlink" title="动态背景科技线条"></a>动态背景科技线条</h3><p>在<code>themes/matery/layout/layout.ejs</code>文件中添加如下代码：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token operator">&lt;</span>script type<span class="token operator">=</span><span class="token string">"text/javascript"</span> color<span class="token operator">=</span><span class="token string">"122 103 238"</span> opacity<span class="token operator">=</span><span class="token string">'0.7'</span> zIndex<span class="token operator">=</span><span class="token string">"-2"</span> count<span class="token operator">=</span><span class="token string">"200"</span>src<span class="token operator">=</span><span class="token string">"//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210609184730213.png" alt="科技线特效"></p><h3 id="页面获取标题"><a href="#页面获取标题" class="headerlink" title="页面获取标题"></a>页面获取标题</h3><p>让每个页面有不同的标题</p><p>修改<code>themes\matery\layout\_partial</code>中的<code>bg-cover-content.ejs</code>文件，将第四行的div标签换为：</p><pre class="line-numbers language-ejs" data-language="ejs"><code class="language-ejs">&lt;div class="title center-align"&gt;     &lt;% if (is_home() &amp;&amp; config.subtitle &amp;&amp; config.subtitle.length &gt; 0) { %&gt;        &lt;%= config.subtitle %&gt;     &lt;% } else { %&gt;        &lt;%= page.title %&gt;     &lt;% } %&gt;&lt;/div&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><font color="red">这个有一点bug，归档页面标题无法显示，解决办法目前还没有。</font><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210609190045015.png" alt="效果图" style="zoom: 50%;"></p><h3 id="打字机效果"><a href="#打字机效果" class="headerlink" title="打字机效果"></a>打字机效果</h3><p>在主题配置文件中，按自己的心意进行配置subtitle</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"># 打字效果副标题.# 如果有符号 ‘ ，请在 ’ 前面加上 \subtitle:  enable: true  loop: true # 是否循环  showCursor: true # 是否显示光标  startDelay: 300 # 开始延迟  typeSpeed: 130 # 打字速度  backSpeed: 70 # 删除速度  sub1: 从来没有真正的绝境, 只有心灵的迷途  sub2: 即使爬到最高的山上，一次也只能脚踏实地地迈一步<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/sehowyoung/images/raw/master/%E6%89%93%E5%AD%97%E6%9C%BA%E6%95%88%E6%9E%9C%E5%9B%BE.gif" alt="打字机效果图"></p><h2 id="博客优化"><a href="#博客优化" class="headerlink" title="博客优化"></a>博客优化</h2><h3 id="gulp代码压缩"><a href="#gulp代码压缩" class="headerlink" title="gulp代码压缩"></a>gulp代码压缩</h3><blockquote><p>hexo生成的html、css、js等都有很多的空格或者换行，而空格和换行也是占用字节的，所以需要将空格换行去掉也就是我要进行的“压缩”，减小一点资源文件的大小也是对访问速度有那么一点提升的。</p></blockquote><p>在站点目录执行以下命令，安装插件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 全局安装gulp模块npm install gulp -g# 安装各种小功能模块  执行这步的时候，可能会提示权限的问题，最好以管理员模式执行npm install gulp gulp-htmlclean gulp-htmlmin gulp-minify-css gulp-uglify gulp-imagemin --save# 额外的功能模块npm install gulp-debug gulp-clean-css gulp-changed gulp-if gulp-plumber gulp-babel babel-preset-es2015 del @babel/core --save<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在Hexo根目录新建文件 gulpfile.js，并复制以下内容到文件中，有中文注释，可以根据自己需求修改。（注意：文件名不能错，一定为gulpfile.js，否则会出错！）</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> gulp <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"gulp"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> debug <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"gulp-debug"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> cleancss <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"gulp-clean-css"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//css压缩组件</span><span class="token keyword">var</span> uglify <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"gulp-uglify"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//js压缩组件</span><span class="token keyword">var</span> htmlmin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"gulp-htmlmin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//html压缩组件</span><span class="token keyword">var</span> htmlclean <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"gulp-htmlclean"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//html清理组件</span><span class="token keyword">var</span> imagemin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"gulp-imagemin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//图片压缩组件</span><span class="token keyword">var</span> changed <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"gulp-changed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//文件更改校验组件</span><span class="token keyword">var</span> gulpif <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"gulp-if"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//任务 帮助调用组件</span><span class="token keyword">var</span> plumber <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"gulp-plumber"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//容错组件（发生错误不跳出任务，并报出错误内容）</span><span class="token keyword">var</span> isScriptAll <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">//是否处理所有文件，(true|处理所有文件)(false|只处理有更改的文件)</span><span class="token keyword">var</span> isDebug <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">//是否调试显示 编译通过的文件</span><span class="token keyword">var</span> gulpBabel <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"gulp-babel"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> es2015Preset <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"babel-preset-es2015"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> del <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"del"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> Hexo <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"hexo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> hexo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Hexo</span><span class="token punctuation">(</span>process<span class="token punctuation">.</span><span class="token function">cwd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 初始化一个hexo对象</span><span class="token comment">// 清除public文件夹</span>gulp<span class="token punctuation">.</span><span class="token function">task</span><span class="token punctuation">(</span><span class="token string">"clean"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">del</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"public/**/*"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 下面几个跟hexo有关的操作，主要通过hexo.call()去执行，注意return</span><span class="token comment">// 创建静态页面 （等同 hexo generate）</span>gulp<span class="token punctuation">.</span><span class="token function">task</span><span class="token punctuation">(</span><span class="token string">"generate"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> hexo<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">hexo</span>            <span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">"generate"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>                watch<span class="token operator">:</span> <span class="token boolean">false</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> hexo<span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> hexo<span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 启动Hexo服务器</span>gulp<span class="token punctuation">.</span><span class="token function">task</span><span class="token punctuation">(</span><span class="token string">"server"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> hexo        <span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token function">hexo</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">"server"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 部署到服务器</span>gulp<span class="token punctuation">.</span><span class="token function">task</span><span class="token punctuation">(</span><span class="token string">"deploy"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> hexo<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">hexo</span>            <span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">"deploy"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>                watch<span class="token operator">:</span> <span class="token boolean">false</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> hexo<span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> hexo<span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 压缩public目录下的js文件</span>gulp<span class="token punctuation">.</span><span class="token function">task</span><span class="token punctuation">(</span><span class="token string">"compressJs"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> gulp        <span class="token punctuation">.</span><span class="token function">src</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"./public/**/*.js"</span><span class="token punctuation">,</span> <span class="token string">"!./public/libs/**"</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">//排除的js</span>        <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span><span class="token function">gulpif</span><span class="token punctuation">(</span><span class="token operator">!</span>isScriptAll<span class="token punctuation">,</span> <span class="token function">changed</span><span class="token punctuation">(</span><span class="token string">"./public"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span><span class="token function">gulpif</span><span class="token punctuation">(</span>isDebug<span class="token punctuation">,</span> <span class="token function">debug</span><span class="token punctuation">(</span><span class="token punctuation">{</span> title<span class="token operator">:</span> <span class="token string">"Compress JS:"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span><span class="token function">plumber</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>            <span class="token function">gulpBabel</span><span class="token punctuation">(</span><span class="token punctuation">{</span>                presets<span class="token operator">:</span> <span class="token punctuation">[</span>es2015Preset<span class="token punctuation">]</span> <span class="token comment">// es5检查机制</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span><span class="token function">uglify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//调用压缩组件方法uglify(),对合并的文件进行压缩</span>        <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>gulp<span class="token punctuation">.</span><span class="token function">dest</span><span class="token punctuation">(</span><span class="token string">"./public"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//输出到目标目录</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 压缩public目录下的css文件</span>gulp<span class="token punctuation">.</span><span class="token function">task</span><span class="token punctuation">(</span><span class="token string">"compressCss"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> option <span class="token operator">=</span> <span class="token punctuation">{</span>        rebase<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>        <span class="token comment">//advanced: true, //类型：Boolean 默认：true [是否开启高级优化（合并选择器等）]</span>        compatibility<span class="token operator">:</span> <span class="token string">"ie7"</span> <span class="token comment">//保留ie7及以下兼容写法 类型：String 默认：''or'*' [启用兼容模式； 'ie7'：IE7兼容模式，'ie8'：IE8兼容模式，'*'：IE9+兼容模式]</span>        <span class="token comment">//keepBreaks: true, //类型：Boolean 默认：false [是否保留换行]</span>        <span class="token comment">//keepSpecialComments: '*' //保留所有特殊前缀 当你用autoprefixer生成的浏览器前缀，如果不加这个参数，有可能将会删除你的部分前缀</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> gulp        <span class="token punctuation">.</span><span class="token function">src</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"./public/**/*.css"</span><span class="token punctuation">,</span> <span class="token string">"!./public/**/*.min.css"</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">//排除的css</span>        <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span><span class="token function">gulpif</span><span class="token punctuation">(</span><span class="token operator">!</span>isScriptAll<span class="token punctuation">,</span> <span class="token function">changed</span><span class="token punctuation">(</span><span class="token string">"./public"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span><span class="token function">gulpif</span><span class="token punctuation">(</span>isDebug<span class="token punctuation">,</span> <span class="token function">debug</span><span class="token punctuation">(</span><span class="token punctuation">{</span> title<span class="token operator">:</span> <span class="token string">"Compress CSS:"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span><span class="token function">plumber</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span><span class="token function">cleancss</span><span class="token punctuation">(</span>option<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>gulp<span class="token punctuation">.</span><span class="token function">dest</span><span class="token punctuation">(</span><span class="token string">"./public"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 压缩public目录下的html文件</span>gulp<span class="token punctuation">.</span><span class="token function">task</span><span class="token punctuation">(</span><span class="token string">"compressHtml"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> cleanOptions <span class="token operator">=</span> <span class="token punctuation">{</span>        protect<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">&lt;\!--%fooTemplate\b.*?%--&gt;</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">,</span> <span class="token comment">//忽略处理</span>        unprotect<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">&lt;script [^&gt;]*\btype="text\/x-handlebars-template"[\s\S]+?&lt;\/script&gt;</span><span class="token regex-delimiter">/</span><span class="token regex-flags">gi</span></span> <span class="token comment">//特殊处理</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> minOption <span class="token operator">=</span> <span class="token punctuation">{</span>        collapseWhitespace<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">//压缩HTML</span>        collapseBooleanAttributes<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">//省略布尔属性的值 &lt;input checked="true"/&gt; ==&gt; &lt;input /&gt;</span>        removeEmptyAttributes<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">//删除所有空格作属性值 &lt;input id="" /&gt; ==&gt; &lt;input /&gt;</span>        removeScriptTypeAttributes<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">//删除&lt;script&gt;的type="text/javascript"</span>        removeStyleLinkTypeAttributes<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">//删除&lt;style&gt;和&lt;link&gt;的type="text/css"</span>        removeComments<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">//清除HTML注释</span>        minifyJS<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">//压缩页面JS</span>        minifyCSS<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">//压缩页面CSS</span>        minifyURLs<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token comment">//替换页面URL</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> gulp        <span class="token punctuation">.</span><span class="token function">src</span><span class="token punctuation">(</span><span class="token string">"./public/**/*.html"</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span><span class="token function">gulpif</span><span class="token punctuation">(</span>isDebug<span class="token punctuation">,</span> <span class="token function">debug</span><span class="token punctuation">(</span><span class="token punctuation">{</span> title<span class="token operator">:</span> <span class="token string">"Compress HTML:"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span><span class="token function">plumber</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span><span class="token function">htmlclean</span><span class="token punctuation">(</span>cleanOptions<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span><span class="token function">htmlmin</span><span class="token punctuation">(</span>minOption<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>gulp<span class="token punctuation">.</span><span class="token function">dest</span><span class="token punctuation">(</span><span class="token string">"./public"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 压缩 public/medias 目录内图片</span>gulp<span class="token punctuation">.</span><span class="token function">task</span><span class="token punctuation">(</span><span class="token string">"compressImage"</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> option <span class="token operator">=</span> <span class="token punctuation">{</span>        optimizationLevel<span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token comment">//类型：Number 默认：3 取值范围：0-7（优化等级）</span>        progressive<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">//类型：Boolean 默认：false 无损压缩jpg图片</span>        interlaced<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token comment">//类型：Boolean 默认：false 隔行扫描gif进行渲染</span>        multipass<span class="token operator">:</span> <span class="token boolean">false</span> <span class="token comment">//类型：Boolean 默认：false 多次优化svg直到完全优化</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> gulp        <span class="token punctuation">.</span><span class="token function">src</span><span class="token punctuation">(</span><span class="token string">"./public/medias/**/*.*"</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span><span class="token function">gulpif</span><span class="token punctuation">(</span><span class="token operator">!</span>isScriptAll<span class="token punctuation">,</span> <span class="token function">changed</span><span class="token punctuation">(</span><span class="token string">"./public/medias"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span><span class="token function">gulpif</span><span class="token punctuation">(</span>isDebug<span class="token punctuation">,</span> <span class="token function">debug</span><span class="token punctuation">(</span><span class="token punctuation">{</span> title<span class="token operator">:</span> <span class="token string">"Compress Images:"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span><span class="token function">plumber</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span><span class="token function">imagemin</span><span class="token punctuation">(</span>option<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>gulp<span class="token punctuation">.</span><span class="token function">dest</span><span class="token punctuation">(</span><span class="token string">"./public"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 执行顺序： 清除public目录 -&gt; 产生原始博客内容 -&gt; 执行压缩混淆 -&gt; 部署到服务器</span>gulp<span class="token punctuation">.</span><span class="token function">task</span><span class="token punctuation">(</span>    <span class="token string">"build"</span><span class="token punctuation">,</span>    gulp<span class="token punctuation">.</span><span class="token function">series</span><span class="token punctuation">(</span>        <span class="token string">"clean"</span><span class="token punctuation">,</span>        <span class="token string">"generate"</span><span class="token punctuation">,</span>        <span class="token string">"compressHtml"</span><span class="token punctuation">,</span>        <span class="token string">"compressCss"</span><span class="token punctuation">,</span>        <span class="token string">"compressJs"</span><span class="token punctuation">,</span>        gulp<span class="token punctuation">.</span><span class="token function">parallel</span><span class="token punctuation">(</span><span class="token string">"deploy"</span><span class="token punctuation">)</span>    <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 默认任务</span>gulp<span class="token punctuation">.</span><span class="token function">task</span><span class="token punctuation">(</span>    <span class="token string">"default"</span><span class="token punctuation">,</span>    gulp<span class="token punctuation">.</span><span class="token function">series</span><span class="token punctuation">(</span>        <span class="token string">"clean"</span><span class="token punctuation">,</span>        <span class="token string">"generate"</span><span class="token punctuation">,</span>        gulp<span class="token punctuation">.</span><span class="token function">parallel</span><span class="token punctuation">(</span><span class="token string">"compressHtml"</span><span class="token punctuation">,</span> <span class="token string">"compressCss"</span><span class="token punctuation">,</span> <span class="token string">"compressJs"</span><span class="token punctuation">)</span>    <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//Gulp4最大的一个改变就是gulp.task函数现在只支持两个参数，分别是任务名和运行任务的函数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：这里我去掉了图片的压缩，如果想要加上可以在第154行加上 “compressImage”, 和第165行的加上”compressImage” 即可</p></blockquote><p>使用（两种方式）：</p><ul><li>直接在Hexo根目录执行 gulp，这个命令相当于 hexo cl&amp;&amp;hexo g 并且再把代码压缩，再hexo s进行部署即可</li><li>在Hexo根目录执行 gulp build ，这个命令与第1种相比是：在最后又加了个 hexo d ，等于说生成、压缩文件后又帮你自动部署了</li></ul><h3 id="新建文章自动打开本地Markdown编辑器"><a href="#新建文章自动打开本地Markdown编辑器" class="headerlink" title="新建文章自动打开本地Markdown编辑器"></a>新建文章自动打开本地Markdown编辑器</h3><blockquote><p>写新文章时，需要控制台执行hexo new “文章名字”生成一篇新文章，但需要手动打开，挺麻烦，我们可以设置在生成之后自动打开</p></blockquote><p>在站点根目录下新建scripts目录，然后在新建<code>auto_open.js</code>，在文件填入一下内容：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> spawn <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'child_process'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>exec<span class="token punctuation">;</span><span class="token comment">// Hexo 2.x 用户复制这段</span><span class="token comment">//hexo.on('new', function(path){</span>  <span class="token comment">//spawn('start  "markdown编辑器绝对路径.exe" ' + path);</span><span class="token comment">//});</span><span class="token comment">// Hexo 3 用户复制这段</span>hexo<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'new'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token function">spawn</span><span class="token punctuation">(</span><span class="token string">'start  "D:\program\typora\Typora\Typora.exe" '</span> <span class="token operator">+</span> data<span class="token punctuation">.</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>其中”D:\program\typora\Typora\Typora.exe”是我本地编辑器的路径，只需要改为你本地编辑器的路径即可，然后在执行<code>hexo cl &amp;&amp; hexo g -d</code>，部署到GitHub即可，以后在发布文章就会自动打开编辑器。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为使用matery主题的hexo增加Valine评论系统</title>
      <link href="/posts/16606.html"/>
      <url>/posts/16606.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文参考<a href="https://fenghen0918.github.io/2020/06/19/hexo/matery-zhu-ti-valine-ping-lun-xi-tong/">matery主题+Valine评论系统</a></p></blockquote><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>上篇博客讲述了如何对hexo+GitHub的博客系统进行一些配置，由于配置评论系统较为复杂，故单独写本篇博客来记录如何为使用matery主题的hexo博客系统增加评论系统</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>由于本站博客系统使用的是<a href="https://console.leancloud.cn/">LeanCloud</a>提供的，因此先打开官网进行<a href="https://leancloud.cn/dashboard/login.html#/signup">注册</a>。</p><p>注册完成后直接选择创建应用，应用名称随便填，方案选择开发版，点击创建即可。</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210609162216842.png" alt="创建应用"></p><p>创建完成后，点击设置</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210609162337837.png" alt="进入设置"></p><p>我们需要用到AppID和AppKey。</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210609162431565.png" alt="获取AppID和AppKey"></p><h2 id="配置评论系统"><a href="#配置评论系统" class="headerlink" title="配置评论系统"></a>配置评论系统</h2><p>在matery主题的配置文件<code>_config.yml</code>中，创建Valine属性：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"># Valine 评论模块的配置，默认为不激活，如要使用，就请激活该配置项，并设置 appId 和 appKey.valine:  enable: true   appId: 你的AppID  appKey: 你的AppKey  pageSize: 10                # 每页显示条数  avatar: monsterid           # 默认头像  lang: zh-CN   placeholder: 昵称填写qq可以显示qq头像和昵称哦~   # 提示信息  guest_info: nick,mail,link   recordIP: true   serverURLs: ''   background: /medias/comment_bg.png               # 背景图片  count: true <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="管理评论"><a href="#管理评论" class="headerlink" title="管理评论"></a>管理评论</h2><p>进入<a href="https://console.leancloud.cn/apps">LeanCloud</a>，点击<code>数据存储</code>，选择<code>Comment</code>，然后你就可以操作数据了</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/%E5%88%A0%E9%99%A4%E8%AF%84%E8%AE%BA.gif" alt="删除评论"></p><h2 id="增强Valine系统"><a href="#增强Valine系统" class="headerlink" title="增强Valine系统"></a>增强Valine系统</h2><h3 id="更换Valine的版本"><a href="#更换Valine的版本" class="headerlink" title="更换Valine的版本"></a>更换Valine的版本</h3><p>在matery配置页面，找到libs.js.valine，将其设置为<code>valine: https://unpkg.com/valine/dist/Valine.min.js</code></p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210609164616769.png" alt="更改valine的版本"></p><h3 id="更换表情"><a href="#更换表情" class="headerlink" title="更换表情"></a>更换表情</h3><p>打开<code>themes\matery\layout\_partial</code>中找到<code>valine.ejs</code>，找到其中的<code>new Valine</code>，大概在249行，修改为以下内容：</p><pre class="line-numbers language-ejs" data-language="ejs"><code class="language-ejs">new Valine({        el: '#vcomments',        appId: '&lt;%- theme.valine.appId %&gt;',        appKey: '&lt;%- theme.valine.appKey %&gt;',        notify: '&lt;%- theme.valine.notify %&gt;' === 'true',        verify: '&lt;%- theme.valine.verify %&gt;' === 'true',        visitor: '&lt;%- theme.valine.visitor %&gt;' === 'true',        avatar: '&lt;%- theme.valine.avatar %&gt;',        pageSize: '&lt;%- theme.valine.pageSize %&gt;',        lang: '&lt;% if (config.language == "zh-CN") {  %&gt;zh-cn&lt;% } else { %&gt;en&lt;% } %&gt;',        placeholder: '&lt;%= theme.valine.placeholder %&gt;',        enableQQ: true,        emojiCDN: '//i0.hdslb.com/bfs/emote/',         // 表情title和图片映射        emojiMaps: {        "tv_doge": "6ea59c827c414b4a2955fe79e0f6fd3dcd515e24.png",        "tv_亲亲": "a8111ad55953ef5e3be3327ef94eb4a39d535d06.png",        "tv_偷笑": "bb690d4107620f1c15cff29509db529a73aee261.png",        "tv_再见": "180129b8ea851044ce71caf55cc8ce44bd4a4fc8.png",        "tv_冷漠": "b9cbc755c2b3ee43be07ca13de84e5b699a3f101.png",        "tv_发怒": "34ba3cd204d5b05fec70ce08fa9fa0dd612409ff.png",        "tv_发财": "34db290afd2963723c6eb3c4560667db7253a21a.png",        "tv_可爱": "9e55fd9b500ac4b96613539f1ce2f9499e314ed9.png",        "tv_吐血": "09dd16a7aa59b77baa1155d47484409624470c77.png",        "tv_呆": "fe1179ebaa191569b0d31cecafe7a2cd1c951c9d.png",        "tv_呕吐": "9f996894a39e282ccf5e66856af49483f81870f3.png",        "tv_困": "241ee304e44c0af029adceb294399391e4737ef2.png",        "tv_坏笑": "1f0b87f731a671079842116e0991c91c2c88645a.png",        "tv_大佬": "093c1e2c490161aca397afc45573c877cdead616.png",        "tv_大哭": "23269aeb35f99daee28dda129676f6e9ea87934f.png",        "tv_委屈": "d04dba7b5465779e9755d2ab6f0a897b9b33bb77.png",        "tv_害羞": "a37683fb5642fa3ddfc7f4e5525fd13e42a2bdb1.png",        "tv_尴尬": "7cfa62dafc59798a3d3fb262d421eeeff166cfa4.png",        "tv_微笑": "70dc5c7b56f93eb61bddba11e28fb1d18fddcd4c.png",        "tv_思考": "90cf159733e558137ed20aa04d09964436f618a1.png",        "tv_惊吓": "0d15c7e2ee58e935adc6a7193ee042388adc22af.png",        "tv_打脸": "56ab10b624063e966bfcb76ea5dc4794d87dfd47.png",        "tv_抓狂": "fe31c08edad661d63762b04e17b8d5ae3c71a757.png",        "tv_抠鼻": "c666f55e88d471e51bbd9fab9bb308110824a6eb.png",        "tv_斜眼笑": "911f987aa8bc1bee12d52aafe62bc41ef4474e6c.png",        "tv_无奈": "ea8ed89ee9878f2fece2dda0ea8a5dbfe21b5751.png",        "tv_晕": "5443c22b4d07fb1907ccc610c8e6db254f2461b7.png",        "tv_流汗": "cead1c351ab8d79e9f369605beb90148db0fbed3.png",        "tv_流泪": "7e71cde7858f0cd50d74b0264aa26db612a8a167.png",        "tv_流鼻血": "c32d39db2737f89b904ca32700d140a9241b0767.png",        "tv_点赞": "f85c354995bd99e28fc76c869bfe42ba6438eff4.png",        "tv_生气": "26702dcafdab5e8225b43ffd23c94ac1ff932654.png",        "tv_生病": "8b0ec90e6b86771092a498c54f09fc94621c1900.png",        "tv_疑问": "0793d949b18d7be716078349c202c15ff166f314.png",        "tv_白眼": "c1d59f439e379ee50eef488bcb5e5378e5044ea4.png",        "tv_皱眉": "72ccad6679fea0d14cce648b4d818e09b8ffea2d.png",        "tv_目瞪口呆": "0b8cb81a68de5d5365212c99375e7ace3e7891b7.png",        "tv_睡着": "8b196675b53af58264f383c50ad0945048290b33.png",        "tv_笑哭": "1abc628f6d4f4caf9d0e7800878f4697abbc8273.png",        "tv_腼腆": "89712c0d4af73e67f89e35cbc518420380a7f6f4.png",        "tv_色": "61822c7e9aae5da76475e7892534545336b23a6f.png",        "tv_调侃": "4bc022533ef31544ca0d72c12c808cf4a1cce3e3.png",        "tv_调皮": "b9c41de8e82dd7a8515ae5e3cb63e898bf245186.png",        "tv_鄙视": "6e72339f346a692a495b123174b49e4e8e781303.png",        "tv_闭嘴": "c9e990da7f6e93975e25fd8b70e2e290aa4086ef.png",        "tv_难过": "87f46748d3f142ebc6586ff58860d0e2fc8263ba.png",        "tv_馋": "fc7e829b845c43c623c8b490ee3602b7f0e76a31.png",        "tv_鬼脸": "0ffbbddf8a94d124ca2f54b360bbc04feb6bbfea.png",        "tv_黑人问号": "45821a01f51bc867da9edbaa2e070410819a95b2.png",        "tv_鼓掌": "1d21793f96ef4e6f48b23e53e3b9e42da833a0f6.png"        },        requiredFields: ['nick','mail'], //设置必填项    });<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重新部署查看</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo clean &amp; hexo g -d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210609165023460.png" alt="评论板块界面"></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo+GitHub个人主页更换主题</title>
      <link href="/posts/38798.html"/>
      <url>/posts/38798.html</url>
      
        <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>上一篇博客我为大家介绍了如何使用hexo+GitHub搭建个人博客，本片我将记录我如何更换hexo的主题matery。</p><h2 id="主题的下载与切换"><a href="#主题的下载与切换" class="headerlink" title="主题的下载与切换"></a>主题的下载与切换</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>hexo主题的官网：<a href="https://hexo.io/themes/">https://hexo.io/themes/</a></p><p>matery主题官网：<a href="https://github.com/blinkfox/hexo-theme-matery">https://github.com/blinkfox/hexo-theme-matery</a></p><p>可以在官网的release里面下载，也可以使用<code>git clone https://github.com/blinkfox/hexo-theme-matery.git</code>下载，将下载的文件夹放到博客文件夹下的themes下。</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210609110153569.png" alt="themes文件夹"></p><h3 id="切换"><a href="#切换" class="headerlink" title="切换"></a>切换</h3><p>在博客文件夹下，打开<code>_config.yml</code>文件，将<code>theme</code>设置为你的主题名字。</p><h2 id="主题的配置"><a href="#主题的配置" class="headerlink" title="主题的配置"></a>主题的配置</h2><h3 id="增加页面"><a href="#增加页面" class="headerlink" title="增加页面"></a>增加页面</h3><p>增加tags标签页、categories分类页、about关于我页面、contact留言板页。</p><h4 id="新建分类-categories-页"><a href="#新建分类-categories-页" class="headerlink" title="新建分类 categories 页"></a>新建分类 categories 页</h4><p><code>categories</code> 页是用来展示所有分类的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>categories/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page "categories"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/categories/index.md</code>，至少需要以下内容：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">---title: categoriesdate: 2021-06-8 17:25:30type: "categories"layout: "categories"---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="新建标签-tags-页"><a href="#新建标签-tags-页" class="headerlink" title="新建标签 tags 页"></a>新建标签 tags 页</h4><p><code>tags</code> 页是用来展示所有标签的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>tags/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page "tags"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/tags/index.md</code>，至少需要以下内容：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">---title: tagsdate: 2021-06-8 17:23:38type: "tags"layout: "tags"---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="新建关于我-about-页"><a href="#新建关于我-about-页" class="headerlink" title="新建关于我 about 页"></a>新建关于我 about 页</h4><p><code>about</code> 页是用来展示<strong>关于我和我的博客</strong>信息的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>about/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page "about"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/about/index.md</code>，至少需要以下内容：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">---title: aboutdate: 2021-06-8 17:25:30type: "about"layout: "about"---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="新建留言板-contact-页"><a href="#新建留言板-contact-页" class="headerlink" title="新建留言板 contact 页"></a>新建留言板 contact 页</h4><p><code>contact</code> 页是用来展示<strong>留言板</strong>信息的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>contact/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page "contact"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/contact/index.md</code>，至少需要以下内容：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">---title: contactdate: 2021-06-8 17:25:30type: "contact"layout: "contact"---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>注</strong>：本留言板功能依赖于第三方评论系统，请<strong>激活</strong>你的评论系统才有效果。并且在主题的 <code>_config.yml</code> 文件中，第 <code>19</code> 至 <code>21</code> 行的“<strong>菜单</strong>”配置，取消关于留言板的注释即可。</p></blockquote><h4 id="新建-404-页"><a href="#新建-404-页" class="headerlink" title="新建 404 页"></a>新建 404 页</h4><p>如果在你的博客 <code>source</code> 目录下还没有 <code>404.md</code> 文件，那么你就需要新建一个</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo new page 404<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编辑你刚刚新建的页面文件 <code>/source/404/index.md</code>，至少需要以下内容：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">---title: 404date: 2021-06-8 17:25:30type: "404"layout: "404"description: "Oops～，我崩溃了！找不到你想要的页面 :("---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="增加emoji支持"><a href="#增加emoji支持" class="headerlink" title="增加emoji支持"></a>增加emoji支持</h3><p>:smile：使你的markdown博客里的emoji表情跳动起来</p><p>安装插件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm install hexo-filter-github-emojis --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在博客文件夹下增加下面配置：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">githubEmojis:  enable: true  className: github-emoji  inject: true  styles:  customEmojis:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210609113107377.png" alt="emoji表情示例"></p><h3 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h3><p>由于 Hexo 自带的代码高亮主题不好看，所以我们采用一个插件来代替它。</p><p>使用<code>npm i -S hexo-prism-plugin</code>来安装插件</p><p>打开项目文件夹下的<code>_config.yml</code>，将 highlight.enable 的值改为 false ，新增下面的代码。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">prism_plugin:  mode: 'preprocess'    # realtime/preprocess  theme: 'tomorrow'  line_number: false    # default false  custom_css:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="搜索功能"><a href="#搜索功能" class="headerlink" title="搜索功能"></a>搜索功能</h3><p>我们使用 <a href="https://github.com/wzpan/hexo-generator-search">hexo-generator-search</a> 的 Hexo 插件来做内容搜索，安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm install hexo-generator-search --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">search:  path: search.xml  field: post<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="中文链接转拼音"><a href="#中文链接转拼音" class="headerlink" title="中文链接转拼音"></a>中文链接转拼音</h3><p>如果你的文章名称是中文的，那么 Hexo 默认生成的永久链接也会有中文，这样不利于 <code>SEO</code>，且 <code>gitment</code> 评论对中文链接也不支持。我们可以用 <a href="https://github.com/viko16/hexo-permalink-pinyin">hexo-permalink-pinyin</a> Hexo 插件使在生成文章时生成中文拼音的永久链接。</p><p>安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm i hexo-permalink-pinyin --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">permalink_pinyin:  enable: true  separator: '-' # default: '-'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="文章字数统计"><a href="#文章字数统计" class="headerlink" title="文章字数统计"></a>文章字数统计</h3><p>为了在文章中显示文章字数、阅读时长信息，可以安装 <a href="https://github.com/willin/hexo-wordcount">hexo-wordcount</a>插件。</p><p>安装命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm i --save hexo-wordcount<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后只需在本主题下的 <code>_config.yml</code> 文件中，将各个文章字数相关的配置激活即可：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"># 文章信息--若要开启文章字数统计，需要安装 hexo-wordcount 插件，安装命令: `npm i --save hexo-wordcount`postInfo:  date: true # 发布日期  update: false # 更新日期  wordCount: true # 文章字数统计  totalCount: false # 站点总文章字数  min2read: true # 文章阅读时长  readCount: true # 文章阅读次数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="配置音乐播放器"><a href="#配置音乐播放器" class="headerlink" title="配置音乐播放器"></a>配置音乐播放器</h3><p>要支持音乐播放，在主题的 <code>_config.yml</code> 配置文件中激活music配置即可：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"># 音乐music:  enable: true  title:         # 非吸底模式有效    enable: true    show: 听听音乐放松一下吧  server: netease   # require music platform: netease, tencent, kugou, xiami, baidu  type: playlist    # require song, playlist, album, search, artist  id: 2799574927     # require song id / playlist id / album id / search keyword  fixed: false      # 开启吸底模式  autoplay: true   # 是否自动播放  theme: '#42b983'  loop: 'all'       # 音频循环播放, 可选值: 'all', 'one', 'none'  order: 'random'   # 音频循环顺序, 可选值: 'list', 'random'  preload: 'auto'   # 预加载，可选值: 'none', 'metadata', 'auto'  volume: 0.7       # 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效  listFolded: false  # 列表默认折叠  hideLrc: true     # 隐藏歌词<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>属性介绍：</p><ol><li><p><code>server</code>可选<code>netease</code>（网易云音乐），<code>tencent</code>（QQ音乐），<code>kugou</code>（酷狗音乐），<code>xiami</code>（虾米音乐），<code>baidu</code>（百度音乐）。</p></li><li><p><code>type</code>可选<code>song</code>（歌曲），<code>playlist</code>（歌单），<code>album</code>（专辑），<code>search</code>（搜索关键字），<code>artist</code>（歌手）</p></li><li><p><code>id</code>获取方法示例: 浏览器打开网易云音乐，点击我喜欢的音乐歌单，浏览器地址栏后面会有一串数字，<code>playlist</code>的<code>id</code>即为这串数字。</p></li></ol></blockquote><h3 id="修改公告-dream一栏-里的每日一句"><a href="#修改公告-dream一栏-里的每日一句" class="headerlink" title="修改公告(dream一栏)里的每日一句"></a>修改公告(dream一栏)里的每日一句</h3><p>找到<code>/themes/matery/layout/index.ejs</code>，第17行改为：</p><pre class="line-numbers language-ejs" data-language="ejs"><code class="language-ejs">&lt;% if (theme.dream.enable) { %&gt;  &lt;!-- &lt;%- partial('_widget/dream') %&gt; --&gt;  &lt;i class="fa fa-volume-up fa-lg fa-fw text-color"&gt;&lt;/i&gt; &lt;%- '&lt;span id="hitokoto"&gt;一言API请求超时。请稍后重试。&lt;/span&gt; （来源：一言API）' %&gt;&lt;% } %&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>同时在<code>/themes/matery/layout/_partial/head.ejs</code>增加代码：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"https://v1.hitokoto.cn/?c=d&amp;encode=js&amp;select=%23hitokoto"</span> defer<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+GitHub搭建个人博客</title>
      <link href="/posts/48892.html"/>
      <url>/posts/48892.html</url>
      
        <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>本篇博客技术了如何使用hexo+GitHub搭建个人博客。gitee至今年五月开始休整个人主页，暂时无法搭建。</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><p>git下载地址：<a href="https://git-scm.com/downloads">Git - Downloads (git-scm.com)</a></p><p>验证git是否安装完成：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">git --version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>出现下面的信息即安装完成。</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210608225744230.png" alt="查看git是否安装成功"></p><h3 id="安装node"><a href="#安装node" class="headerlink" title="安装node"></a>安装node</h3><p>node.js下载地址：<a href="https://nodejs.org/zh-cn/download/">下载 | Node.js (nodejs.org)</a></p><p>验证node是否安装成功</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">node -v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>出现下面的信息即代表安装完成：</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210608230136589.png" alt="产看node是否安装成功"></p><h3 id="GitHub仓库"><a href="#GitHub仓库" class="headerlink" title="GitHub仓库"></a>GitHub仓库</h3><p>创建一个GitHub的账号，当然gitee也可以。</p><p>GitHub地址：<a href="https://github.com/">https://github.com/</a></p><p>Gitee地址：<a href="https://gitee.com/">https://gitee.com/</a></p><p>在注册好以后创建一个新仓库</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210609085515819.png" alt="新建仓库"></p><p>仓库名构成为：用户名.github.io</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210609085818668.png" alt="创建仓库"></p><h2 id="安装hexo并且本地运行"><a href="#安装hexo并且本地运行" class="headerlink" title="安装hexo并且本地运行"></a>安装hexo并且本地运行</h2><p>创建一个文件夹，用于存放你的博客</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">//切换到所在磁盘位置e://切换到文件夹位置cd myBlog<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>安装hexo-cli脚手架</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm install -g hexo-cli<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>用<code>hexo -v</code>验证hexo-cli脚手架是否安装完成</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210609090103875.png" alt="查看hexo版本"></p><p>使用<code>hexo init</code>初始化网站，如果报错或者安装不成功，就去<a href="https://github.com/hexojs/hexo-starter">hexojs/hexo-starter(github.com)</a>将代码下载下来，放到你的目录下。</p><p>然后进入网站所在文件夹，执行<code>npm install</code>命令，安装必备的组件。完成安装后，页面结构如图所示</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">.├── _config.yml # 网站的配置信息，您可以在此配置大部分的参数。 ├── package.json├── node_modules # 组件所在文件夹├── scaffolds # 模版文件夹├── source  # 资源文件夹，除 _posts 文件，其他以下划线_开头的文件或者文件夹不会被编译打包到public文件夹|   ├── _drafts # 草稿文件|   └── _posts # 文章Markdowm文件 └── themes  # 主题文件夹<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用<code>hexo g</code>即可生成静态网页，可在public里面找到。然后运行<code>hexo s</code>打开本地服务器，就可以查看，这是我更换主题matery后的界面，具体后面会写。</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210609091349215.png" alt="静态主页"></p><h2 id="连接GitHub与本地git"><a href="#连接GitHub与本地git" class="headerlink" title="连接GitHub与本地git"></a>连接GitHub与本地git</h2><h3 id="配置ssh-key"><a href="#配置ssh-key" class="headerlink" title="配置ssh key"></a>配置ssh key</h3><p>右击鼠标，选中<code>Git Bash Here</code>，打开git界面，开始配置ssh key。</p><p>输入<code>ssh-keygen -t rsa -C '你的邮箱'</code></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ssh-keygen -t rsa -C 'howyoung525@foxmail.com'Generating public/private rsa key pair.Enter file in which to save the key (/c/Users/84661/.ssh/id_rsa): 可以在此输入你的文件保存地址，默认为~/.ssh/id_rsa,建议换成~/.ssh/id_rsa.githubEnter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in /c/Users/84661/.ssh/id_rsaYour public key has been saved in /c/Users/84661/.ssh/id_rsa.pubThe key fingerprint is:SHA256:oFnXNTgDePDBcW6j2xp9mTpbheokQ0JjM+3nLvtxqfA howyoung525@foxmail.comThe key's randomart image is:+---[RSA 3072]----+|      .++o..o    ||      .oo=+. .   ||      O.+ =o     ||     * B o . .   ||    o . S . . .  ||       o * . =   ||        * B B    ||        .@.B     ||        o+Eo     |+----[SHA256]-----+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输入命令<code>cat ~/.ssh/id_rsa.github.pub</code>，查看公钥文件，然后选中，右击复制。</p><p>打开你的GitHub，点击右上角头像旁边的倒三角，选择<code>settings</code>，在点击<code>SSH adn GPG keys</code>，点击<code>new</code>，在页面里添加title和key，title可以随意写，key把公钥文件内容粘贴进去即可。</p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://gitee.com/sehowyoung/images/raw/master/%E9%85%8D%E7%BD%AE.gif" alt="git与GitHub连接配置"></h2><h3 id="配置本地账户"><a href="#配置本地账户" class="headerlink" title="配置本地账户"></a>配置本地账户</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">git config --global user.name '你的用户名'git config --global user.email '你的邮箱'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="测试连接"><a href="#测试连接" class="headerlink" title="测试连接"></a>测试连接</h3><p>使用<code>ssh -T git@github.com</code>来测试是否成功，出现下面信息即成功（第一会让输入yes）</p><p><img src="https://gitee.com/sehowyoung/images/raw/master/image-20210609094359872.png" alt="测试连接"></p><h2 id="部署到GitHub"><a href="#部署到GitHub" class="headerlink" title="部署到GitHub"></a>部署到GitHub</h2><p>安装插件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm install hexo-deployer-git --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>打开文件夹下面的<code>_config.yml</code>文件，找到最下面的<code>delpoy</code>，修改配置为：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">deploy:  type: git  repository:    github: git@github.com:你的GitHub用户名/用户名.github.io.git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>使用<code>hexo g -d</code>生成静态文件并上传。</p><p>稍等一会，便可以在浏览器访问<code>https://你的用户名.github.io</code>，即可看见你的博客了。</p><p>此外，最好将<code>_config.yml</code>文件最前端的6-12行进行修改：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"># Sitetitle: howyoung's blogsubtitle: howyoung's blogdescription: 'howyoung 的博客'keywords: blog 博客 howyoungauthor: howyounglanguage: zh-CNtimezone: Asia/Shanghaiurl: https://sehowyoung.github.io/per_page: 建议改为6的倍数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
