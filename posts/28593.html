<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>软件工程考试要点 | howyoung's blog</title><meta name="keywords" content="944 软件工程"><meta name="author" content="howyoung,howyoung525@foxmail.com"><meta name="copyright" content="howyoung"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="944软件工程考试总结"><meta property="og:type" content="article"><meta property="og:title" content="软件工程考试要点"><meta property="og:url" content="https://blog.howyoung.work/posts/28593.html"><meta property="og:site_name" content="howyoung&#39;s blog"><meta property="og:description" content="944软件工程考试总结"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://gitee.com/sehowyoung/images/raw/master/202108262332281.jpeg"><meta property="article:published_time" content="2021-11-18T15:14:51.000Z"><meta property="article:modified_time" content="2021-11-23T16:56:35.792Z"><meta property="article:author" content="howyoung"><meta property="article:tag" content="笔记"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://gitee.com/sehowyoung/images/raw/master/202108262332281.jpeg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://blog.howyoung.work/posts/28593"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""><link rel="preconnect" href="//hm.baidu.com"><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="google-site-verification" content="howyoung's blog"><meta name="baidu-site-verification" content="howyoung's blog"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?b6cbf2f58ef12084a9aa3a61aea3264a";var a=document.getElementsByTagName("script")[0];a.parentNode.insertBefore(e,a)}()</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-Q09DVCSSMV"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-Q09DVCSSMV")</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"prismjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":100,"languages":{"author":"作者: howyoung","link":"链接: ","source":"来源: howyoung's blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"软件工程考试要点",isPost:!0,isHome:!1,isHighlightShrink:void 0,isToc:!0,postUpdate:"2021-11-24 00:56:35"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/self/material-oceanic.css"><meta name="generator" content="Hexo 5.4.0"><style>.github-emoji{position:relative;display:inline-block;width:1.2em;min-height:1.2em;overflow:hidden;vertical-align:top;color:transparent}.github-emoji>span{position:relative;z-index:10}.github-emoji .fancybox,.github-emoji img{margin:0!important;padding:0!important;border:none!important;outline:0!important;text-decoration:none!important;user-select:none!important;cursor:auto!important}.github-emoji img{height:1.2em!important;width:1.2em!important;position:absolute!important;left:50%!important;top:50%!important;transform:translate(-50%,-50%)!important;user-select:none!important;cursor:auto!important}.github-emoji-fallback{color:inherit}.github-emoji-fallback img{opacity:0!important}</style><link rel="stylesheet" href="/css/prism-tomorrow.css"><link rel="stylesheet" href="/css/prism-line-numbers.css"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/avatar.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">27</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">27</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友情链接</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://gitee.com/sehowyoung/images/raw/master/202108262332281.jpeg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">howyoung's blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友情链接</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">软件工程考试要点</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-11-18T15:14:51.000Z" title="发表于 2021-11-18 23:14:51">2021-11-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-11-23T16:56:35.792Z" title="更新于 2021-11-24 00:56:35">2021-11-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/">软件工程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">36.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>108分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="软件工程考试要点"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h1><h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><h2 id="Ⅰ-考试形式和试卷结构"><a href="#Ⅰ-考试形式和试卷结构" class="headerlink" title="Ⅰ 考试形式和试卷结构"></a>Ⅰ 考试形式和试卷结构</h2><ol><li><p>试卷满分及考试时间<br>本试卷满分为150分，考试时间为180分钟</p></li><li><p>答題方式<br>答题方式为闭卷，笔试。</p></li><li><p>试卷内容结构</p><p>| 内容 | 占比 |<br>| ————————————— | ——- |<br>| 软件工程基本概念与过程模型 | 约5% |<br>| 可行性研究与项目计划 | 约5% |<br>| 软件分析与设计 | 约55% |<br>| 软件验证 | 约23% |<br>| 软件维护 | 约2% |<br>| 软件质量保证 | 约10% |</p></li><li><p>试题结构</p></li></ol><div class="table-container"><table><thead><tr><th>题型</th><th>分值</th></tr></thead><tbody><tr><td>填空题</td><td>30分（一空一分）</td></tr><tr><td>选择题</td><td>20分（每题2分）</td></tr><tr><td>简答题</td><td>30分（6题，每题5分）</td></tr><tr><td>分析设计题</td><td>50分（2题，每题25分）</td></tr><tr><td>综合题</td><td>20分（2题，每题10分）</td></tr></tbody></table></div><h2 id="Ⅱ-考察内容"><a href="#Ⅱ-考察内容" class="headerlink" title="Ⅱ 考察内容"></a>Ⅱ 考察内容</h2><ol><li>软件工程基本概念与过程模型<ol><li>软件工程的产生</li><li>软件工程的研究对象与基本原理</li><li>软件开发方法</li><li>软件工程工具和环境</li><li>软件生存期过程</li><li>软件工程常用生存周期模型</li><li>软件文档</li><li>敏捷软件开发</li></ol></li><li>可行性研究与项目计划<ol><li>系统分析</li><li>成本估计</li><li>效益分析</li><li>风险分析</li><li>进度安排</li><li>项目组织与计划</li></ol></li><li>需求分析<ol><li>需求分析的目标</li><li>需求收集</li><li>需求规格说明</li><li>数据流建模</li><li>实体一关系建模</li><li>用例建模</li><li>对象建模</li><li>统一建模语言UML</li></ol></li><li>软件设计<ol><li>软件设计的任务和过程</li><li>软件设计基本原则</li><li>面向对象设计原则</li><li>面向数据流图的设计方法</li><li>面向对象的设计方法</li><li>面向对象软件设计模式</li><li>模型一视图一控制器框架</li><li>软件体系结构</li><li>软件详细设计</li></ol></li><li>软件验证技术<ol><li>软件测试基础</li><li>代码复审</li><li>白盒测试</li><li>黑盒测试</li><li>单元测试</li><li>集成测试</li><li>确认测试</li><li>系统测试</li><li>调试</li></ol></li><li>软件维护技术<ol><li>软件维护的基本概念</li><li>软件维护过程</li><li>软件可维护性</li><li>软件再工程技术</li></ol></li><li>软件质量保证与分析<ol><li>软件质量</li><li>软件复杂性分析</li><li>IS0软件质量体系</li><li>软件配置管理</li><li>软件过程能力成熟度模型</li><li>参考教材：陈松乔，任胜兵，王国军。现代软件工程。北京：清华大学出版社，2013</li></ol></li></ol><h1 id="第一章-软件工程基本概念与过程模型"><a href="#第一章-软件工程基本概念与过程模型" class="headerlink" title="第一章  软件工程基本概念与过程模型"></a>第一章 软件工程基本概念与过程模型</h1><h2 id="1-1-软件工程的产生"><a href="#1-1-软件工程的产生" class="headerlink" title="1.1 软件工程的产生"></a>1.1 软件工程的产生</h2><p>软件=程序+数据结构+文档</p><p>三个特点：</p><ol><li><p>软件是“开发”出来的，不是“制造”出来的</p></li><li><p>软件可能会被“废弃”，但不会被“用坏”</p></li><li><p>过去的软件大多是“定制”的，而不是“装配”的</p></li></ol><p>为了摆脱软件危机所造成的困境，北大西洋公约组织（NATO）的科学委员会在1968年首次提出“软件工程”的概念。</p><h2 id="1-2-软件工程的研究对象与基本原理"><a href="#1-2-软件工程的研究对象与基本原理" class="headerlink" title="1.2 软件工程的研究对象与基本原理"></a>1.2 软件工程的研究对象与基本原理</h2><p>软件工程是什么：</p><ul><li>性质（能力）：<strong>指导软件开发和维护</strong>的工程性学科；</li><li>理论基础：计算机科学、管理科学和数学等 ；</li><li>手段：采用<strong>工程化</strong>的概念、原理、技术和方法进行软件的开发和维护，把经过时间证明正确的<strong>管理</strong>措施和当前能够得到的最好的<strong>技术、方法</strong>相结合 ；</li><li>目的：以期用<strong>较少的</strong>代价获取<strong>高质量的</strong>软件。</li></ul><p>软件工程的研究对象：标准和规范、过程和模型、方法和技术、工具和环境</p><p>软件工程的四个研究对象构成了以软件质量为核心的层次结构。</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111121653970.png" alt="image-20211112165341928" style="zoom:50%"></p><p>标准和规范是保证软件质量的关键。过程和模型为方法和技术提供了活动框架，而方法和技术、工具和环境则为实现过程和模型提供了具体方式。</p><p>软件工程的基本原理（1分技术+6分管理）：</p><ol><li>用分阶段的生存周期<strong>计划</strong>严格管理</li><li>坚持进行阶段<strong>评审</strong></li><li>实施严格的产品<strong>控制</strong></li><li>采用现代程序设计<strong>技术</strong></li><li><strong>结果</strong>应能清楚地审查</li><li>开发<strong>小组</strong>的成员应该少而精</li><li>承认不断<strong>改进</strong>软件工程时间的必要性</li></ol><p><strong><em>Boehm认为这7条原理是确保软件产品质量和开发效率的原理的最小集合</em></strong></p><h2 id="1-3-软件开发方法"><a href="#1-3-软件开发方法" class="headerlink" title="1.3 软件开发方法"></a>1.3 软件开发方法</h2><ul><li>软件开发方法是使用定义好的技术（集）及表示符号来组织软件生产过程的方法。</li><li>一般说来，软件开发方法必须在开发步骤、软件文档格式、开发方案评审标准做出规定。</li><li>主要软件开发方法：结构化方法、面向对象方法、形式化方法。</li></ul><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111121713375.png" alt="image-20211112171335317" style="zoom:150%"></p><p>开发方法的结合研究：</p><ul><li>利用各种方法的长处，从而实现优势互补</li><li>在<strong>需求分析和规格说明阶段</strong>采用结构化方法，在<strong>设计和实现阶段</strong>采用面向对象方法，在软件开发全过程中一些<strong>对软件质量有重要影响的部分</strong>采用形式化方法。</li></ul><h2 id="1-4-软件工程工具和环境"><a href="#1-4-软件工程工具和环境" class="headerlink" title="1.4 软件工程工具和环境"></a>1.4 软件工程工具和环境</h2><h3 id="1-4-1-软件工程工具"><a href="#1-4-1-软件工程工具" class="headerlink" title="1.4.1 软件工程工具"></a>1.4.1 软件工程工具</h3><ul><li>软件工具：为支持计算机软件的开发、维护及有关工作而研制的程序系统。</li><li>使用软件工具的<strong>目的</strong>：降低软件开发和维护的成本，提高软件产品的生产效率和质量。</li><li>软件开发工具：用于软件开发过程的各种开发活动<ul><li>分析、设计工具：Visio、Rational Rose</li><li>编码工具：Eclipse</li><li>软件维护工具：辅助维护人员对代码及其有关文档进行各种维护活动</li><li>再工程工具—-软件重构工具</li><li>软件管理和支持工具：辅助软件项目管理人员和支持人员的各种管理和支持活动</li></ul></li><li>特点：一般情况下一种软件工具只支持一种活动。</li><li>不足：工具界面不统一，工具内部无联系，工具切换由人工操作。</li></ul><h3 id="1-4-2-集成型软件开发环境"><a href="#1-4-2-集成型软件开发环境" class="headerlink" title="1.4.2 集成型软件开发环境"></a>1.4.2 集成型软件开发环境</h3><ul><li>由软件工具集和环境集成机制构成</li><li>软件工具集用以支持软件开发的相关过程、活动和任务（支持某种开发方法）</li><li>环境集成机制为工具集成和软件开发、维护和管理提供统一的支持</li></ul><h2 id="1-5-软件生存期过程"><a href="#1-5-软件生存期过程" class="headerlink" title="1.5 软件生存期过程"></a>1.5 软件生存期过程</h2><ul><li>软件生存期过程规定了获取、供应、开发、操作和维护软件时，要实施的<strong>过程、活动和任务</strong>。其目的是为各种人员提供一个公共的框架，以便可以使用“<strong>相同的语言</strong>”在自己的环境中创作和管理软件。</li><li>软件生存期过程没有规定一个特定的生存周期模型，各软件开发机构可视其项目的需要选择一种软件生存周期模型，并将软件生存期过程所含过程、活动和任务映射到选定的软件生存周期模型中。</li></ul><h2 id="1-6-常用软甲生存期模型"><a href="#1-6-常用软甲生存期模型" class="headerlink" title="1.6 常用软甲生存期模型"></a>1.6 常用软甲生存期模型</h2><ul><li>软件生存期模型描述了软件项目从需求定义开始，到开发成功后投入使用，在使用的过程中不断增补修订，直到最后停止使用这一期间所进行的各种活动如何执行的模型。</li></ul><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111121727874.png" alt="瀑布模型" style="zoom:50%"></p><ul><li>采用原型模型开发系统，用户和开发者必须达成一致：原型被建造仅仅是用来定义需求，之后便部分或全部抛弃，最终的软件要在充分考虑了质量和可维护性等方面之后才被开发。</li></ul><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111121743302.png" alt="原型模式" style="zoom:50%"></p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111121744302.png" alt="RAD模型" style="zoom:50%"></p><p><strong>一次性地将整个系统交给用户</strong>：<br>瀑布模型是假设当线性阶段完成之后就能交付一个完善的系统。原型模型主要用来帮助开发者获取用户需求，待需求稳定后再开发最终系统提供给用户。RAD模型则先将系统主要功能分给若干RAD小组开发，然后集成起来形成最终系统提交给用户。</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111121751134.png" alt="增量模型" style="zoom:50%"></p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111121753869.png" alt="螺旋模型" style="zoom:67%"></p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111121756942.png" alt="RUP模型" style="zoom:50%"></p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111121806565.png" alt="image-20211112180600496" style="zoom:150%"></p><p>其他模型：</p><ul><li>极限编程模型（强调对变化的适应）</li><li>构件组装模型(基于构件组装)</li><li>簇模型（强调并行开发）</li><li>喷泉模型（适合面向对象软件开发）</li><li>智能模型（将瀑布模型与专家系统结合）</li></ul><h2 id="1-7-软件文档"><a href="#1-7-软件文档" class="headerlink" title="1.7 软件文档"></a>1.7 软件文档</h2><ul><li>软件文档为提高软件工程项目的开发和管理能力提供了重要的基础。</li><li>在软件生存周期中，软件文档种类多、编制工作量大、技术性强。</li><li>一方面要对软件文档的地位和作用应有充分的认识，另一方面要提高文档的质量。</li><li>文档是指某种数据媒体和其中所记录的数据。</li><li>作用：<ul><li>提高了软件开发过程的可视性；</li><li>有利于及时纠正错误，减少返工，提高软件开发效率；</li><li>为开发人员、管理人员以及用户等之间的协作和交流提供了基础。</li></ul></li><li>要求：及时性；完整性 ；实用性；规范性。</li><li>分类：按照文档产生和使用的范围不同，软件文档可以分成三类，即：技术文档、管理文档和用户文档。其中，技术文档和管理文档又统称为系统文档。<ul><li>技术文档是指在软件开发过程中作为开发人员前一阶段工作成果和后一阶段工作依据的文档。</li><li>管理文档是指在软件开发过程中由开发人员等制定并提交给管理人员的工作计划或报告，使管理人员能够通过这些文档了解软件项目的安排、进度、资源使用及成果等。</li><li>用户文档是软件开发人员为用户准备的有关该软件使用、操作、维护的资料</li></ul></li><li>编写步骤：<ul><li>准备工作；</li><li>确定写作内容；</li><li>编写定稿；</li><li>更新完善</li></ul></li></ul><h2 id="1-8-敏捷软件开发"><a href="#1-8-敏捷软件开发" class="headerlink" title="1.8 敏捷软件开发"></a>1.8 敏捷软件开发</h2><ul><li>敏捷开发的四个价值：<ul><li>个体和交互胜过过程和工具</li><li>可工作的软件胜过难以理解的文档</li><li>客户协作重于合同谈判</li><li>响应变化胜过遵循计划</li></ul></li><li>敏捷过程：<ul><li>对变化进行快速地响应</li><li>有效地进行交流</li><li>将客户拉入团队</li><li>组建团队，控制完成所需要的工作</li></ul></li><li>特点：<ul><li>需求驱动</li><li>短期计划</li><li>迭代开发</li><li>提供多个软件增量</li><li>随着变化调整</li></ul></li><li>敏捷原则<ul><li>最优先要做的是通过<strong>尽早地、持续地交付有价值的软件</strong>来使客户满意。</li><li>即使在开发后期，也<strong>欢迎需求改变</strong>。敏捷过程利用变化来为客户创造竞争优势。</li><li>经常性地<strong>交付可以工作的软件</strong>，交付的间隔可以从几个星期到几个月，交付的时间间隔越短越好。</li><li>在整个项目开发期间，<strong>业务人员和开发人员必须天天在一起工作</strong>。</li><li><strong>围绕有积极性的个人构建项目团队</strong>。为他们提供所需的环境和支持，并信任他们能够完成工作。</li><li>在团队内部，最有效果并富有效率的信息传递方法是<strong>面对面的交流</strong>。</li><li>可运行的软件是首要的<strong>进度度量标准</strong>。</li><li>敏捷过程<strong>提倡可持续的开发速度</strong>。责任人、开发者和用户应该能够保持一个长期的、稳定的开发速度。</li><li>持续<strong>关注优秀的技能和好的设计</strong>，增强敏捷能力。</li><li><strong>简单</strong>（是不必做的工作最大化的艺术）是必要的。</li><li>最好的架构、需求和设计出自于<strong>自组织的团队</strong>。</li><li>每隔一段时间，<strong>团队应反省</strong>如何才能有效地工作，并相应地调整自身的行为。</li></ul></li></ul><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111172313411.png" alt="image-20211117231301108" style="zoom:67%"></p><h1 id="第二章-可行性研究与项目计划"><a href="#第二章-可行性研究与项目计划" class="headerlink" title="第二章 可行性研究与项目计划"></a>第二章 可行性研究与项目计划</h1><ul><li>软件工程项目可行性研究<strong>实质</strong>是一次大大压缩和简化了的分析和设计过程，主要在<strong>较高层次</strong>上以较抽象的方式进行，其<strong>目的</strong>是在尽可能短的时间内以最小的代价确定该项目<strong>是否能够开发，是否值得开发</strong>。</li><li>内容：<ul><li>技术可行性（相关技术、风险、资源）</li><li>经济可行性（成本、效益）</li><li>操作可行性（政治、法律、社会道德等）</li></ul></li><li>步骤：<ul><li>系统目标和范围的定义：要解决的根本问题、达到目标所需的资源和经费；</li><li>对现行系统进行分析研究：现有系统的物理模型和逻辑模型；（入口：现有系统的组织结构）</li><li>导出新系统的逻辑模型；（解决了有关问题）</li><li>设计新系统的物理方案；（最先进的方案、实用、基本方案）</li><li>推荐可行的方案 ；（包括推荐理由）</li><li>编写可行性研究报告。（结论：继续、延期和拒绝）</li></ul></li></ul><h2 id="2-1-系统分析"><a href="#2-1-系统分析" class="headerlink" title="2.1 系统分析"></a>2.1 系统分析</h2><ul><li><p>系统分析是可行性研究阶段对现有系统的功能、数据及约束条件的初步研究，了解现有系统能做什么。</p></li><li><p>系统分析往往先从系统的<strong>组织结构</strong>入手，进而<strong>分析组织</strong>的业务功能及业务流程，最后用数据流图明确<strong>信息如何在组织中流动</strong>完成指定的业务功能。</p></li><li><p>系统的组织结构反映了组织内部的组成以及它们之间的关系。</p></li><li><p>内容：</p><ul><li><p>组织结构图：</p><p>在组织结构图中，每个方框表示一个业务域，通过层次分解精化，直至小的工作组或某个个体。</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111172353120.png" alt="image-20211117235306075" style="zoom:50%"></p></li><li><p>业务联系图</p><p>业务联系图反映组织各部分与各项业务之间的联系。</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111222231821.png" alt="image-20211122223156489"></p></li><li><p>业务功能树</p><p>用于描述组织内部各部分的业务和功能</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111222233581.jpg" alt=""></p></li></ul></li><li><p>系统流程图是描绘物理系统的传统工具，可以采用系统流程图来描述项目的大概业务处理流程，其基本思想是用图形符号以黑盒子形式描绘系统各部件（如程序、数据库、文档、人工过程等）。</p></li><li><p>系统流程图表达的是信息在系统中各部件之间流动的情况，而不是对信息进行加工处理的控制过程。</p></li><li><p>数据流图描述的是系统的逻辑模型，图中没有具体的物理元素，只是描绘信息在系统中的流动和处理情况。（数据流图是逻辑系统的图形表示）</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111172355696.png" alt="image-20211117235543662"></p></li><li><p>在可行性研究阶段，采用数据流图来描述数据在系统中的流动和处理情况时，不必详细描述，只须概括地描述高层的数据处理和流动。</p></li></ul><h2 id="2-2-成本估计"><a href="#2-2-成本估计" class="headerlink" title="2.2 成本估计"></a>2.2 成本估计</h2><ul><li><p>三种方法：</p><ul><li>自顶向下（基于已完成的类似项目进行估算）</li><li>自底向上（使用简单的“分解技术”来进行成本以及工作量的估算）</li><li>使用经验模型进行成本及工作量的估算</li></ul></li><li><p>自顶向下成本估计</p><ul><li><p>通常仅由少数上层技术与管理人员参加。</p></li><li><p>方式：依据先前已完成项目所耗费的总成本（总工作量），推算新开发软件的总成本（总工作量），然后在项目内部进行成本分配。</p></li><li><p>优点:工作量小，速度快。</p></li><li><p>缺点:对开发中某些局部问题或特殊困难易低估，甚至没有考虑。如果所开发的软件缺乏可借鉴的经验，则估计偏差可能较大。</p></li></ul></li><li><p>自底向上成本估计</p><ul><li>估计者必须先了解待开发软件的范围。软件范围包括功能、性能、限制、接口和可靠性等。</li><li>方式：在估算开始之前，应对软件范围进行适当的<strong>细化</strong>，以提供较详细的细节。对于细化得到的任务单元可交给该任务的开发人员去<strong>估计</strong>，得到各任务单元的估计成本。然后，将各任务单元的成本<strong>汇合</strong>成项目的总成本。</li><li>对涉及全局的花费（如质量管理）可能估计不足甚至完全忽视，使成本估计可能偏低。</li></ul></li><li><p>基于经验模型的成本估计</p><ul><li><p>利用已完成项目的样本数据进行分析，从而建立有关经验公式来预测项目所需的成本、工作量等，具有比较客观（与前面的估算方法相比）、计算结果可重复（即无论何时使用模型，其结果相同）等优点。</p></li><li><p>由于经验数据是从一些有限的项目中得到的，而且软件类型和开发环境各不相同，因而模型中得到的结果必须慎重使用。</p></li><li><p>主要经验模型：</p><ul><li><p>静态单变量模型</p><p>典型结构为：$E=A+B\times(估计变量)^C$，其中，A、B和C是由经验导出的常数；E是以人月（PM）为单位的工作量；“估计变量”是被估软件特征的估计量，如代码行数等。</p></li><li><p>动态多变量模型：</p><p>模型把项目的资源需求看成是时间的函数。</p><p>例如：$L=C<em>{k}<em>K^{4/3}</em>t</em>{d}^{4/3}$，其中，L表示源代码行数（以LOC计算）；K表示软件全生存周期（含维护在内）所需工作量（以人年计）；$t_{d}$表示项目开发持续时间（以年计）；$C_k$表示技术状态常数。</p><p><strong>这表明，如果缩短开发时间，将意味着增加项目的开发工作量</strong></p></li><li><p>COCOMO模型</p><p>Boehm将软件成本估算分成3个由粗到细的层次：基本层、中间层和详细层。每个层次又按软件项目的应用领域和复杂程序分成3种类型：组织型、半独立型和嵌入层。</p><p>模型形式：$ TDEV=C<em>(MM)^d , MM=a</em>(KDSI)^b*\sum\limits_{i = 1}^{15} {f_i} $ ，其中，其中MM表示开发工作量，以人月计；KDSI表示源指令条数，以千行计算；TDEV表示开发时间，以月计算；$f_i$(i=1～15)表示15项项目影响调节因子；a,c表示模型系数；b,d表示模型指数。</p><ul><li><p>基本层COCOMO模型</p><p>不考虑成本影响调节因子，是对软件成本的一种宏观粗略估计，是一个静态单变量模型</p><ul><li>组织型——较小、较简单的软件项目</li><li>半独立型——软件的需求介于“组织型”和“嵌入型”之间。</li><li>嵌入型——必须在一组严格的硬件、软件及操作约束下开发的软件项目，对接口、数据结构、算法要求较高。</li></ul></li><li><p>中间层COCOMO模型</p><p>主要考虑了从整个生存期来衡量成本影响调节因子，共15项，分成4类：产品、硬件、人员及项目。</p></li><li><p>详细层COCOMO模型</p><p>详细层COCOMO模型需要考虑各调节因子对于不同开发阶段的影响。</p><p>针对每一个影响因素，按模块级、子系统级和系统级，有三张工作量因素分级表，供不同级别的估算使用。</p><p>详细层COCOMO模型的模型形式与中间层COCOMO模型相同，只是fi的取值在详细层COCOMO模型中应分级和分阶段给定。</p></li></ul><p>改进：COCOMOII模型可以处理较广泛的软件工程技术，例如，面向对象、包含瀑布模型及其它生存期模型、复用、第四代语言等等。</p><p>Boehm关于自己提出的COCOMO模型的评价意见是：一个软件估算模型能够在成本估算上相差不到20%，时间估算上相差不到70%，就相当不错了。</p></li><li><p>运用：</p><p>使用时应根据实际环境进行调整以适合自己的应用项目。同时对于估算结果的精度也不应期望过高。</p><p>当开发产品时，实际的开发工作量应与预测值进行比较。出现偏差可作为一个有问题的早期警告。管理者应该分析出现问题的原因，如开发小组不胜任，产品规模低估了等，并采取合适的行动使影响最小化。</p></li></ul></li></ul></li></ul><h2 id="2-3-效益分析"><a href="#2-3-效益分析" class="headerlink" title="2.3 效益分析"></a>2.3 效益分析</h2><ul><li><p>系统的效益有两部分：经济效益和社会效益。</p></li><li><p>经济效益是指用使用新系统而增加的收入，包括使用新系统节省的运行费用，是一种有形的效益。</p></li><li><p>社会效益是一种无形的效益，主要从性质上、心理上进行衡量，很难直接量化，但在某些情况下，无效的效益能转化成有形的效益。</p></li><li><p>度量指标：</p><ul><li><p>货币的时间价值：常用利率的形式表示</p></li><li><p>纯收入：其值等于整个生存周期内系统的累积经济效益（折算成当前值）与投资之差。</p></li><li><p>投资回收期：其值等于使累计的经济效益（折算成当前值）等于最初投资所需要的时间。</p><p>投资回收期越短，就能越快地获得经济效益，因而这项工程也就越值得投资。</p></li><li><p>投资回收率：用来衡量投资效益的大小，并可以和银行年利率进行比较</p><p>计算公式：$P=F_1/(1+j)+F_2/(1+j)^2+…+F_n/(1+j)^n$</p><p>其中，P表示当前的投资额，$F_i$表示第i年年底的效益（i=1,2, …,n），n表示系统的使用寿命，j表示投资回收率。</p></li></ul></li><li><p>系统的效益分析随系统的特征而异。</p><p>根据总投资的情况和年度效益分析的结果，可以进一步计算纯收入、投资回收期和投资回收率等。</p><p>管理者根据有关分析结果，结合其它潜在的对投资的使用，考虑有关社会效益，可以在经济上确定系统是否值得投资开发。</p></li></ul><h2 id="2-4-风险分析"><a href="#2-4-风险分析" class="headerlink" title="2.4 风险分析"></a>2.4 风险分析</h2><blockquote><p>如果你不主动攻击风险，风险就会主动攻击你。</p><p>主动的、明智的风险管理策略应该在技术工作开始之前，先<strong>标识</strong>出潜在的风险，<strong>评估</strong>它们出现的概率及产生的影响，并按重要性加以排序，然后项目组织再制订一个计划来<strong>管理</strong>风险。</p></blockquote><p>风险分析活动：风险标识、风险估计、风险评价和风险管理与监控。</p><h3 id="2-4-1-风险标识"><a href="#2-4-1-风险标识" class="headerlink" title="2.4.1 风险标识"></a>2.4.1 风险标识</h3><ul><li><p>类型：</p><ul><li><p>宏观角度：项目风险、技术风险和商业风险</p></li><li><p>Charette：已知风险、可预测风险和不可预测风险</p></li></ul></li><li><p>方法：</p><ul><li>产品规模：与待开发或修改的软件的总体规模相关的风险。</li><li>商业影响：与管理或市场所加约束相关的风险。</li><li>客户特性：与客户的素质以及开发者和客户定期通信的能力相关的风险。</li><li>过程定义：与软件过程被定义的程度以及它们被开发组织所遵守的程度相关的风险。</li><li>开发环境：与用以建造产品的工具的可用性及质量相关的风险。</li><li>建造技术：与待开发软件的复杂性及系统所包含技术的“新奇性”相关的风险。</li><li>人员数量及经验：与参与工作的软件技术人员的总体水平及项目经验相关的风险。</li></ul></li></ul><h3 id="2-4-2-风险估计"><a href="#2-4-2-风险估计" class="headerlink" title="2.4.2 风险估计"></a>2.4.2 风险估计</h3><ul><li>风险发生的可能性。风险可能性尺度可以用布尔值、定量或定性的方式表示。</li><li>可能带来的损失：灾难的、严重的、轻微的和可忽略的。</li></ul><h3 id="2-4-3-风险评价"><a href="#2-4-3-风险评价" class="headerlink" title="2.4.3 风险评价"></a>2.4.3 风险评价</h3><ul><li>根据风险估计的结果，建立一系列三元组：[r~i~, p~i~, e~i~]，其中r~i~表示风险，p~i~表示风险出现的概率，e~i~表示风险产生的影响 ；</li><li>定义项目的各种风险参考水准，如成本、进度等；</li><li>找出每个[r~i~, p~i~, e~i~]与各参考水准之间的关系；</li><li>预测一组临界点以定义项目的终止区，该区由一条曲线或易变动区域来界定；</li><li>预测怎样的风险组合，会影响参考水准。</li><li><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111221637672.png" alt="image-20211122163714608" style="zoom:50%"></li></ul><h3 id="2-4-4-风险管理与监控"><a href="#2-4-4-风险管理与监控" class="headerlink" title="2.4.4 风险管理与监控"></a>2.4.4 风险管理与监控</h3><ul><li><p>风险管理</p><ul><li><p>风险管理是指利用某些技术，如原型化、软件自动化、可靠性工程学，以及某些项目管理方法等设法避免或转移风险。</p></li><li><p>实施==风险管理策略==会带来一些额外的开销。<u>仅当实施风险管理策略所需的成本小于风险管理带来的效益</u>（即风险带来的影响）时才可考虑实施风险管理策略。</p></li><li><p>高影响且发生概率为中到高的风险以及低影响且高发生概率的风险，应该首先列入管理的考虑之中。</p></li><li><p>按照Pareto的80-20规则，80%的软件风险能够由仅仅20%的已标出风险来说明。</p></li></ul></li><li><p>风险监控的三个目标：</p><ul><li>事件和主要风险因素的跟踪，判断一个预测的风险事实上是否发生了；</li><li>风险估计，确保针对某个风险制定的风险管理措施正在实施；</li><li>收集可用于将来风险分析的信息。</li></ul></li></ul><h2 id="2-5-进度安排"><a href="#2-5-进度安排" class="headerlink" title="2.5 进度安排"></a>2.5 进度安排</h2><ul><li><p>方式：</p><ul><li>系统最终交付日期已经确定，软件开发组织在这一约束下将工作量进行分配；</li><li>系统最终交付日期只确定了大致的期限，最终发布日期由软件开发组织确定，工作量以一种能够最好地利用资源的方式进行分配。</li></ul><p><strong>在实际工作中，第一种方式发生的频率远高于第二种方式。</strong></p></li><li><p>基本原则：</p><ul><li>任务分解：将软件工程项目的任务分解成易管理的子任务,即作业;</li><li>作业依存：确保作业间的依存关系——顺序和并发；</li><li>时间分配：为每个作业指定开始和终止时间；</li><li>资源约束：在进行时间分配时应考虑资源约束，如人员数量、工具；</li><li>定义责任：应指定某特定小组负责某个作业；</li><li>定义结果：对每个作业定义相应的结果——产品或产品的一部分；</li><li>定义里程碑：每个作业或作业系列应与项目的里程碑相联系。</li></ul></li><li><p>工作量分配：</p><p>40-20-40规则：在整个软件开发过程中，编码的工作量约占20%，编码前的工作量占40%，编码后的工作量也占40%</p></li><li><p>进度安排方法：</p><ul><li>原则上可以把一般工程项目的进度安排方法和工具应用于软件工程项目。</li><li>首先识别一组项目任务作业，建立任务作业之间的相互关联，然后估算各个任务的工作量，分配人力和其它资源，指定进度时序。</li><li>方法：PERT技术和Gantt图方法</li></ul></li><li><p>PERT技术</p><ul><li>PERT技术（Program Evaluation &amp; Review Technique，PERT） 又叫计划评审技术、工程网络技术</li><li><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111221645045.png" alt="PERT图" style="zoom:67%"></li><li>计算事件的最早发生时间（EET）<ul><li>通常规定，起始事件的最早发生时刻为0；</li><li>考虑进入该事件的所有作业；</li><li>对于每个作业均计算其起始事件的最早发生时刻EET与持续时间之和；</li><li>选取上述和数中的最大值作为该事件的最早发生时刻EET。</li></ul></li><li>计算事件的最晚发生时间（LET）<ul><li>通常规定，工程最后一个事件的最迟发生时刻等于最早发生时刻；</li><li>考虑离开该事件的所有作业；</li><li>对于每个作业都计算其结束事件的最迟发生时刻LET与作业持续时间之差；</li><li>选取上述差数中的最小值作为该事件的最迟发生时该LET。</li></ul></li><li><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111221648265.png" alt="示例"></li><li>利用机动时间安排进度<ul><li>机动时间=LET-EET-作业持续时间</li><li><strong>先安排关键作业，再利用机动时间安排非关键作业。</strong></li><li><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111221650072.png" alt="image-20211122165008026" style="zoom:67%"></li></ul></li></ul></li></ul><h2 id="2-6-项目组织与计划"><a href="#2-6-项目组织与计划" class="headerlink" title="2.6 项目组织与计划"></a>2.6 项目组织与计划</h2><ul><li><p>人尽其才</p></li><li><p>人员组织规律</p><ul><li><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111221651552.png" alt="Rayleigh-Norden曲线"></li><li>如果在软件生存周期平均使用人力，则会造成：起始阶段人力过剩（图中①）、开发后期和维护前期人力不足（图中②）和维护时期人力补偿为时已晚（图中③）</li></ul></li><li><p>各类人员参与程度曲线</p><ul><li><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111221652290.png" alt="各类人员参与程度曲线"></li><li>初级技术人员在编码时参与最多，而在其它阶段参与则较少；高级技术人员在软件开始的开始阶段和结束阶段参与较多，在中间阶段参与较少；管理人员在项目开始阶段参与较多，其它则参与较少。</li></ul></li><li><p>两大定律：</p><ul><li>人员——时间权衡定律<ul><li>软件开发工作量与软件开发时间的4次方成反比。</li><li>如果适当延长软件开发时间，则可减少软件开发的工作量；反之，如果缩短软件开发时间，则工作量会大幅度增加</li></ul></li><li>Brooks定律<ul><li>向一个已经延期的软件项目追加开发人员，可能会使它完成得更晚。</li><li>当开发人员以算术级数增长时，人员之间的通信将以几何级数增长。</li></ul></li></ul><p>由这两条定律，可以得出：<strong>对于软件项目，开发时间宁可长一些，开发人员可少而精一些。</strong></p></li><li><p>人员组织形式</p><ul><li>软件开发机构选择怎样的人员组织形式，要针对<strong>软件项目的特点和参与人员的素质</strong>来决定。</li><li>在建立软件开发组织时，应注意：<ol><li>责任到人——尽早将责任落实，便于管理；</li><li>合理分工——减少不必要的通信，提高工作效率；</li><li>责权均衡——责任与权力的平衡，有助于任务的完成。</li></ol></li><li>层次模式<ul><li><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111221707726.png" alt="层次模式"></li><li>软件经理负责整个开发部门的管理工作，在各项目之间分配和协调各种资源。</li><li>目经理负责一个具体项目开发的各个方面。</li><li>每个小组负责项目的一部分工作。</li><li>审查小组与项目经理同属一个层次，主要从事质量保证活动，在项目开发的里程碑进行技术审查和管理复审。</li></ul></li><li>矩阵模式<ul><li><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111221708535.png" alt="矩阵模式"></li><li>项目经理注重于问题域知识，阶段经理则熟悉阶段的开发知识。</li></ul></li></ul><p>对于层次模式中的小组和矩阵模式中的子项的组织，主要有三种组织形式</p><ul><li>主程序员小组<ul><li><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111221711579.png" alt="主程序员小组"></li><li>主程序员负责制订计划、协调与审查工作，并完成结构设计及代码中关键和复杂部分的实现。</li><li>技术人员负责项目的具体分析与开发以及文档资料的编写工作。</li><li>后备程序员主要协助主程序员的工作，必要时可替代主程序的工作。</li></ul></li><li>民主小组<ul><li><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111221712683.png" alt="民主小组" style="zoom:33%"></li><li>民主小组的最基本概念是“无我程序设计”（egoless programming）</li><li>日本许多公司使用权用民主小组的组织形式进行软件开发</li></ul></li><li>层次小组<ul><li><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111221712292.png" alt="层次小组"></li><li>层次间按隶属关系进行通信，组内平等通信。</li><li>这种组织方式适合于<strong>大型软件开发项目</strong>，尤其是项目本身就是层次结构状的课题。</li></ul></li></ul></li></ul><h1 id="第三章-需求分析"><a href="#第三章-需求分析" class="headerlink" title="第三章 需求分析"></a>第三章 需求分析</h1><blockquote><p>需求分析是指开发人员通过细致的调查分析，详细、准确和完整地理解用户需要什么样的软件，将用户非形式的需求陈述转化为完整的需求定义，再将需求定义转换到相应的需求规格说明的过程。<br>通常，把一整套的需求分析方法、技术和工具等的集合称为建模方法。</p></blockquote><h2 id="3-1-需求分析的目标"><a href="#3-1-需求分析的目标" class="headerlink" title="3.1 需求分析的目标"></a>3.1 需求分析的目标</h2><ul><li>AO:决定是否建立一个系统</li><li>A1:理解最终的软件系统应该解决哪些问题。</li><li>A2:引出这些问题和系统的一些相关问题。</li><li>A3:提供一个与这些问题和系统特征有关的回答问题的基础。</li><li>A4:决定系统应该做什么。</li><li>A5:决定系统不应该做什么</li><li>A6:确认系统将能够满足用户的需要，并且定义相应的验收标准。</li><li>A7:为系统开发提供一个基础。</li></ul><p>需求分析的这些目标可由三个子阶段完成：</p><ul><li>可行性分析主要是完成AO目标，即要决定是否建立一个系统；</li><li>需求收集主要完成目标A1~A6；</li><li>目标A7则由需求规格说明完成。</li></ul><h2 id="3-2-需求收集"><a href="#3-2-需求收集" class="headerlink" title="3.2 需求收集"></a>3.2 需求收集</h2><ul><li><p>收集的内容</p><ul><li>信息需求（数据需求）</li><li>功能需求</li><li>性能需求</li><li>运行需求</li><li>未来需求</li></ul><p>除此之外，还有用户界面需求、资源使用需求(如人、财、物)等其他专门需求。</p></li><li><p>方法：</p><ul><li>访谈</li><li>问卷调查</li><li>场景使用</li><li>用户资料收集</li><li>建立快速原型</li></ul></li></ul><h2 id="3-3-需求规格说明"><a href="#3-3-需求规格说明" class="headerlink" title="3.3 需求规格说明"></a>3.3 需求规格说明</h2><blockquote><p>一旦系统分析员确信收集到了用户的需求之后，接着就应该把它们整理成规范化的形式，即进行系统的需求规格说明。一方面，因为需求规格说明是系统分析员在用户的参与下做出的双方对系统必须要做什么的一致的理解。因此，需求规格说明应该清楚明了，只有这样，用户才能看得懂，才有可能接受。另一方面，需求规格说明将是设计组进行设计的依据，这就要求需求规格说明必須做到完整、详尽。</p></blockquote><p>需求规格说明必须做到：</p><ul><li>技术性描述不要太强，用户才容易阅读；</li><li>要足够准确，设计人员据此设计的产品才可能满足最终用户的要求。</li></ul><p>多种需求规格说明的方法和技术：</p><ul><li>非形式化的需求规格说明使用自然语言进行描述；</li><li>半形式化的需求规格说明使用图形并辅以自然语言进行描述；</li><li>形式化的需求规格说明采用比半形式化的方式更为严格的形式，如VDM系统、乙系统和 RAISE系统等采用严格的数学描述形式。</li></ul><h2 id="3-4-数据流建模"><a href="#3-4-数据流建模" class="headerlink" title="3.4 数据流建模"></a>3.4 数据流建模</h2><ul><li>数据流建模方法是一种<strong>结构化分析方法</strong>；</li><li><strong>自顶向下、逐层分解</strong>地定义系统需求；</li><li>特点是<strong>利用数据流图来对用户需求进行分析</strong>；</li><li>可用于分析<strong>任何</strong>应用系统的需求</li></ul><h3 id="3-4-1-数据流图"><a href="#3-4-1-数据流图" class="headerlink" title="3.4.1 数据流图"></a>3.4.1 数据流图</h3><ul><li><p>据流(用箭头表示）；</p></li><li><p>加工（加工一般用一个圆圈或圆角方框来表示 ）；</p></li><li><p>数据存储(一般用开口的矩形框或双划线来表示)；</p></li><li><p>数据的源点和终点（一般用正方形或立方体来表示 ）；</p></li><li><p>扩展符号主要有：*、+和⊕ 。</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111221852410.png" alt="例3-1"></p></li><li><p>分层数据流图</p><ul><li>分层数据流图可以避免一次引入过多的细节，有利于控制问题的复杂度，从而便于对大型系统描述的实现。</li><li>不同的用户可以只选择分层数据流图中与本身有关或感兴趣的部分，不必阅读全图，从而便于用户的使用和理解。</li><li>顶层数据流图<ul><li>主要描述整个系统的作用范围，说明系统的边界，反映系统和外部环境之间的关系，即系统的输入和输出数据流。</li><li><strong>只有一张</strong></li><li><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111221854830.png" alt="例3-2"></li></ul></li><li>底层数据流图<ul><li>有一些不必再进行分解的加工组成（基本加工）</li><li><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111221856088.png" alt="图3-3"></li></ul></li><li>中间层数据流图<ul><li>通过分解高层加工得到的</li><li><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111221856550.png" alt="图3-4"></li></ul></li></ul></li></ul><h3 id="3-4-2-数据词典"><a href="#3-4-2-数据词典" class="headerlink" title="3.4.2 数据词典"></a>3.4.2 数据词典</h3><blockquote><p>数据词典（Data Dictionary，DD），又称数据字典，是关于数据信息的集合，是对数据流图中的每个数据，包括数据流和数据存储，进行严格定义的场所，以保持数据在系统中的一致性。</p></blockquote><p>组成描述符：</p><div class="table-container"><table><thead><tr><th>符号</th><th>涵义</th></tr></thead><tbody><tr><td>=</td><td>表示等价于（或定义为）</td></tr><tr><td>+</td><td>表示连接两个数据元素，即“与”的关系</td></tr><tr><td>[ \</td><td>]</td><td>表示从方括号内列出的若干个数据元素中选择一个</td></tr><tr><td>{}</td><td>表示重复花括号内的数据元素若干次($1{E}10$或$_1^{10}{E}$)</td></tr><tr><td>()</td><td>表示愿口号内的元素是可有可无的</td></tr><tr><td>m..n</td><td>表示界域，从m到n</td></tr><tr><td>*..*</td><td>表示两个星号间的内容为对跳内的注释</td></tr></tbody></table></div><h3 id="3-4-3-加工说明"><a href="#3-4-3-加工说明" class="headerlink" title="3.4.3 加工说明"></a>3.4.3 加工说明</h3><ul><li><p>数据流图中的“基本加工”由于没有进一步分解得到子图，因而需要加工说明来对其进行描述。</p></li><li><p>描述基本加工如何把输入数据流变换成输出数据流的加工规则；描述实现加工的策略而不是实现加工的细节。</p></li><li><p>IPO图、结构化语言、判定表、判定树等均可作为加工说明的工具。</p></li><li><p>IPO（Input/Process/Output）图</p><ul><li><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111221859761.png" alt="IPO图"></li><li>IPO图除可用于分析阶段描述加工逻辑说明外，也常与层次图（Hierachy Chart, HC）一起用于设计阶段，形成HIPO图。</li></ul></li><li><p>结构化语言</p><ul><li>结构化语言，又称PDL（Program Design Language, PDL）或伪代码（Pseudo Code），是一种介于自然语言和形式语言之间的一种半形式语言。</li></ul></li><li><p>判定表/判定树</p><ul><li>适合：完成加工的一组动作是由于某一组条件取值的组合而引发的动作</li><li><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111221928990.png" alt="判定表"></li><li>判定树是判定表的图形表示，有时比判定表更直观。</li><li><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111221929874.png" alt="判定树"></li></ul></li></ul><h3 id="3-4-4-数据流建模步骤"><a href="#3-4-4-数据流建模步骤" class="headerlink" title="3.4.4 数据流建模步骤"></a>3.4.4 数据流建模步骤</h3><p>原则上是由外向里、自顶向下</p><ul><li>画顶层数据流图</li><li>画分层数据流图</li><li>用数据词典定义数据流图中的所有数据</li><li>用加工说明描述数据流图中的基本加工</li></ul><h2 id="3-5-实体一关系建模"><a href="#3-5-实体一关系建模" class="headerlink" title="3.5 实体一关系建模"></a>3.5 实体一关系建模</h2><ul><li><p>实体关系图由三个相互关联的部分构成：<strong>实体</strong>（即数据对象）、实体之间的<strong>关系</strong>以及实体和关系的<strong>属性</strong>。</p><ul><li>实体：对必须由软件理解的任何复合信息的表示。在E-R图中，实体用矩形框表示</li><li>属性：定义了一个实体的特征并呈现三种不容的性质之一：<ul><li>命名一个实例</li><li>描述一个实例</li><li>引用另一个表的实例</li></ul></li><li>关系</li></ul></li><li><p>基数</p><ul><li>定义：表示一个给定的关系中的实体数据</li><li>两个对象可能的关系：一对一、一对多、多对多</li></ul></li><li><p>模态</p><ul><li>如果一个实体的某一个实例对一个关系没有明显的要求或者关系是可选的，则这一关系的模态值为0</li><li>如果一个实体的任一个实例对一个关系有明确的强制性的要求，则这一关系的模态值为1。</li></ul><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111221939210.png" alt="例3-5"></p><ul><li>“人”和“计算机”之间的“买”的关系是1对多的关系，也就是说，一个“人”可以买0或多台“计算机”，但是，任何一台“计算机”只能被1个“人”购买。图中，基数用靠近实体的竖线或水平放置的爪形表示：竖线表示“1”，爪形表示“多”。模<br>态则用远离实体的竖线或圆圈表示：竖线表示“强制”，圆圈表示“可选”。因此，该图表示，系统中的“计算机”必须要有一个“人”购买，否则，系统不保存有关信息：但是，系统中的“人”可能买了“计算机”，也可能还未买（是潜在的客户）。</li></ul></li></ul><h2 id="3-6-用例建模"><a href="#3-6-用例建模" class="headerlink" title="3.6 用例建模"></a>3.6 用例建模</h2><ul><li>用例建模是一种从<strong>用户使用系统</strong>的角度来建立系统功能需求模型的一种方法。</li><li>用例建模既非从数据模型开始，亦非从系统数据流着手，而是从<strong>组成系统的实际操作</strong>入手。</li><li>用例图，又称用例模型，是用例建模的主要成果，它从系统外部执行者的角度来描述系统需要提供哪些功能以及谁使用这些功能。</li></ul><h3 id="3-6-1-用例图"><a href="#3-6-1-用例图" class="headerlink" title="3.6.1 用例图"></a>3.6.1 用例图</h3><ul><li><p>四种主要成分：</p><ul><li>系统：待开发的任何事物，包括软件、硬件或者过程</li><li>参与者：使用系统的对象，系统外部的实体，以某种方式参与用例的执行过程<ul><li>主要参与者：主动发起人，通过使用用例从系统中获得业务价值。主要参与者可能是一个，可能是多个。</li><li>次要参与者：为其他参与者创造业务价值</li></ul></li><li>用例：参与者为达到某个目的而与系统进行的一系列交互，执行结果将为参与者提供可度量的价值</li><li>关系：描述参与者和用力之间的关系<ul><li>通信关系：描述参与者和用力之间的关系</li><li>泛化关系：参与者之间的泛化关系意味着一个参与者可以完成另一个参与者同样的任务，它也可补充额外的任务。用例之间的泛化关系意味着一个用例是另一个用例的特殊版本。</li><li>包含关系：包含关系描述了用例间的共同行为。当两个或两个以上用例有共同的执行序列片断时，可以将这些执行序列片断抽出，形成被包含例。同时，当一个用例描述的执行序列是另一个用例的执行序列的一部分时，也可使用包含关系。</li><li>拓展关系：对一个已存在用例增加新功能</li></ul></li></ul><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111221958193.png" alt="简单ATM系统用例图"></p></li></ul><h3 id="3-6-2-参与者及用例的描述"><a href="#3-6-2-参与者及用例的描述" class="headerlink" title="3.6.2 参与者及用例的描述"></a>3.6.2 参与者及用例的描述</h3><ul><li>参与者描述的内容主要包括参与者的名称、是否为抽象参者与及对参与者的简要描述。</li><li><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111222000449.png" alt="参与者规格说明"></li><li>用例描述有许多种方法，如简单文字、模板、表格、形式化语言和图形等，开发人员可根据项目进展及用户特点灵活选择。</li></ul><h3 id="3-6-3-用例建模步骤"><a href="#3-6-3-用例建模步骤" class="headerlink" title="3.6.3 用例建模步骤"></a>3.6.3 用例建模步骤</h3><ol><li>找出系统的参与者和用例；<br>（<strong>在选择参与者时</strong>，有两个非常有用的标准：首先，应该能至少确定一个用户来扮演参与者；其次，与系统相关的不同参与者实例所充当的角色间的重叠应该最少。<strong>在确定用例时</strong>，“有价值的结果”和“特定参与者”是两个有用的准则。）</li><li>区分用例的优先次序；</li><li>详细描述每个用例；</li><li>构造用户界面原型；</li><li>构造用例图。</li></ol><p>（用例的结构关系应尽量反映真实情况；需要将每个单独的用例视为一个单独的制品；应尽量避免从功能上分解用例。）</p><h2 id="3-7-面向对象建模"><a href="#3-7-面向对象建模" class="headerlink" title="3.7 面向对象建模"></a>3.7 面向对象建模</h2><ul><li><p>对象建模的主要任务是了解某个特定应用问题域内所涉及的对象，以及各种各样的结构和通信关系。</p></li><li><p>面向对象方法学的三原则：</p><ol><li>一切事物皆对象</li><li>任何系统都由对象构成，系统本身也是对象</li><li>系统的发展和进化过程都是由系统的内部对象和外部对象（内部对象）之间的相互作用完成的</li></ol></li><li><p>面向对象方法的主要特征：</p><ul><li>由对象组成的，软件中的任何元素都是对象</li><li>将所有对象划分成各种类，每个类都定义一组数据和一组方法</li><li>按照子类和父类的关系，将若干类组成一个层次的系统</li><li><p>对象与对象之间只能通过传递消息进行通信</p></li><li><p><strong>面向对象=对象+类+继承+通信</strong></p></li></ul></li><li><p>封装、继承与多态是面向对象方法区别于传统的结构化方法的三个主要特点。</p><ul><li><p>封装：是指其类与对象把数据和操纵数据的方法合在一起构成一个整体，外部只能通过消息来同对象打交道。</p></li><li><p>继承：子类可以继承父类的所有属性和方法</p></li><li><p>多态：指为不同数据类型的实体提供统一的接口，或使用一个单一的符号来表示多个不同的类型。</p></li></ul></li></ul><h3 id="3-7-1-确定对象-amp-类（对象层）"><a href="#3-7-1-确定对象-amp-类（对象层）" class="headerlink" title="3.7.1 确定对象&amp;类（对象层）"></a>3.7.1 确定对象&amp;类（对象层）</h3><ul><li>对象是现实世界某些事物的一个抽象，它反映该事物在系统中需要保存的信息和发挥作用。</li><li>类是具有相同属性和操作的一组对象的集合。</li><li>方法：<ul><li>三视图模型法（实体一关系模型、数据流模型、状态—迁移模型）</li><li>基于语言的信息分析法（短语频率分析、矩阵分析）；类职责协作（Class—Reponsibility—Collaboration，CRC）卡片。</li></ul></li><li>应该说明的是：①最后得到的对象&amp;类不可能被证明是绝对正确或绝对错误；②用户的偏好对模型最后所选择的对象&amp;类有很大的影响。</li></ul><h3 id="3-7-2-标识结构（结构层）"><a href="#3-7-2-标识结构（结构层）" class="headerlink" title="3.7.2 标识结构（结构层）"></a>3.7.2 标识结构（结构层）</h3><ul><li>标识结构是用来处理对象建模复杂性的机制之一。</li><li>现实世界的事物之间有两种主要关系：继承关系、整体/部分关系。</li><li><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111222124700.png" alt="image-20211122212458646"></li><li>对于分类继承关系，可以采用如下的方式来标识：自顶向下和自底向上方式。</li><li>对于整体/部分的聚合和组合关系，一方面，把每一个对象的类看成是一个整体，考虑：什么是它的部分或组成成份。另一方面，把每一个对象的类看成一个部件，考虑：该对象的类适合什么样的组装整体。</li></ul><h3 id="3-7-3-标识主题（主题层）"><a href="#3-7-3-标识主题（主题层）" class="headerlink" title="3.7.3 标识主题（主题层）"></a>3.7.3 标识主题（主题层）</h3><ul><li><p>方法：</p><ul><li>对每一个结构增加一个相应的主题；</li><li>对每个对象增加一个相应的主题；</li><li>将紧密耦合的主题组合起来得到更好的主题；</li><li>如果主题的数目较多不符合“7±2规则”，则应进一步精炼主题。</li></ul><p>注：1. 在选择主题时，不应用功能分解方法，开发人员可以依据子问题域、子系统，甚至组织或地域来区分主题。</p><ol><li>若将一个主题看成是问题域中的整体/部分关系，即问题域由主题组成，则对建立模型很有用。</li></ol></li></ul><h3 id="3-7-4-定义属性及实力关联（属性层）"><a href="#3-7-4-定义属性及实力关联（属性层）" class="headerlink" title="3.7.4 定义属性及实力关联（属性层）"></a>3.7.4 定义属性及实力关联（属性层）</h3><ul><li>属性是对象&amp;类的数据单元，定义属性使得问题域更加明确，也使对对象&amp;类和结构的认识更深入具体。</li><li>在分析阶段，一般不使用属性来表示对象&amp;类之间的关系，而使用对象&amp;类的实例关联来描述。</li><li>实例关联可以看成是一种事务规则或应用论域限制。当实现这些对象的时侯，这些事务规则指明操作如何运行，以确保与系统的策略相一致。</li><li>在UML中，实例的关联表示包括：关联名称、角色名称、多重性和导航性；</li><li>一般，在图中要么注明关联名称，要么注明角色名称，而不同时注明角色名称和关联名称；</li><li>在UML中，多重性被说明为用逗号分隔的区间，每个区间具有如下形式：minimum、maximum ；在UML中，如果多重性不显式说明，则多重性就不确定；</li><li>导航性的意义可看做“消息仅能够沿箭头所指的方向传递”。在UML中，没有导航性标识，则表示关联是双向的。</li><li>属性定义：<ul><li>分类：描述性、命名性、参考属性</li><li>定义属性应该在原子概念的层次上进行。</li><li>方法：依据属性的种类考察每个对象&amp;类可帮助定义属性；如果已建立数据视图，如IDEF1X图，ER图，数据视图中的实体的属性表示了存储数据的需求，这些存储数据的需求必须体现在模型中，一般作为对象&amp;类的属性；另外，通过考察对象的描述，也可为定义属性提供帮助。</li><li>对于分类结构，应该利用继承机制来定位属性的位置。</li></ul></li><li>实力关联定义：<ul><li>实例关联反映了对象&amp;类的实例之间的相互依赖、相互作用的关系。整体/部分关系是一种特殊的实例关联。</li><li>方法：直接提取需求陈述中的动词词组；领域知识；矩阵分析；等。</li><li>实例关联应仅选择哪些系统必须维持的实例对应关系。</li></ul></li></ul><h3 id="3-7-5-定义服务及消息连接（服务层）"><a href="#3-7-5-定义服务及消息连接（服务层）" class="headerlink" title="3.7.5 定义服务及消息连接（服务层）"></a>3.7.5 定义服务及消息连接（服务层）</h3><ul><li>定义服务也即标识对象&amp;类的操作。对象&amp;类所执行的操作以及对象之间传递的消息反映了对象&amp;类的动态关系，也即系统的动态方面。</li><li>定义服务的方法：考察系统的责任；研究问题域；分析对象&amp;类状态或追踪对象&amp;类的执行线路；用例模型中的事件流</li><li>定义消息连接：<ul><li>在对象建模中，消息是对象&amp;类之间在行为上的唯一联系方式。</li><li>方法：在已经存在实例连接的对象&amp;类和分类结构之间增加消息连接；检查对象&amp;类和分类结构，寻找一个实例所需要的另一个实例的操作。</li><li>在UML的类图中，可以采用实例关联的导航性来表示消息连接。也可采用单独的协作图或顺序图来描述对象&amp;类实例的消息连接。</li></ul></li></ul><h2 id="3-8-统一建模语言UML"><a href="#3-8-统一建模语言UML" class="headerlink" title="3.8 统一建模语言UML"></a>3.8 统一建模语言UML</h2><blockquote><p>UML（Unified Modeling Language, UML）是一种可以应用于任面向对象软件开发方法的标记法和语义语言。</p></blockquote><h3 id="3-8-1-UML结构"><a href="#3-8-1-UML结构" class="headerlink" title="3.8.1 UML结构"></a>3.8.1 UML结构</h3><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111222139523.png" alt="UML结构"></p><ul><li><p>关系：<a target="_blank" rel="noopener" href="http://igiggle.cn/archives/u-m-l-lei-tu-yi-ji-lei-jian-guan-xi--fan-hua---shi-xian--yi-lai--guan-lian--ju-he--zu-he-">UML类图以及类间关系(泛化 、实现、依赖、关联、聚合、组合)</a></p><p>| 关系 | 标记法 | 说明 |<br>| ————- | ————————————— | —————————————— |<br>| 关联 | —————————— | 对象之间的一组连接 |<br>| 依赖 | -·-·-·-·-&gt; | 物件的改变引起依赖物件的改变 |<br>| 泛化/继承 | —————————$\triangleright $ | 继承父类 |<br>| 实现 | - - - - -$\triangleright $ | 实现接口或者抽象类 |</p></li><li><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111222204232.png" alt="视图框架"></p></li><li><p>类图：</p><ul><li>描述了对象的结构</li><li>关键元素是类元（类、接口等）以及它们之间的关系</li><li>类元之间有关联、泛化及各种不同的依赖关系，包括实现和使用关系。</li><li><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111222207944.png" alt="image-20211122220758890" style="zoom:67%"></li></ul></li><li><p>包图</p><ul><li>包图由包或类组成，表示包与包、包与类之间的关系，用于描述系统的分层结构。</li><li>包图中包用文件夹图形来描述。</li><li><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111222208593.png" alt="包图"></li></ul></li><li><p>组件图</p><ul><li>组件图，又称构件图，用来描述软件的各个组件（包括源代码文件、二进制文件、脚本、可执行文件等）之间的依赖关系。</li><li>在UML中，组件使用左侧带两个小矩形的大矩形表示。</li><li><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111222209939.png" alt="组件图"></li></ul></li><li><p>部署图</p><ul><li>部署图，又称配置图，显示的是对运行时处理节点以及其中的组件的配置，反映了系统硬件的物理拓扑结构。</li><li>在UML中，节点用一个三维矩形表示。</li><li><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111222210583.png" alt="部署图"></li></ul></li><li><p>对象图</p><ul><li>对象图描述的一组对象以及它们之间的关系。</li><li>对象是类的一个具体实例，在UML中采用矩阵形表示。其中标明对象名和属性取值。</li><li><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111222210118.png" alt="对象图"></li></ul></li><li><p>用例图</p><ul><li>用例图从系统外部执行者的角度来描述系统需要提供哪些功能，指明这些功能的参与者，即用例图描述了参与者和用例及它们之间的关系。</li></ul></li><li><p>顺序图</p><ul><li>顺序图用来建模以时间顺序安排的对象间的交互。</li><li><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111222211057.png" alt="顺序图"></li></ul></li><li><p>协作图</p><ul><li>协作图，又称合作图，用来建模对象或角色之间的交互，描述这些对象或角色之间是如何彼此通信的。</li><li><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111222212002.png" alt="协作图"></li></ul></li><li><p>状态图</p><ul><li>状态图描述一个类对象所经历的各种状态以及事件发生时状态的转移条件。</li><li><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111222213097.png" alt="状态图"></li></ul></li><li><p>活动图</p><ul><li>活动图是由状态图变化而来的，描述需要执行的活动以及执行这些活动的顺序。</li><li><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111222213773.png" alt="活动图"></li><li><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111222214058.png" alt="泳道形式的活动图示例" style="zoom:50%"></li></ul></li></ul><h3 id="3-8-2-特点"><a href="#3-8-2-特点" class="headerlink" title="3.8.2 特点"></a>3.8.2 特点</h3><ol><li>统一了面向对象方法的基本概念 ；</li><li>具有更强的建模能力 ；</li><li>独立于特定的开发语言和开发过程。</li></ol><h3 id="3-8-3-应用"><a href="#3-8-3-应用" class="headerlink" title="3.8.3 应用"></a>3.8.3 应用</h3><ol><li><p>需求分析</p><p>用例图—-功能的需求；类图—-静态结构 ；</p><p>状态图、顺序图和协作图等—-类之间所需的协作，实现用例。</p></li><li><p>设计</p><p>定义软件系统中的技术细节用到的类，如引入处理用户交互的类、处理数据的类、处理通信和并行性的类等。</p></li><li><p>实现</p><p>组件图—-代码组件的物理结构以及组件之间的关系；部署图—-硬件的拓扑结构和组件的分布。</p></li><li><p>测试</p><p>类图—-单元测试；组件图、协作图—-集成测试；用例图 —-确认测试</p></li></ol><h1 id="第四章-软件设计"><a href="#第四章-软件设计" class="headerlink" title="第四章 软件设计"></a>第四章 软件设计</h1><h2 id="4-1-软件设计的任务和过程"><a href="#4-1-软件设计的任务和过程" class="headerlink" title="4.1 软件设计的任务和过程"></a>4.1 软件设计的任务和过程</h2><ul><li>概要设计的主要任务是回答“系统总体上应该如何做？”，即将分析模型映射为具体的软件结构。</li><li>详细设计则将概要设计的结果具体化，其主要任务是确定软件系统各组组成成分内部的数据结构和算法过程。</li><li>过程：<ol><li>数据设计（对象设计）：设计数据结构（类的属性）</li><li>软件结构（子系统）设计：定义主要元素间的关系（划分子系统）</li><li>接口（消息）设计：系统内部、系统之间、系统与用户如何通信</li><li>过程（方法）设计：得到系统各个功能的过程化描述</li></ol></li></ul><h2 id="4-2-软件设计基本原则"><a href="#4-2-软件设计基本原则" class="headerlink" title="4.2 软件设计基本原则"></a>4.2 软件设计基本原则</h2><h3 id="4-2-1-抽象与求精"><a href="#4-2-1-抽象与求精" class="headerlink" title="4.2.1 抽象与求精"></a>4.2.1 抽象与求精</h3><ul><li>抽象是一种常用的思考和解决问题的方式，即抽取事物的本质的共同特性而暂时避开不必要的低层细节。</li><li>方式：过程抽象、数据抽象和控制抽象。</li><li>抽象过程是指具有特定功能的一个命名的指令序列。（如：二维图形创建 ）</li><li>抽象数据则是描述数据对象的一个命名的数据集合。（如：“图画”数据对象 ）</li><li>抽象控制包含了一种程序控制机制而无须刻画其内部细节。（如：操作系统中的“同步信号量”）</li><li>求精是由N. Wirth最初提出的一种自顶向下设计策略，其主要思想是：将某个宏观功能不断分解，逐步确定过程细节，直至用程序设计语言描述的算法实现为止。</li><li>抽象使得设计人员能够避开过早地陷入细节之中刻画过程和数据。</li><li>求精能够帮助设计人员随着设计过程的深入而不断呈现更低层次的信息。</li></ul><h3 id="4-2-2-模块化和信息隐藏"><a href="#4-2-2-模块化和信息隐藏" class="headerlink" title="4.2.2 模块化和信息隐藏"></a>4.2.2 模块化和信息隐藏</h3><ul><li>软件应该分解成可单独命名的且可访问的部件，这些部件称为模块。</li><li>分而治之：把一个大问题分解成若干小问题来解决时将会更加容易。</li><li><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111222330549.png" alt="image-20211122233026420"></li><li>信息隐藏：是指模块中所包含的信息（包括数据和过程）对不需要这些信息的其它模块是不可访问的。</li><li>抽象有助于定义组成软件的过程（或信息）实体</li><li>隐藏定义并加强了对模块内部访问的约束，有助于分离模块的实现者和使用者。</li></ul><h3 id="4-2-3-模块独立性"><a href="#4-2-3-模块独立性" class="headerlink" title="4.2.3 模块独立性"></a>4.2.3 模块独立性</h3><ul><li><p>模块独立性：是模块化、抽象和信息隐藏的直接产物，其基本含义是每一个模块只完成功能需求中的一个特定的子功能，而且从程序结构的其它部分来看这一模块只具有一个简单的接口</p></li><li><p>模块的功能独立性可以使得模块既容易开发又容易维护。</p></li><li><p>模块独立性有两个定性的度量标准：内聚度和耦合度。</p></li><li><p>内聚度：</p><ul><li>内聚度（Cohesion）是指模块内部各成分联系紧密的程度。</li><li>通常，内聚度越高，模块的独立性就越强。</li><li>内聚程度从高到低的顺序是：功能内聚、信息内聚、通信内聚、过程内聚、时间内聚、逻辑内聚和偶然内聚。</li><li>设计模块时，应该尽可能<strong>避免</strong>使用偶然内聚等低级内聚的模块，<strong>争取</strong>高级内聚的模块，以提高模块的独立性。</li></ul><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111222342563.png" alt="image-20211122234256412"></p></li><li><p>耦合度：</p><ul><li>耦合（Coupling）是模块之间相互关联紧密的程度。</li><li>一般地，模块的耦合度越低，模块的独立性越强。</li><li>模块之间的耦合程度从低到高也可分为七种：非直接耦合、数据耦合、标记耦合、控制耦合、外部耦合、公共耦合、内容耦合。</li><li>在设计模块时，应该<strong>尽量</strong>使用数据耦合，<strong>必要时</strong>使用标记耦合，<strong>少用</strong>控制耦合，限制使用公共耦合，<strong>最好不要</strong>使用内容耦合。</li></ul><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111222353750.png" alt="image-20211122235314594"></p></li></ul><h2 id="4-3-面向数据流图的设计方法"><a href="#4-3-面向数据流图的设计方法" class="headerlink" title="4.3 面向数据流图的设计方法"></a>4.3 面向数据流图的设计方法</h2><ul><li><p>面向数据流图的设计方法是一种结构化设计方法</p></li><li><p>两种设计方法：数据流分析和事务分析</p></li><li><p>过程：</p><ol><li>研究、分析和审查数据流图，确保数据流图符合实际，必要时还要进一步精化数据流图。</li><li>确定数据流图的类型，即变换型数据流或事务型数据流。</li><li>再依据数据流图的类型采用变换分析法或事务分析法导出系统初始的软件结构。</li><li>依据软件设计原理和一些优化策略改进系统初始的软件结构，形成最终的软件结构。</li></ol></li></ul><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111231422860.png" alt="结构化分析模型转换为结构化设计模型示意图"></p><h3 id="4-3-1-层次图和改进的IPO图"><a href="#4-3-1-层次图和改进的IPO图" class="headerlink" title="4.3.1 层次图和改进的IPO图"></a>4.3.1 层次图和改进的IPO图</h3><ul><li>层次图主要用来描绘软件的层次结构，矩形框代表一个模块，矩形框间的连线表示模块间的调用关系。层次图很适于在自顶向下设计软件的过程中使用，且常与IPO图一起使用，形成HPO图，层次图中的每个方框对应一个IPO图。为了使用方便，在层<br>次图中除顶层外，每个方框都加了编号，且对IPO图进行了改进。</li><li><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111231432330.png" alt="层次图示例"></li><li><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111231432881.png" alt="改进的IPO图示例"></li></ul><h3 id="4-3-2-软件结构图"><a href="#4-3-2-软件结构图" class="headerlink" title="4.3.2 软件结构图"></a>4.3.2 软件结构图</h3><ul><li>在结构化设计方法中，软件结构是软件系统模块层次结构，反映了整个系统功能及其之间的关系。</li><li>软件结构图的主要内容有：<ul><li>模块<ul><li>6种：传入模块、传出模块、变换模块、协调模块、源模块和漏模块</li><li>用<strong>方框</strong>表示，并用名字标识方框</li></ul></li><li>模块间的调用关系<ul><li>三种：顺序调用、选择调用、循环调用</li><li>方框之间的箭头表示模块之间的调用与被调用关系。</li><li>模块间调用的次序，习惯上是<strong>从左至右</strong>。</li><li><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111231426058.png" alt="三种调用关系"></li></ul></li><li>模块之间传递的信息。<ul><li>模块传递的信息用带名称的<strong>短线箭头</strong>来表示。箭头方向代表信息传递的方向。</li><li>若箭头线尾是带<strong>空心圆圈</strong>，则表示该箭头线代表的是<strong>数据</strong>；若箭头线尾是带<strong>实心圆圈</strong>，则表示该箭头线代表的是<strong>控制</strong></li><li><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111231427195.png" alt="image-20211123142707153" style="zoom:33%"></li></ul></li></ul></li></ul><h3 id="4-3-3-数据流变换分析法"><a href="#4-3-3-数据流变换分析法" class="headerlink" title="4.3.3 数据流变换分析法"></a>4.3.3 数据流变换分析法</h3><ul><li><p>数据流变换分析法是一种将变换型数据流图映射为变换型软件结构图的软件系统设计方法。</p></li><li><p>变换型数据流图一般呈线性形状，大致由三部分组成：传入路径、变换中心和传出路径。</p></li><li><p>变换型软件结构图则大致由四部分模块组成：输入模块、中心加工模块，输出模块和主控模块。</p></li><li><p>传入、传出路径和交换中心的标识</p><ul><li>一般，可以采用<strong>试探的办法</strong>来确定系统的变换中心和传入/传出路径。</li><li>从数据流图的物理输入始端出发，沿数据流一步步往数据流图的输出末端移动，直到遇到的数据流不能再被看作是系统的输入数据为止，则其前一个数据流便是<strong>系统的逻辑输入</strong>。</li><li>从数据流图的物理输出未端一步步往数据流图的输入始端移动，直到遇到的数据流不能再被看作是系统的输入数据为止，则其后一个数据流便是<strong>系统的逻辑输出</strong>。</li><li>从物理输入始端至系统的逻辑输入构成系统的<strong>传入路径部分</strong>。从物理输出未端至系统的逻辑输出构成系统的<strong>传出路径部分</strong>。逻辑输入和逻辑输出之间的部分构成<strong>变换中心部分</strong>。</li></ul></li><li><p>例子：</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111231444778.png" alt="例4-3-1"></p><p>在找出系统的传入/传出路径和变换中心后，在数据流图中用分界线来标识它们。</p><ul><li><p>一级分解：</p><ul><li>将数据流图映射为一个能为信息的输入、变换和输出提供控制的特定结构。</li></ul><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111231445368.png" alt="一级分解"></p></li><li><p>二级分解：</p><ul><li>将数据流图中的每一个加工处理映射为软件结构图中一个模块。</li><li>对于<strong>传入路径中的加工处理</strong>，从变换中心的边界开始，沿着传入路径向外移动，把传入路径中遇到的每个加工处理映射成软件结构图中输入信息处理控制模块直接或间接调用的模块。</li><li>对于<strong>传出路径中的加工处理</strong>，从变换中心的边界开始，沿着传出路径向外移动，把传出路径中遇到的每个加工处理映射成软件结构图中输出信息处理控制模块直接或间接调用的模块。</li><li>对于<strong>变换中心的加工处理</strong>，则直接映射为变换流控制模块直接调用的模块。</li></ul><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111231446573.png" alt="二级分解"></p></li></ul></li></ul><h3 id="4-3-4-事务分析法"><a href="#4-3-4-事务分析法" class="headerlink" title="4.3.4 事务分析法"></a>4.3.4 事务分析法</h3><ul><li><p>事务分析法是将事务型数据流图映射为事务型软件结构图的软件系统设计方法。</p></li><li><p>事务型数据流图一般呈幅射状，由三部分组成，即至少一条接收路径、一个事务中心和若干条动作路径。</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111231449294.png" alt="事务型数据流图"></p></li><li><p>事务型软件结构图大致由四部分模块构成。事务接受模块、事务调度模块、事务处理控制模块和总控模块。</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111231450529.png" alt="事务型软件结构图"></p></li><li><p>数据流图事务中心的标识</p><ul><li>事务中心一般位于几条动作路径的起始点上。</li><li>动作路径具有自己的结构特征，可能是事务型的，也可能是变换型的。在标识事务中心的同时，还应确定每条动作路径的结构特征，并在数据流图中标识。</li></ul></li><li><p>例子：</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111231451307.png" alt="例4-3-2"></p><ul><li><p>一级分解</p><ul><li>将事务型的数据流图图映射到包含一个事务接收分支和一个事务分类处理分支的软件结构上。</li></ul><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111231452193.png" alt="一级分解"></p></li><li><p>二级分解</p><ul><li>细化事务接收模块和事务处理控制模块。</li><li>从事务中心开始，沿接收路径的变换被映射成事务接收模块直接或间调用的模块。</li><li>数据流图的每一条动作路径映射成与其自身的数据流图类型相一致的软件结构，其方法是变换分析法或事务分析法。</li></ul><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111231454757.png" alt="二级分解"></p></li></ul><h4 id="4-3-5-改进"><a href="#4-3-5-改进" class="headerlink" title="4.3.5 改进"></a>4.3.5 改进</h4><ul><li>在改进软件结构时应该记住“一个不能工作的最佳设计”是毫无价值的。</li><li>设计人员应该致力于设计能够满足所有功能和性能要求，而且按照设计原理和改进规则衡量是值得接收的软件。</li></ul><ol><li>模块大小适中<ul><li>模块大小影响模块的可理解性。</li><li>限制模块的大小也是减少软件复杂性的手段之一。</li><li><strong>对于规模较大的模块，检查其包含的功能，从中分离出一些功能构成软件结构图中的同层或下一层的其它模块。</strong></li><li><strong>对于规模较小的模块，应考虑是否可以同它的上层调用模块合并。</strong></li></ul></li><li>模块扇入扇出合理<ul><li>模块的扇出是指模块直接调用多少其它模块。</li><li>模块的扇入是指共有多个模块直接调用本模块。</li><li>模块的扇出过大，表明该模块过分复杂，需要协调和控制过多的下层模块。</li><li>模块的扇入过大，而它又不是公用模块，一般来说明该模块可能具有多个功能。</li><li>一个模块的扇出不要超过7个(7土2原则)，否则应考虑<strong>重新分解</strong>，如增加中间层但如果模块功能是“分类”，则顺其自然，不受限制。</li><li>经验表明，良好的软件结构图，上层模快（主要是控制模块）往往具有较高的扇出，底层的模块（主要是功能型模块）具有较高的扇入，呈两头小、中间大的清真寺状。</li></ul></li><li>模块的作用域应在控制域内<ul><li>模块的作用域是指模块中判定的作用范围，它是指所有受这个判定影响的模块。</li><li>模块的控制域是指模块本身及其直接或间接调用的模块。</li><li>如果模块的作用域不在控制域之内，则会增加模块间数据的传递量，使模块之间出现控制耦合。</li><li>可从以下几个方面对结构图进行改造:<ul><li>将做判定的模块合并到它的上层调用模块中，从而使判定处于足够高的层次。</li><li>将受判定影响的模块下移到控制范围内。</li><li>将判定上移到层次较高的位置</li></ul></li></ul></li></ol></li></ul><h2 id="4-4-面向对象设计原则"><a href="#4-4-面向对象设计原则" class="headerlink" title="4.4 面向对象设计原则"></a>4.4 面向对象设计原则</h2><div class="table-container"><table><thead><tr><th>原则</th><th>定义</th></tr></thead><tbody><tr><td>单一职责原则</td><td>一个对象只包含单一的职责，并且该职责被完整地封装在一个类中</td></tr><tr><td>开闭原则</td><td>对拓展开放，对修改关闭</td></tr><tr><td>里氏替换原则</td><td>使用基类的地方必须能透明地使用其子类</td></tr><tr><td>依赖倒转原则</td><td>高层模块不应该依赖低层模块，应该以来抽象。抽象不应该依赖于细节，细节应该依赖于抽象</td></tr><tr><td>接口隔离原则</td><td>客户端不应该依赖那些不需要的接口</td></tr><tr><td>合成复用原则</td><td>优先使用对象组合，而不是通过继承来达到复用的目的</td></tr><tr><td>迪米特法则</td><td>每一个软件单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位</td></tr></tbody></table></div><h2 id="4-5-面向对象的设计方法"><a href="#4-5-面向对象的设计方法" class="headerlink" title="4.5 面向对象的设计方法"></a>4.5 面向对象的设计方法</h2><h3 id="4-5-1-软件复用"><a href="#4-5-1-软件复用" class="headerlink" title="4.5.1 软件复用"></a>4.5.1 软件复用</h3><ul><li>软件复用：是指软件开发过程中重复使用相同或相似的软件元素</li><li>目标：缩短开发周期、降低维护代价、可靠性、高效性、一致性、保护投资</li><li>对象：<ul><li>个人的复用</li><li>设计和功能规格说明的复用</li><li>设计模式的复用</li><li>源代码的复用</li><li>抽象模块的复用</li></ul></li><li>阻力<ul><li>管理人员：纠正开发人员不愿意复用的思想</li><li>经济方面：软件开发人员不愿意写得通用，害怕无事可做</li><li>软件部件的管理：没有有效的管理</li><li>增加的开发费用：将软件转换成可复用的软件部件需要付出很大的代价</li><li>法律方面：版权问题</li></ul></li><li>对模块化结构的要求<ul><li>类型可变：高层次设计软件模块时可能规定了通用类型，因此需要支持不同的类型</li><li>例程组合：在设计可复用的软件部件的时候，相关的例程应该能组成一个包</li><li>实现可变：多种实现方式</li><li>表示独立性：使用者只关心接口，不关系实现细节</li><li>抽出共同的行为</li></ul></li></ul><h3 id="4-5-2-面向对象设计"><a href="#4-5-2-面向对象设计" class="headerlink" title="4.5.2 面向对象设计"></a>4.5.2 面向对象设计</h3><ol><li><p>子系统设计</p><ol><li><p>问题域部分设计</p><ul><li>最能反映用户需求的一个部件，也是面向对象需求分析中已经做了分析的部件。</li><li>修改<ul><li>调整需求；</li><li>重用已有的类；</li><li>将问题域有关的类组成一组，并建立一个公共的协议；</li><li>对继承进行调整，以利于实现；</li><li>提高性能。</li></ul></li></ul></li><li><p>人机交互部分设计</p><ul><li>人机交互部分突出人如保命令系统以及系统如何向用户提供交互信息。</li><li>在设计人机交互部分时，首先考虑的是人，其次是任务，然后再是有关工具。</li><li>人机交互部分在系统行为和用户界面之间架起了一座桥梁。</li><li>主要对象：窗口和报表</li><li>三类窗口<ul><li>登录窗口：进入系统的必经之路</li><li>设置窗口：三个目的：①建立和初始化系统正常运行所必需的对象，如建立、维护和删除持久性对象的窗口。②完成系统管理功能，如增加和删除授权使用系统的用户，或设置用户使用系统的权限级别。③由人来激活或关闭系统中的设备，如打印机、CD-ROM、视频摄像机等。</li><li>商务功能窗口：人机交互来完成商务功能</li></ul></li></ul></li><li><p>数据管理部件的设计</p><p>目的：</p><ol><li>用于存储问题域中持久性的对象</li><li>用于封装问题域中持久性对象的存储和检索机制</li></ol></li><li><p>系统交互部件的设计</p><p>主要负责系统与系统的物理设备之间、各子系统之间以及系统与其他系统之间的通信和数据交换</p></li></ol></li><li><p>对象设计</p><p>对每一个对象中的数据部分进行设计，得到每一个对象的更为准确的属性，然后设计这个属性相应的数据结构</p></li><li><p>消息设计</p><ul><li>描述每一个对象可以接收和发送消息的接口</li><li>出发点：<ul><li>对象与对象之间的关系，实质上代表相互之间传递消息的关系</li><li>对象与对象之间的事件跟踪图也是消息设计的一个出发点</li></ul></li></ul></li><li><p>方法设计</p><p>目的：</p><ul><li>将之前遗漏的方法找出来</li><li>定义每一种方法过程化的细节</li></ul></li></ol><h2 id="4-6-面向对象软件设计模式"><a href="#4-6-面向对象软件设计模式" class="headerlink" title="4.6 面向对象软件设计模式"></a>4.6 面向对象软件设计模式</h2><ul><li>设计模式是指系统地命名、解释和评价某一重要的、可重用的面向对象设计方案</li></ul><h3 id="4-6-1-创建型模式"><a href="#4-6-1-创建型模式" class="headerlink" title="4.6.1 创建型模式"></a>4.6.1 创建型模式</h3><ol><li><p>工厂方法模式</p><ul><li><p>适用情况：</p><ul><li><p>一个类不知道他所创建的对象的类</p></li><li><p>一个类希望由其子类确定他创建的对象</p></li><li><p>类将创建对象的职责分配给多个帮助者子类中的一个，且将哪一个帮助者子类作为代表这项信息布局化</p></li></ul></li><li><p>使用效果：</p><ul><li>比直接产生对象更加灵活</li><li>连接平行类层次，可见下图</li></ul></li><li><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111231729997.png" alt="工厂方法示例"></p></li></ul></li><li><p>抽象工厂模式</p><ul><li>适用情景：<ul><li>系统与如何创建、组合和表示其产品无关</li><li>系统由多个产品族之一来配置</li><li>强调一系列相关产品对象的设计以便联合使用</li><li>提供一个产品类库，旦只想显示其接口。</li></ul></li><li>使用效果：<ul><li>隔离了具体的类</li><li>使产品族间的转换容易进行</li><li>容易实现一次应用只使用同一个系统中的产品对象</li><li>难以扩展抽象工厂以支持新种类的产品。</li></ul></li></ul></li></ol><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111231732603.png" alt="抽象工厂模式"></p><h3 id="4-6-2-结构型模式"><a href="#4-6-2-结构型模式" class="headerlink" title="4.6.2 结构型模式"></a>4.6.2 结构型模式</h3><ol><li><p>适配器模式</p><ul><li>适用情景：<ul><li>希望使用一个已存在的类，但它的接口与希望的接口不匹配</li><li>要创建一个可复用的类，该类可以与其他不相关的类或不可预见的类协同工作</li><li>想使用一些已存在的类，但不能对每一个类子类化以匹配它们的接口（仅适用于对象组合的适配器模式）。</li></ul></li></ul><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111231740240.png" alt="适配器模式"></p></li><li><p>组合模式</p><ul><li>使用条件：<ul><li>希望表示对象的整体、部分层次结构</li><li>希望一致的处理叶子对象和组合对象</li></ul></li><li>使用效果：<ul><li>定义了对象的整体/部分层次结构，且客户代码中任何用到叶子对象的地方均可使用组合对象</li><li>简化了客户代码，客户代码不必关心处理的是叶子对象还是组合对象，即可以一致地使用叶子对象和组合对象</li><li>易于添加新的组合子类和叶子子类，客户代码不必因新的组合子类和叶子子类而改变；</li><li>使设计更加通用，但难于实现只组合某些特定的部件限制。</li></ul></li><li><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111231744054.png" alt="组合模式"></li></ul></li></ol><h3 id="4-6-3-行为型模式"><a href="#4-6-3-行为型模式" class="headerlink" title="4.6.3 行为型模式"></a>4.6.3 行为型模式</h3><ol><li><p>迭代器模式</p><ul><li>使用条件<ul><li>在不暴露聚合对象内部表示的条件下访问聚集对象。</li><li>支持对聚合对象的多种遍历。</li><li>为遍历不同的聚合对象提供一个统一接口。</li></ul></li><li>使用效果<ul><li>支持以不同的方式遍历聚合对象。</li><li>简化了聚合对象的接口。迭代器的遍历接口使聚合对象本身不再需要类似的遍历接口。</li><li>由于每个迭代器保持它自己的遍历状态，因此可以在同一个聚合对象进行多种遍历。</li></ul></li><li><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111231755159.png" alt="迭代器模式"></li></ul></li><li><p>观察者模式</p><ul><li>适用条件<ul><li>一个模型有两个方面，其中一方面依赖于另一方面。将二者分别封装在独立的对象中可使它们可以各自独立地改变和复用。</li><li>一个对象的改变需要同时改变其它对象，且不知道有多少对象需改变。</li><li>一个对象必须能够在对别的对象一无所知的情况下通知它们。</li></ul></li><li>使用效果<ul><li>减少了Subject类和Observer类之间的耦合。</li><li>支持广播通信。主题发送的通知不需指定它的接收者。处理还是忽略一个通知取决于观察者。</li><li>可能会发生预想不到的更新。在主题上一个看似无关紧要的操作可能会引起一系列对观察者以及依赖这些观察者的那些对象的更新。</li></ul></li></ul><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111231756311.png" alt=""></p></li></ol><h2 id="4-7-模型一视图一控制器框架"><a href="#4-7-模型一视图一控制器框架" class="headerlink" title="4.7 模型一视图一控制器框架"></a>4.7 模型一视图一控制器框架</h2><ul><li><p>模型－视图－控制器（Model-View-Controller， MVC）框架结构是为那些需要为同一数据提供多个视图的应用程序而设计的，它很好的实现了数据层与表示层的分离。</p></li><li><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111231801066.png" alt="MVC框架中类的交互"></p><ol><li><p>当用户进行一些输入动作后，控制器接收用户事件，并根据事件的类型来改变模型</p></li><li><p>视图事先会在模型中登记，当模型数据发生改变时，马上通知已向此模型登记的每个视图，视图从模型中取得最新的数据并刷新自己。</p></li></ol></li></ul><h2 id="4-8-软件体系结构"><a href="#4-8-软件体系结构" class="headerlink" title="4.8 软件体系结构"></a>4.8 软件体系结构</h2><ul><li>SEI 定义:软件体系结构是指一个程序/系统构件的结构，它们之间的相互关系， 以及在设计和交付的整个过程中的原则和指导方针.<br>Mary Shaw 和 David Garlan 认为， 软件体系结构包括构成系统的设计元素的描述，设计元素的交互，设计元素组合的模式，以及在这些模式中的约束。<br>国内普遍定义:软件体系结构包括构件、连接件和约束，它是可预制和可重构的软件框<br>架结构。 构件是可预制和可重用的软件部件，是组成体系结构的基本计算单元或数据存储单元;连接件也是可预制和可重用的软件部件，是构件之间的连接单元;构件和连接件之间的关系用约束来描述</li><li>软件体系结构包括：构件(Component)、连接件(Connector)和约束(Constraint)或配置(Configuration)三大要素。<ul><li>构件：<ul><li>是指一个计算单元或者数据存储单元，可以是一个处理过程或数据元素</li><li>构件是用于实现计算和状态的单元，可以工作在：客户端、服务器端、数据库或层等。</li></ul></li><li>连接件：<ul><li>连接件是体系结构的一个元素，它可以用于建模：<ul><li>构件之间的相互作用</li><li>控制这些相互作用的规则</li></ul></li></ul></li><li>约束<ul><li>约束描述了体系结构的配置和拓扑要求，配置或拓扑是指构件和连接件组成的一个连接图，它用于描述软件体系结构的构成，确定了体系结构的构件与连接件之间的连接关系：<ul><li>正确的连接性</li><li>并发和分布性</li><li>符合设计的启发式和风格规则</li></ul></li></ul></li></ul></li><li>软件体系结构优势：<ul><li>易理解</li><li>可重用</li><li>控制成本</li><li>可分析性</li></ul></li></ul><h2 id="4-9-软件详细设计"><a href="#4-9-软件详细设计" class="headerlink" title="4.9 软件详细设计"></a>4.9 软件详细设计</h2><ul><li>目标：<ul><li>详细设计阶段具体地设计所要求的系统，得出新系统的软件详细规格。同时，要求设计出的规格简明易懂，便于下一阶段用某种程序设计语言在计算机上实现。</li><li>如何高质量地完成详细设计是提高软件质量的关键。</li></ul></li><li>任务：<ul><li>算法过程的设计;</li><li>数据结构的设计;</li><li>数据库物理设计;</li><li>信息编码设计;</li><li>测试用例的设计;</li><li>其他设计：网络、输入输出等</li><li>编写“详细设计说明书” 。</li></ul></li><li>结构化程序的详细设计技术的特点：<ul><li>自顶向下，逐步求精</li><li>单入口、单出口的三种基本流程控制结构</li></ul></li><li>程序流程图<ul><li>优点：直观、灵活、易使用，便于初学者掌握</li><li>缺点：程序流程图本质上并不是逐步求精的好工具，它诱使程序设计人员过早考虑程序的控制流程，而不去考虑程序的全局结构；另一方面，用箭头表示控制流方向，可以实现控制流的任意转移，如果使用得当则简单易懂且灵活，否则非结构化的程序流程图可能非常难理解，无法进行修改和维护。同时，程序流程图也不便于表示数据结构。</li></ul></li><li>盒图<ul><li><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111231953114.png" alt="盒图"></li><li>优点：它强制设计人员使用结构化技术，从而可以保证设计的质量。同时，从盒图上可以直观地看出某一特定控制结构的作用范围，为理解设计意图、编程实现、选择测试用例等带来了方便。在使用时还可附上一个描述数据结构的盒子，使得盒图更加适用于详细设计</li><li>缺点：盒图的修改比较麻烦，且结构嵌套层次较多时不太容易绘制，以致盒图的使用至今仍不流行</li></ul></li><li>判定树和判定表：见前面</li><li>问题分析图<ul><li><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111231955384.png" alt="常用符号"></li><li>特点：<ul><li>问题分析图强制设计人员采用结构化技术。</li><li>采用树形结构，既克服了程序流程图不能清晰表现程序层次结构的缺点，又不同于盒图将处理约束在一个盒子里而使修改麻烦，并且这种结构为软件的自动生成提供了有力的帮助（树遍历）</li></ul></li></ul></li><li>Jackson程序设计方法<ul><li>Jackson结构程序设计方法（Jackson Structured Programming，JSP）是英国人M.A.Jackson首先提出来的，是一种面向数据结构的结构化程序设计方法。</li><li>该方法通过分析问题的输入、输出数据结构（用Jackson图表示）的对应关系，按一定的映射规则将其映射成软件的过程描述，用Jackson伪代码表示。</li><li><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111231958762.png" alt="Jackson图"></li><li><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111231959892.png" alt="Jackson伪代码"></li><li>步骤：<ul><li>分析并确定问题的输入和输出数据结构，并用Jackson图表示。</li><li>找出输入和输出数据结构中有对应关系的数据单元。</li><li>将数据结构映射为程序结构。</li><li>列出完成程序结构图中各处理框功能的全部操作，以及有关条件，并将它们分配到程序结构图的适当位置。</li><li>用Jackson伪代码写出与程序结构图相对应的过程性表示。</li></ul></li></ul></li><li>Wariner图<ul><li><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111232000138.png" alt="Wariner图"></li><li>步骤：<ul><li>分析和确定问题的输入和输出数据结构，并用Warnier图来表示；</li><li>从数据结构（特别是输入数据结构）导出程序的处理结构，用Warnier图表示；</li><li>将程序结构改用程序流程图表示；</li><li>根据上一步得出的程序流程图，写出程序的详细过程性描述</li></ul></li></ul></li><li>面向对象程序的详细设计<ul><li>面向对象程序的核心概念是类，具有三种基本特性：封装、继承、多态</li><li>封装性：类的封装性使得数据和操纵数据的算法（函数或过程）紧密地捆绑在一起，这样就可以使得操纵数据的函数或过程的作用域和可视性限制在软件系统的局部区域内</li><li>继承性：在面向对象程序设计中，允许某个类继承其它类的成员函数或数据成员。被继承的类称为基类、父类或超类，继承的类称为派生类或子类</li><li>多态性：多态性使得相关的类可有同名的函数，这个同名的函数根据不同类产生不同的结果。换言之，不同类的对象可以具有相同的接口，这些相同的接口自然会呈现出不同的行为。通过多态性程序设计，可以编写并编译代码以处理未知类型的对象。</li><li>设计原则：<ul><li>可复用性:保证方法的内聚性;减少一个方法的代码规模;保持方法对外接口的一致性;分离策略（控制）方法和实现方法;方法应均匀覆盖数据；加强封装性；减少方法的耦合性。</li><li>可扩展性：封装数据；封装方法内部的数据结构；避免情况分支语句；区分公有方法和私有方法。</li><li>健壮性 ：防止输入错误 （围栏）；把握优化代码的时机；检查参数的合法性；选择适当的实现方法。</li><li>协作性：对类进行详细的文档化；把类打包成模块；尽量使得代码容易理解；等等</li></ul></li></ul></li></ul><h1 id="第五章-软件验证技术"><a href="#第五章-软件验证技术" class="headerlink" title="第五章 软件验证技术"></a>第五章 软件验证技术</h1><ul><li>进行软件验证的方式大体有两种：测试和证明</li><li>测试又分静态测试和动态测试两种。</li><li>静态测试，又称评审，是对软件进行的一种分析和检查活动。</li><li>动态测试是通过运行软件来检验其动态行为和运行结果的正确性。</li><li>证明是一种通过形式化的数学方法来确保软件正确性的活动。</li><li>软件测试是<strong>确保软件质量</strong>和降低软件成本的重要手段，<u>涉及软件的整个生存周期</u></li></ul><h2 id="5-1-软件测试基础"><a href="#5-1-软件测试基础" class="headerlink" title="5.1 软件测试基础"></a>5.1 软件测试基础</h2><ul><li><p>软件测试≠程序测试</p></li><li><p>软件测试对象：软件生存周期各阶段<strong>文档和代码</strong></p></li><li><p>据美国一家公司统计：64%的错误属于分析和设计的错误，<strong>编码错误只占36%。</strong></p></li><li><p>软件测试<strong>不是打消软件工程师积极性</strong>的过程，而是同软件分析与设计一样，是为了建成高质量的软件，只不过是从不同的侧面进行罢了。</p></li><li><p>软件测试试图以<strong>最少的代价</strong>发现软件分析、设计和编码中存在的各种不同类型的<strong>错误</strong>，从而提高软件<strong>质量</strong>，降低软件<strong>成本</strong>。</p></li><li><p>测试原则:</p><ul><li>测试应“尽早地和不断地进行”。</li><li>较早确定测试计划，严格执行测试计划。</li><li>注意错误的群集现象和应用Pareto原则。</li><li>测试规模应从小到大。</li><li>测试应一般由独立的第三方进行。</li><li>应保证测试用例的完整性和有效性。</li><li>应保存所有测试用例和出错统计等，直至软件不用为止。</li></ul></li><li><p>测试工具:一种测试软件，开发人员借助它可以提高软件测试工作的效率</p><ul><li>按工作方式分类:静态测试工具和动态测试工具</li><li>按功能分类:测试计划工具——支持制订测试计划；测试设计与开发工具——支持测试数据生成等；测试执行工具——支持特定的测试方法，支持回归测试等；测试评价工具——报告测试覆盖情况；测试管理工具——协助进行测试组织工作；以及其它辅助测试工具等</li></ul></li><li><p>典型软件测试工具</p><ul><li>静态分析工具<ul><li>通过扫描被测程序的正文，对其数据流和控制流进行分析，然后送出测试报告。</li><li>主要功能包括：变量检查、逻辑结构检查、接口检查、编程风格检查和静态特性统计等，通过建立交叉引用表的方式等实现。</li></ul></li><li>动态测试工具<ul><li>通过对被测程序有控制地运行，自动地监视、记录和统计被测程序的运行情况。</li><li>主要功能包括：语句执行次数统计、执行开销估算、CPU执行时间分析和软硬件资源利用分析等。</li></ul></li><li>测试数据自动生成程序<ul><li>用来为被测程序自动产生测试输入数据。这样，一方面可以减轻生成大量测试数据的负担，另一方面可以避免人为的偏见。对于预期结果，可以利用手工计算等得到</li><li>按生成测试数据的方式来分有：路径测试数据生成程序、随机测试数据生成程序、根据数据规格说明生成测试数据等</li></ul></li><li>文档比较程序<ul><li>用来自动检查测试结果。</li><li>其检查过程一般主要由三步组成；首先建立一个存放预期结果的文件；然后执行测试，并把测试结果存进另一文件；最后，使用文件比较程序比较上述两个文件，打印出有差异者的情况</li></ul></li></ul></li><li><p>测试组织</p><ul><li>一般来讲，独立测试之前，软件开发者应负责对程序单个模块测试，以保证每个模块能完成详细设计的功能等。</li><li>在很多情况下，软件开发者也进行集成测试，以保证每个模块能按总体设计的要求形成整个软件系统。</li><li>在系统形成之后，独立测试小组才开始介入，同时为了保证测试顺利进行，在测试过程中，开发人员必须协助。独立测试应确保系统满足需求分析的要求和用户意图。</li></ul></li><li><p>测试与调试</p><ul><li>测试是查找错误症状的过程</li><li>调试则是查找错误症状原因并改正错误的过程</li></ul></li><li><p>动态测试步骤</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111232034021.png" alt="动态测试步骤"></p></li></ul><h2 id="5-2-代码复审"><a href="#5-2-代码复审" class="headerlink" title="5.2 代码复审"></a>5.2 代码复审</h2><ul><li>代码复审一般在程序通过编译（如查找语法等错误）及静态分析工具检查（如找出程序在结构、编码标准与风格等方面的错误）之后，在动态测试之前进行。</li><li>代码复审是一种人工进行的测试，可以由程序作者本人非正式地进行，也可以由审查小组以开会的方式进行。</li><li>代码复审的主要方法有：代码会审、走查、办公桌检查。</li><li>经验表明，代码复审是一种非常有效的程序验证技术，该方法能够有效地发现30%到70%的逻辑设计和编码错误。</li><li>内容:<ul><li>对源程序代码进行的复审主要着重于检查编码实现是否完备、正确等。</li><li>在复审过程中，可以对照有关条例或错误检验表，查找程序在结构、功能、编码标准和风格等方面的错误或提出质疑。</li><li><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111232036776.png" alt="代码复审内容条例举例"></li><li><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111232037515.png" alt="错误检验表一般内容"></li></ul></li><li>代码会审<ul><li>会审小组一般由4人左右组成，包括组长1人，程序作者1人，其他程序员（或测试员）1~2人。会审小组通过对评审材料阅读、讨论和争议，对程序代码进行检查。</li><li>会前，小组负责人将待评审的材料及有关附件发放给与会者，以熟悉有关内容。</li><li>会上，程序作者逐句朗读并讲解程序代码，其他人则集中精力对照有关条例或检查表，捕捉程序可能存在的问题，也可以展开讨论。</li><li>会后，应把查出的问题清单交给程序作者处理，作者处理完后交回组长。如果问题很多，或者程序改动较大，则在改正后应再次组织会审。</li><li><strong>会审一方面可使得同行之间相互启发从而更易于发现错误，另一方面有利于互相学习、交流经验、取长补短，以进一步提高软件开发质量和效率。</strong></li></ul></li><li>走查<ul><li>会前，发放有关材料给与会者进行熟悉，并至少指定一人设计测试用例。</li><li>会上，与会者扮演计算机角色，人工“执行”被测程序。通过将测试用例“输入”被测程序，对程序的逻辑和功能提出各种疑问，并进行有关的讨论和争议，以发现程序中存在的问题。</li><li>会后的处理同代码会审相同 。</li></ul></li><li>办公桌检查<ul><li>办公桌检查可以看成是由一个人进行的代码复审。</li><li>程序作者在程序通过编译之后，进行单元测试之前，对源代码进行分析、检验，并补充有关文档，以发现程序中的错误。</li><li>其方式可以按照错误检验表来分析被查程序，也可以仿照走查对程序进行人工“执行”。</li></ul></li></ul><h2 id="5-3-白盒测试"><a href="#5-3-白盒测试" class="headerlink" title="5.3 白盒测试"></a>5.3 白盒测试</h2><ul><li>白盒测试是一种以程序的内部逻辑结构为依据设计测试用例的方法，因而又称结构测试或玻璃盒测试。</li><li>合理的白盒测试就是要选取足够的测试用例，对源代码实行比较充分的覆盖，以便尽可能多地发现程序中的错误。（原因：穷举测试不合理）。</li><li>主要有两种方法：一种称为逻辑覆盖法，另一种称为路径覆盖法。除此外，对循环的测试，可采用循环覆盖法。</li></ul><h3 id="5-3-1-逻辑覆盖法"><a href="#5-3-1-逻辑覆盖法" class="headerlink" title="5.3.1 逻辑覆盖法:"></a>5.3.1 逻辑覆盖法:</h3><ul><li><p>内容:</p><ul><li>语句覆盖：测试用例能使被测程序的每条执行语句至少执行一次。</li><li>判定覆盖：测试用例能使被测程序中的每个判定至少取得一次“真”和一次“假”。又称分支覆盖。</li><li>条件覆盖：测试用例能使被测程序中每个判定的每个条件至少取得一次“真”和一次“假”。如果判定中只有一个条件，则条件覆盖便满足判定覆盖，否则，不一定。</li><li>判定/条件覆盖：测试用例既满足判定覆盖，又满足条件覆盖。</li><li>条件组合覆盖：测试用例使每个判定中所有可能的条件取值组合至少执行一次。</li></ul></li><li><p>步骤:</p><ul><li>选择逻辑覆盖程度类型；</li><li>选择测试路径以满足选定的覆盖程度；</li><li>选择测试输入数据以满足选定的测试路径和覆盖程度；</li><li>根据测试输入数据和测试路径计算预期结果。</li></ul></li></ul><h3 id="5-3-2-基本路径覆盖法"><a href="#5-3-2-基本路径覆盖法" class="headerlink" title="5.3.2 基本路径覆盖法:"></a>5.3.2 基本路径覆盖法:</h3><ul><li>逻辑覆盖法并没有检测程序的所有执行路径。</li><li>基本路径测试是T.McCabe（音译：麦凯伯）首先提出的一种白盒测试技术。所谓基本路径是指程序中至少引进一条新的语句或一个新的条件的任一路径。</li><li>循环处理在计算路径时只计算一次。</li><li>基本路径测试法是在<strong>程序图</strong>的基础上，通过分析环形复杂性，导出基本路径集，然后设计测试用例使基本路径集中的每条路径至少经过一次。</li><li>步骤:<ul><li>以详细设计结果或源程序代码为基础，导出程序图；（注意应将复合条件判定转化为单一条件判定）。</li><li>计算程序图的环形复杂度；（可以采用图形矩阵方法计算，也可采用其它方法来计算）。</li><li>确定基本路径集；（基本路径集的路径数就是环形复杂度大小）。</li><li>生成测试用例，使基本路径集中的每条路径至少经过一次。</li></ul></li></ul><h3 id="5-3-3-循环覆盖法"><a href="#5-3-3-循环覆盖法" class="headerlink" title="5.3.3 循环覆盖法"></a>5.3.3 循环覆盖法</h3><ul><li>逻辑覆盖法和基本路径覆盖法对于循环只进行了循环一次的测试，显然是不充分的。而循环是大多数软件实现算法的关键部分，因此对循环的测试是十分重要的。</li><li>对于结构化程序而言，循环主要有三种：<ul><li>简单循环<ul><li><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111232057052.png" alt="简单循环"></li><li>对于简单循环，假设n是循环的最大次数，则可以采用如下策略设计测试用例：<ul><li>整个跳过循环，即循环0次；</li><li>只有一次通过循环，即循环1次；</li><li>循环2次；</li><li>循环m次，其中m＜n；</li><li>分别循环n-1，n和n+1次。</li></ul></li></ul></li><li>嵌套循环<ul><li><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111232058610.png" alt="嵌套循环"></li><li>对于嵌套循环，可以采用如下策略来导出测试用例：<ul><li>从最内层循环开始，其他循环设置为最小次数循环；</li><li>对最内层循环使用简单循环策略，并为范围外或排除的值增加其他测试；</li><li>由内向外构造下一个循环的测试，使其外层循环为最小次数，其内部嵌套循环为“典型”次数，直到所有循环测试完</li></ul></li></ul></li><li>串接循环<ul><li><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111232059541.png" alt="串接循环"></li><li>对于串接循环，如果串接循环的循环都彼此独立，则可以采用简单循环的测试策略；如果循环不独立，如第二个循环变量的初始值是外层第一个循环变量的当前值，则应使用嵌套循环的测试策略。</li></ul></li></ul></li></ul><h2 id="5-4-黑盒测试"><a href="#5-4-黑盒测试" class="headerlink" title="5.4 黑盒测试"></a>5.4 黑盒测试</h2><ul><li><p>黑盒测试又称功能测试、数据驱动测试等，它将待测试对象看成是一个黑盒子，不考虑程序内部的逻辑结构和特性，只依据规格说明书检查程序的功能是否能正常使用。</p></li><li><p>通常，白盒测试用于测试的早期，而黑盒测试由于不需了解程序内部情况，因而被许多后期测试（如确认测试、系统测试）采用</p></li><li><p>黑盒测试常发现错误类型:</p><ul><li>功能错误：表现在功能不正确或功能遗漏或实现了不该实现的功能等。</li><li>接口错误：表现在不能正确地接收信息或输出信息。</li><li>数据错误：表现在数据结构错误或外部信息（如数据文件）访问错误。</li><li>性能错误：表现在性能需求得不到满足。</li><li>初始化或终止错误：表现在不能进行正确的初始化或终止。</li></ul></li><li><p>测试用例设计方法:</p><ul><li><p>等价分类法</p><ul><li>等价分类法将所有可能的<strong>输入数据</strong>（有效的或无效的）<strong>划分成若干个等价类，然后从每个等价类中选出一个作为“代表”形成测试用例</strong>。</li><li>假定：<strong>等价类中的所有数据对于暴露程序中的错误是等效的</strong>。</li><li>在确定输入数据的等价类时常要分析输出数据的等价类，以便根据输出数据的等价类导出对应的输入数据等价类。</li><li>等价类划分指南:<ul><li>如果输入条件规定了一个<strong>取值范围或值的个数</strong>，则可以定义一个有效等价类和两个无效等价类。</li><li>如果输入条件是一个<strong>布尔量</strong>，则可以确定一个有效等价类和一个无效等价类。</li><li>如果规定了<strong>输入值的集合</strong>，或者规定了“必须如何”的条件，则可以定义一个有效等价类和一个无效等价类。</li><li>如果规定了<strong>输入数据必须遵守的规则</strong>，则可以定义一个有效等价类（符合规则）和若干无效等价类（从不同角度违反规则）。</li><li>如果规定了<strong>输入数据的一组值</strong>，而且程序对<strong>不同输入值做不同</strong>处理，则可以定义若干有效等价类（每个值一个有效等价类）和一个无效等价类。</li><li>如果确知已划分的<strong>等价类中各元素在程序中的处理方式是不同</strong>的，则应将此等价类进一步划分成更小的等价类。</li></ul></li><li>步骤:<ul><li>划分等价类，形成<strong>等价类表</strong>；</li><li>为每个等价类规定一个唯一的<strong>编号</strong>；</li><li>设计一个新的测试用例，使其尽量多地覆盖尚未被覆盖的<strong>有效等价类</strong>，重复这一步，直到所有的有效等价类都被覆盖为止。</li><li>设计一个新的测试用例。使其覆盖一个而且只覆盖一个<strong>无效等价类</strong>，重复这一步，直到所有无效等价类均被覆盖为止。</li></ul></li></ul></li><li><p>边界值分析法</p><ul><li>边界值分析法主要用来选择等价类边界值作为测试用例检查程序边界运行情况，是一种补充等价分类法的测试用例设计技术。</li><li>通常，输入等价类和输出等价类的边界情况是测试的重点，应当选择正好等于，刚刚小于和刚刚大于边界的值作为测试数据</li><li>指南:<ul><li>如果输入条件代表以a和b为边界的范围，则测试用例应当包含a、b、略小于下界a，略大于上界b的值。</li><li>如果输入条件规定了值的个数，则用最大个数、最小个数、比最大个数多1，比最小个数少1的数作为测试数据。</li><li>上述两条指南对输出条件也适用。</li><li>如果程序的规格说明中给出的输入和输出域是有序集合（如有序表），则应选取集合的第一个元素和最后一个元素作为测试数据。</li><li>如果程序数据结构有预定义的边界（如数组有100项，下标下界是0，上界是99），则应选择测试数据测试其边界的数据项。</li></ul></li></ul></li><li><p>猜错法</p><ul><li><p>猜错法能充分发挥人的经验和直觉，在一个测试小组中集思广益，方便实用，特别是在软件测试基础较差的情况下，很好地组织测试小组（也可包括外来人员）进行错误猜测，是一种很有效的测试方法</p></li><li><p>例子:</p><p>测试一个排序程序，可先用边界值分析法设计以下的测试用例：①排序序列为空；②排序序列仅有一个数据；③排序序列为满序列数据。然后，再用猜错法补充以下测试用例：④排序序列已经按要求排好序；⑤排序序列的顺序与要求的顺序恰好相反；⑥排序序列中的所有数据全部相等；等等</p></li></ul></li><li><p>因果图法</p><ul><li>因果图法借助图形来设计测试用例，特别适用于被测程序具有多种输入条件，程序的输出又依赖于输入条件的各种组合的情况。</li><li><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111232144249.png" alt="因果图"></li><li>步骤:<ul><li>分析程序规格说明中哪些是原因，哪些是结果。原因常常是输入条件或输入条件的等价类，结果则是输出条件。</li><li>分析程序规格说明中描述内容的语义和限制，找出两类关系，画出因果图。</li><li>把因果图转换成判定表。</li><li>对判定表的每一列写成一个测试用例</li></ul></li></ul></li></ul></li><li><p>黑盒法综合策略</p><ul><li>首先用边界值分析法设计测试用例；</li><li>必要时用等价分类法补充测试用例；</li><li>必要时再用猜错法补充测试用例；</li><li>如果在程序的说明中含有输入条件的组合，宜在一开始末就采用因果法，然后再按上述步骤进行。</li></ul></li></ul><h2 id="5-5-单元测试"><a href="#5-5-单元测试" class="headerlink" title="5.5 单元测试"></a>5.5 单元测试</h2><ul><li><p>单元测试又称模块测试或分调，是动态测试中的第一步，通常在<strong>编码阶段</strong>进行。</p></li><li><p>单元测试集中检查软件设计的最小单元——<strong>模块</strong>，即程序中最小的独立编译单位。在源程序代码经过编译、评审，确认没有语法错误之后，便可开始进行单元测试的测试用例设计，以发现程序内部逻辑结构的错误。</p></li><li><p>单元测试可以由<strong>程序作者</strong>进行，也可以由<strong>同行</strong>互测对方的单元进行。</p></li><li><p>测试策略:</p><p>单元测试一般总是把白盒法和黑盒法结合运用。先用黑盒法设计出一组基本的测试用例，然后用白盒法，根据覆盖标准要求补充新的测试用例满足覆盖标准。在一般情况下，单元测试应以白盒法为主。</p></li><li><p>作用:</p><ul><li>采用从单元开始而不是对整个程序进行测试，一方面可以减少测试工作的复杂性，另一方面容易进行错误定位和纠错。同时，对多个模块的测试可以并行地进行，从而缩短测试的周期。</li><li>性价比好</li></ul></li><li><p>内容:考察模块的接口和内部结构，检查是否符合程序规格说明（即详细设计说明书）的要求</p><ul><li>模块的接口:进出数据是否正确</li><li>局部数据结构:检查局部数据结构能否保持完整性</li><li>重要的执行通路:检查由于计算错误、判定错误、控制流错误导致的程序错误</li><li>出错处理路径:检查内部错误处理设施是否有效</li><li>影响以上各项的边界条件:检查临界数据是否正确处理</li></ul></li><li><p>测试的阶段及活动</p><ul><li>善测试计划阶段<br>(制定方法、资源及进度的计划;确定需测试的与需求有关的特性；细化计划)</li><li>获得测试用例集阶段<br>（设计测试用例集；执行测试计划及实现设计）</li><li>评价测试单元阶段<br>（执行测试规程；核对终止情况；评价测试效果和被测单元）</li></ul></li><li><p>测试软件</p><ul><li><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111232204933.png" alt="image-20211123220450883"></li><li>一般地，<strong>驱动模块</strong>应完成接收测试数据，并把数据传给被测模块，然后打印有关结果等任务；<strong>桩模块</strong>应该模拟实际模块完成少量数据处理，并检验和打印入口处的信息，然后将控制返回给被测模块。</li></ul></li></ul><h2 id="5-6-集成测试"><a href="#5-6-集成测试" class="headerlink" title="5.6 集成测试"></a>5.6 集成测试</h2><ul><li><p>集成测试，又称组装测试、综合测试或联调，是在单元测试完成之后，将所有模块按概要设计要求组装成系统的时候进行的测试。</p></li><li><p>主要目标是发现与接口有关的问题。</p></li><li><p>集成测试有组装和检验两重意义，一方面将各经过单元测试的模块拼装起来形成完整可运行的系统；另一方面要检验每一步拼装过程是否正确。</p></li><li><p>测试内容:</p><ul><li>主要检查模块接口和全局数据。</li><li>检查清单：<ul><li>穿越模块接口的数据是否会丢失；</li><li>一个模块是否对另一个模块产生不利的副作用；</li><li>模块组装后，能否达到预期要求的功能；</li><li>全局数据结构在引用中是否有问题；</li><li>模块的误差积累是否可以接受。</li></ul></li><li>主要内容:<ul><li>接口完整性</li><li>功能有效性</li><li>数据一致性</li><li>性能</li></ul></li></ul></li><li><p>测试策略:</p><ul><li>集成测试一般应由<strong>独立的测试小组</strong>进行，由测试小组提出测试用例，记录测试结果，并编制测试报告。</li><li>测试用例的设计通常采用黑盒法，其实施策略又分为<strong>非渐增式</strong>和渐增式两种。</li><li>在模块组装起来后，新的数据流路径建立起来了，新的控制逻辑可能激活了等等。这些改变可能会使原本工作正常的功能产生错误，因此，应对某些已经进行过的测试的测试用例再重新执行一遍，以保证上述改变不会传播意外的副作用，称之为<strong>回归测试</strong>。</li></ul></li><li><p>非渐增式:</p><ul><li>采用非渐增式测试，一般应先经过单元测试，然后再把所有模块一次性组装在一起进行测试，最终得到要求的软件系统。</li><li>将模块一次性组装在一起运行成功的可能性并不大。其结果往往是发现有错误，但由于程序中模块一次性引入过多，难于进行错误定位。同时，一旦修正错误之后，新的错误很可能马上会出现。</li><li>除规模很小的程序，一般很少采用此种测试策略。</li></ul></li><li><p>渐增式:</p><ul><li><p>渐增式测试采用逐步加入模块或功能簇的方式进行，在加入过程中边连接边测试，比较容易定位和修正错误，且接口也可以更容易进行彻底地测试。</p></li><li><p>按照添加模块的方式，又可分为自顶向下的渐增测试和自底向上的渐增测试</p></li><li><p>自顶向下的渐增式</p><ul><li><p>首先集成主控模块，然后按照软件结构的控制层次自上而下进行集成，把主控模块的直接（或间接）调用模块按深度优先或广度优先的方式集成到整个软件结构中。</p></li><li><p>步骤:</p><ol><li>以主控模块为被测模块兼驱动模块，所有被主控模块直接调用的下层模块全部用桩模块代替，对主控模块进行测试。</li><li>根据集成的实现方法（如深度或广度优先），用实际模块替换相应桩模块，再用桩模块代替它们的直接下属模块。</li><li>在每一个模块集成的时候都要进行测试。</li><li>进行回归测试（即重新执行以前做过的全部测试或部分测试），排除组装过程中引入新的错误。</li><li>重复(2)～(4)，直到所有的模块都已组装到系统中</li></ol></li><li><p>特点:</p><ul><li>能较早地显示整个程序的轮廓，对增强开发人员的信心，取得用户的支持，有重要的作用；</li><li>只需编写桩模块供测试用，驱动模块可以利用实际模块；</li><li>能尽早发现主要控制中的问题，减少以后的返工；</li><li>可先对逻辑输入的分支进行组装和测试，检查和克服潜藏的错误，为其后对主加工分支的组装和测试提供了保证；</li><li>由于每添加一个新模块，就进行一次测试，这样虽然耗费一些时间，但却使被测程序测试更彻底，尤其是上层模块。</li></ul></li><li><p>存在逻辑次序问题:最常见的是出现在当高层测试需要首先对较低层次进行足够测试后才能完成的时候。为了能够准确地实施测试，应当让桩模块正确而有效地模拟下层被调模块的功能和合理的接口，不能是只包含返回语句或只显示该模块已调用信息，不执行任何功能的哑模块。</p><p>解决方法:把测试推迟到桩模块用实际模块替代之后进行，或者采用自底向上组装和测试软件</p></li></ul></li><li><p>自底向上的渐增式测试</p><ul><li>步骤:<ol><li>把低层模块组合成实现某个特定的子功能的模块簇，并用编写的驱动模块控制它进行测试；可以对若干功能簇并行进行测试；</li><li>用实际模块换掉驱动模块，沿软件结构自下而上移动，把子功能簇组合起来形成更大的子功能簇，并进行测试；</li><li>重复(2)直到所有模块组装完毕</li></ol></li><li>特点:<ul><li>不能在测试的早期显示出程序的轮廓。程序的总体结构，要等到加入最后一个模块时才能最终形成；</li><li>测试软件只需要驱动模块，不需要桩模块，而且随着组装层次的上移，驱动模块将大为减少（在多数情况下，编写驱动模块要比桩模块容易）；</li><li>由于从低层模块开始组合，所以较易产生测试用例</li></ul></li></ul></li><li><p>混合的渐增式测试</p><ul><li>对上层模块采取自顶向下测试，使之能较早地显示系统的总体轮廓；</li><li>对某些关键模块或子系统采用由底向上组装和测试的方法，以便一方面能减少对模块的重复测试次数，另一方面能较容易产生测试用例。</li></ul><p>注:这里所谓的关键模块是指：（1）具有输入/输出功能的模块。（2）有重要功能、性能或含有新算法的模块。</p></li></ul></li><li><p>回归测试</p><ul><li>采用软件改动前测试时执行过的测试用例对改动后的软件再进行测试。</li><li>回归测试的测试用例有三种不同类型：<ul><li>能够测试软件的所有功能的代表性测试用例；</li><li>针对可能会被修改所影响的软件功能而进行附加测试的测试用例；</li><li>针对修改过的软件成分进行测试的测试用例。</li></ul></li></ul></li></ul><h2 id="5-7-确认测试"><a href="#5-7-确认测试" class="headerlink" title="5.7 确认测试"></a>5.7 确认测试</h2><ul><li>所谓确认测试就是验证所开发软件的功能和性能及其他特性是否符合软件需求规格说明书的要求。所以，确认测试又称之为有效性测试。</li><li>一般在模拟的环境（也可能就是开发的环境）下，运用黑盒法进行测试。</li><li>确认测试是由软件开发单位组织进行的最后一次测试，也是把软件交给用户，进行正式的安装和验收之前所作的一次重要的准备。为了确保测试质量，一方面应组织独立的测试小组进行测试，另一方面吸收任务委托单位及用户代表参加测试，以提高测试的可信度。同时，应将测试中发现的错误填入问题清单，交开发者处理。</li><li>确认测试内容:<ul><li>功能测试；</li><li>性能测试；</li><li>强度测试；</li><li>配置复审</li></ul></li><li>α测试和β测试<ul><li>α测试和β测试的测试方法，用以发现可能只有最终用户才能发现的错误。</li><li>α测试:<ul><li>α测试是由一个用户在开发环境下进行的测试；也可以是开发机构内部的用户在模拟实际操作环境下进行的测试，软件在一个自然设置状态下使用。软件在开发者对用户的“指导”下进行测试，开发者负责记录错误和使用中出现的问题。显然，α测试是在一个受控的环境中进行。</li><li>α测试的目的是评价软件产品的功能（F）、局域化（L）、可使用性（U）、可靠性（R）、性能（P）和支持（S）等方面的特性，尤其注重产品的界面和特色。</li><li>α测试可以从软件编码结束之时开始，或在模块或集成测试完成之后开始，也可以在确认测试过程中产品达到一定的稳定和可靠程度之后再开始。</li></ul></li><li>β测试:<ul><li>β测试是由软件的最终用户（多个）在一个或多个用户场所来进行。这些用户是与软件厂商签定了支持产品预发行合同的外部客户，要求用户使用该产品，并愿意返回有关问题给开发者。一般地，β测试时开发者通常不在测试现场，软件是在开发者不能控制的现场中应用。</li><li>在β测试中，由用户负责记下遇到的所有问题，包括主观认定的和真实的问题，定期向开发者报告，开发者在综合用户的报告之后进行修改，最后将软件产品交付给全体用户使用。</li><li>只有当α测试达到一定的可靠程度时，才能开始β测试。</li><li>β测试的主要目标是测试可支持性，包括文档、客户培训等。一般β测试应尽可能由主持产品发行的人员来管理。</li></ul></li></ul></li></ul><h2 id="5-8-系统测试"><a href="#5-8-系统测试" class="headerlink" title="5.8 系统测试"></a>5.8 系统测试</h2><ul><li>系统测试是在更大范围内进行的测试，它将经过确认测试的软件作为整个基于计算机的系统的一个元素，与计算机硬件、外设、支持软件、数据和人员等其他系统元素结合在一起，在实际运行环境下，对系统进行的一系列集成和确认测试。</li><li>系统测试通常由任务委托单位或用户组织的验收小组负责，一般应根据需求分析说明书来设计测试用例，在实际使用环境中运行。</li><li>系统测试的内容对不同的系统各不相同</li><li>恢复测试<ul><li>恢复测试就是要通过各种手段，让软件强制性地发生故障，然后验证恢复是否能正常进行的一种系统测试方法。</li><li>如果系统的恢复是自动的（由系统本身来进行），则应对重新初始化、数据恢复、重新启动等逐个进行正确性评价。</li><li>如果恢复需要人工干预，则需对修复的平均时间进行评估以判定它是否在允许的范围之内。</li></ul></li><li>安全性测试<ul><li>安全测试用来验证集成在系统内的保护机制是否能够在实际中保护系统不受到非法侵入。</li><li>主要破坏方法:①攻击易受损坏的部分，破坏安全性；②有目的地引发系统出错，期望在系统恢复过程中侵入系统；③通过各种手段，获取系统的密码；④浏览非保密数据，从中找到进入系统的方法；等等。</li><li>若有足够的时间和资源，好的安全性测试应能最终侵入系统。</li><li>系统设计者的任务是：把系统设计为攻破系统的代价远大于攻破系统后从中得到的好处。</li></ul></li><li>可用性测试:主要从使用的方便性、易理解性和易学性等方面对系统进行检查，以发现人为因素或使用习惯等的问题。</li><li>安装测试:要找出系统安装过程中出现的问题</li><li>互联测试:验证两个或多个不同的系统之间的互操作性。这类测试对支持标准规格说明，或承诺支持与其他系统互连的软件系统有效</li></ul><h2 id="5-9-调试"><a href="#5-9-调试" class="headerlink" title="5.9 调试"></a>5.9 调试</h2><ul><li><p>调试，又称纠错或排错，是程序测试后开始的工作，<strong>主要任务是依据测试发现的错误迹象确定错误位置和原因，并加以改正</strong>。</p></li><li><p>调试活动由两部分组成：</p><ul><li>确定程序中可疑错误的确切性质和位置。</li><li>对程序（设计，编码）进行修改，排除这个错误。</li></ul></li><li><p>调试是通过现象，找出原因的一个思维分析的过程</p></li><li><p>步骤:</p><ul><li>从错误的外部表现形式入手，确定程序中出错位置；</li><li>研究有关部分的程序，找出错误的内在原因；</li><li>修改设计和代码，以排除这个错误；</li><li>重复进行暴露了这个错误的原始测试或某些有关测试，以确认该错误是否被排除；是否引进了新的错误。</li><li>如果所做的修正无效，则撤消这次改动，重复上述过程，直到找到一个有效的解决办法为止。</li></ul></li><li><p>难点:</p><ul><li>错误的症状和引起错误的原因可能相隔很远，尤其是在高度耦合的程序结构中；</li><li>错误症状可能在另一错误被纠正后消失或暂时性的消失；</li><li>错误症状可能实际并不是由错误引起的（如舍入误差）；</li><li>错误症状可能是由不易跟踪的人工操作引起的；</li><li>错误症状可能是和时间相关的，而不是处理问题；</li><li>很难再现产生错误症状的输入条件；</li><li>错误症状可能时有时无（如在软硬件结合的嵌入式系统中常常遇到）；</li><li>错误症状可能是由于把任务分布在若干不同处理器上运行而造成。</li></ul></li><li><p>调试的策略:</p><ul><li><p>猜想法:该方法通过分析错误症状，根据以往经验，辅助使用已有的计算机工具，猜测错误的原因并进行定位。可以通过“在程序中插入打印语句”、“使用注释或GOTO语句运行部分程序”或“调试工具”等来实现该方法。</p></li><li><p>跟踪法:先分析错误征兆，确定最先发现“<strong>症状</strong>”的位置。然后，人工<strong>沿程序的控制流程</strong>，向回追踪源程序代码，直到找到<strong>错误根源</strong>或确定<strong>错误产生的范围</strong>。</p><p>跟踪法对于<strong>小程序很有效</strong>，往往能把错误范围缩小到程序中的一小段代码；仔细分析这段代码不难确定出错的准确位置。但对于大程序，由于回溯的路径数目较多，回溯会变得很困难。</p></li><li><p>演绎法:演绎法排错是测试人员首先根据已有的测试用例，设想及枚举出所有可能出错的原因做为假设；然后再用原始测试数据或新的测试，从中逐个排除不可能正确的假设；最后，再用测试数据验证余下的假设确是出错的原因。</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111232238210.png" alt="image-20211123223831158"></p></li><li><p>归纳法:基本思想是：从一些线索（错误征兆）着手，通过分析它们之间的关系来找出错误。</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111232239524.png" alt="image-20211123223916473"></p></li></ul></li><li><p>调试的原则:</p><ul><li><strong>冷静多思</strong>。调试是软件开发过程中最艰巨的脑力劳动之一。错误症状同错误原因之间往往没有明显的联系。这就要求调试人员要有耐心，并且细心，在面临困惑的情况下虚心向同行请教。</li><li><strong>彻底修改</strong>。一方面应注意其周围是否存在类似的其它错误，即考虑错误的群集现象；另一方面要纠正错误本身而不是其症状。</li><li><strong>防止引入新的错误</strong>。进行回归测试是一种较好的办法。</li></ul></li></ul><h1 id="第六章-软件维护技术"><a href="#第六章-软件维护技术" class="headerlink" title="第六章 软件维护技术"></a>第六章 软件维护技术</h1><h2 id="6-1-软件维护的基本概念"><a href="#6-1-软件维护的基本概念" class="headerlink" title="6.1 软件维护的基本概念"></a>6.1 软件维护的基本概念</h2><ul><li><p>所谓软件维护是指软件交付使用之后，为了改正错误或满足新的需求等而修改软件以达到延长软件寿命为目的的过程。</p></li><li><p>软件维护阶段的长短决定了软件寿命的长短；</p></li><li><p>软件维护阶段的费用占软件总成本的大部分。</p></li><li><p>原因:主要原因是软件维护不是因为使用时软件磨损或老化引起，而是由于软件设计不正确、不完善或使用环境的变化等引起</p></li><li><p>维护类型:</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111232243062.png" alt="image-20211123224310994"></p></li><li><p>策略:不同的维护类型需要采用不同的维护策略</p><ul><li>改正性维护:通过使用一些新技术，可以大大减少进行改正性维护的需要.除此之外，还可通过以下方法来减少此类维护活动：<ul><li>利用应用软件包；</li><li>进行防错程序设计；</li><li>提高系统结构化程度；</li><li>进行周期性维护审查。</li></ul></li><li>适应性维护:运行环境的变化是不可避免的，但可以控制<ul><li>进行配置管理。把硬件、操作系统和其他相关环境因素的可能变化进行配置管理。</li><li>修改局部化。把因环境变化而必须修改的程序局部于某些程序模块中。</li><li>使用例行程序包等。例如使用内部程序列表等，可为维护性修改程序提供方便</li></ul></li><li>完善性维护:利用前两类维护中列举的方法，可以减少此类维护。另外，使用功能强且易于使用的工具和通过用户使用系统原型模型完整地确定系统需求等可以减少完善性维护的工作量。</li><li>预防性维护:可通过采用提前实现或软件重用等手段或技术来减少此类维护活动的工作量</li><li>支援性维护:可通过提供最新用户文档或联机用户文档，进行适当的用户培训或设立专门的维护人员等方式来减少此类维护活动。</li></ul></li><li><p>软件维护成本:软件维护活动所花费的工作量占软件整个生存期工作量的70%以上</p><ul><li>Boehm模型:<ul><li>$MM<em>{维护}=ACT*MM</em>{开发}*EAF$</li><li>$ACT=(修改的指令数+增加的指令数)/指令总数$</li><li>调节因子EAF</li></ul></li><li>Belady与Lehman模型<ul><li>$M=P+K^{(c-d)}$</li><li>M表示维护所需工作量；</li><li>P表示生产性工作量，如问题分析和评价、修改设计、实现等；</li><li>K表示一个经验常数；</li><li>c表示因未采用结构化方法和缺少文档而增加的软件复杂度；</li><li>d表示维护人员对软件的熟悉程度。</li></ul></li></ul></li><li><p>副作用:指由于修改程序而导致的错误或其它不需要的活动。</p><ul><li>修改代码的副作用</li><li>修改数据的副作用</li><li>修改文档资料的副作用</li></ul></li><li><p>控制副作用:</p><ul><li>按模块把修改分组；</li><li>自顶向下地安排所修改模块的顺序；</li><li>每次修改一个模块；</li><li>对于每个修改了的模块，在安排修改下一个模块之前，要确定这个修改的副作用</li></ul></li><li><p>困难:</p><ul><li>理解别人的程序困难，且困难程度随软件配置成分的减少而迅速增加。</li><li>需要维护的软件往往存在文档资料不全，甚至有文档也不易理解并和程序代码可能不一致。当前，有些软件的文档是在代码形成后为了应付所谓的鉴定而突击出来的。</li><li>大多数软件在开发时没有考虑到将来的维护。</li><li>软件维护被人们看成是一种没有创造性的工作，往往不能引起人们的重视。部分人认为，维护别人的程序不如开发新的程序。</li></ul></li></ul><h2 id="6-2-软件维护过程"><a href="#6-2-软件维护过程" class="headerlink" title="6.2 软件维护过程"></a>6.2 软件维护过程</h2><ul><li><p>软件维护过程:本质上是修改和压缩了的软件定义和软件开发过程。</p></li><li><p>过程</p><ul><li>首先，必须建立一个维护组织，确定提出维护申请的过程及评价的过程，为每个维护申请规定标准的处理步骤。建立维护活动的登记制度，并规定复审标准。</li><li>然后，按维护组织建立的过程进行维护活动。</li></ul></li><li><p>维护组织:</p><ul><li><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111232253014.png" alt="image-20211123225313959"></li><li>职责:<ul><li>将维护申请提交给<strong>维护管理员</strong>，由维护管理员将其交给某系统的系统管理员去评价。</li><li><strong>系统管理员</strong>是熟悉产品程序的某部分的技术人员。</li><li>系统管理员对维护申请评价后由<strong>修改批准人员</strong>（又称变化授权人）决定如何进行修改。</li><li><strong>维护人员</strong>在系统管理员的指导下修改软件系统。在维护人员对系统进行修改的过程中，<strong>配置管理员</strong>应对软件配置进行审查。</li></ul></li></ul></li><li><p>维护申请</p><ul><li>维护组织通常提供维护申请表（Maintenance Request Form，简写为MRF），由申请维护的用户填写。</li><li>如果是改正性的维护，用户必须完整地说明出错的情况，如输入数据，全部输出信息以及其他有关材料。</li><li>如果申请的是适应性或完善性维护，则应提出一个简短的需求说明书</li></ul></li><li><p>维护工作流程:</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111232254465.png" alt="image-20211123225449407"></p></li><li><p>维护记录与评价:</p><ul><li><p>维护记录</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111232256112.png" alt="image-20211123225621059"></p></li><li><p>维护评价:</p><ul><li>程序运行失败的平均数；</li><li>于每类维护活动的总人时数；</li><li>平均每个程序、每种语言、每种维护类型所做的程序变动数；</li><li>维护过程中增加或删除一个源程序语句平均花费的人时数；</li><li>维护每种语言所花费的工作量（平均人时数）；</li><li>一张维护申请表的平均周转时间；</li><li>不同维护类型所占百分比。</li></ul></li></ul></li></ul><h2 id="6-3-软件可维护性"><a href="#6-3-软件可维护性" class="headerlink" title="6.3 软件可维护性"></a>6.3 软件可维护性</h2><ul><li><p>软件可维护性是指纠正软件系统中出现的错误或缺陷，以及为满足新的要求进行修改、扩充和压缩软件的容易程度。</p></li><li><p>影响软件可维护性的软件属性:</p><ul><li>可理解性:表现为人们通过阅读源代码和相关文档，理解软件的结构、接口、功能和内部过程的容易程度。</li><li>可测试性:一个软件容易被测试的程度。</li><li>可修改性:程序容易修改的程度。</li></ul></li><li><p>软件可维护性的定量度量</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111232257521.png" alt="image-20211123225755464"></p></li><li><p>提高可维护性的方法:</p><ul><li>建立明确的软件质量目标和优先级；</li><li>使用提高软件质量的技术和工具；</li><li>进行明确的质量保证审查；</li><li>选择可维护的程序设计语言；</li><li>改进程序文档；</li><li>开发时考虑到维护。</li></ul></li></ul><h2 id="6-4-软件再工程技术"><a href="#6-4-软件再工程技术" class="headerlink" title="6.4 软件再工程技术"></a>6.4 软件再工程技术</h2><ul><li><p>软件再工程（Reengineering）是一类软件工程活动，通过对旧软件(遗留系统)实施处理，以增进对软件的理解，同时又提高了软件自身的可维护性、可复用性等。</p></li><li><p>维护的局限:</p><ul><li>采用新技术所带来的竞争优势受到严重限制；</li><li>维护旧软件的成本随时间不断增加；</li><li>修改越来越困难。</li></ul></li><li><p>逆向工程:软件逆向工程，通过对程序的分析，导出更高抽象层次的表示</p></li><li><p>重构</p><ul><li>软件重构是对源代码和/或数据进行修改，使其易于理解或维护，以适应将来的变更。</li><li>Arnold总结了软件重构的好处，即：提高了程序的质量；改善了软件生产率；减少了维护工作量；使软件易于测试和调试；等等。</li><li>面向对象软件重构<ul><li>重构（名词）：对软件内部结构的一种调整，目的是在<strong>不改变软件可观察之行为</strong>的前提下提高其可理解性、降低其修改的成本。</li><li>重构（动词）：使用一系列的重构（名词），在<strong>不改变软件可观察之行为</strong>的前提下调整其结构，以达到提高其可理解性、降低其修改成本的目的。</li><li>重构是语义保持的（有测试作为保证）。因此重构只会使软件质量不断变好，不会造成破坏。</li></ul></li><li>工具支持:<ul><li>Refactoring Browser, XRefactory , jFactor工具提供半自动方法实现重构；</li><li>SmallTalk 的VisualWorks V7，Eclipse V2，Together ControlCenter V6，Intellij IDEA V3，Borland JBuilder V7等开发环境有集成的重构工具。</li></ul></li></ul></li><li><p>正向工程</p><ul><li>正向工程也称为改造，用从现存软件恢复设计中得到的信息去重构现存系统，以改善其整体质量。</li><li>由于软件的原型（现存系统）已经存在，正向工程的生产率将远高于平均水平；同时，又由于用户已对该软件有经验，因而正向工程过程可以很容易地确定新的需求和变化的方向。</li></ul></li><li><p>再工程成本/效益分析</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111232302371.png" alt="image-20211123230224315"></p></li><li><p>在工程风险分析</p><ul><li><strong>过程风险</strong>：未进行再工程成本/效益分析或在规定的时间内未达到成本/效益要求；对再工程项目的人力投入缺乏管理；对再工程方案实施缺乏监督等等。</li><li><strong>应用领域风险</strong>：再工程项目缺少本地应用领域专家支持；对源程序中体现的业务知识不熟悉；等等。</li><li><strong>技术风险</strong>：恢复设计得到的信息无用或未被充分利用；逆向工程得到的成果不可分享；缺乏再工程技术支持；等等。</li><li>除这些之外，还有<strong>人员风险</strong>（如人员缺乏协作精神）、<strong>工具风险</strong>（如工具不可靠）等等。</li></ul></li></ul><h1 id="第七章-软件质量保证与分析"><a href="#第七章-软件质量保证与分析" class="headerlink" title="第七章 软件质量保证与分析"></a>第七章 软件质量保证与分析</h1><h2 id="7-1-软件质量"><a href="#7-1-软件质量" class="headerlink" title="7.1 软件质量"></a>7.1 软件质量</h2><ul><li><p>软件质量特性:</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111232329348.png" alt="软件质量特性"></p></li><li><p>软件质量评价</p><ul><li>评价软件质量可从三个方面进行，即产品或中间产品、过程（即软件生产所需的资源和活动）和项目</li><li>产品或中间产品评价<ul><li>定义质量需求<br>质量需求包含两个方面：①问题规定或隐含的需求；②软件质量标准和其它技术信息。</li><li>准备评价<br>首先选择质量度量；然后定义质量等级；再定义评估准则。</li><li>评价过程<br>评价过程实际上是对软件产品就第2步中准备的评价内容进行实施，也分3步：<ol><li>测量——把选定的质量度量应用到软件产品上；</li><li>评级——确定某测量值的等级；</li><li>评估——根据评估准则确定产品质量，并依据管理准则判定产品是否可通过验收或是否发行等等。</li></ol></li></ul></li><li>过程或项目评价<ul><li>主要通过考察软件企业的质量保证与质量管理的质量来评价软件产品的质量。</li><li>一般来说，好的质量保证与质量管理会带来高的产品质量。</li></ul></li></ul></li><li><p>软件质量保证</p><ul><li>所谓质量保证（Quality Assurance）是为了提供足够的信任表明实体能满足质量要求，而在<strong>质量体系</strong>中实施并根据需要进行证实的全部有计划、系统化的活动。</li><li>质量体系（Quality System）是为实施质量管理所需的组织结构、程序、过程和资源</li><li>参与者:<ul><li>软件工程师：通过采用可靠的技术方法和措施，进行正式的技术复审、执行计划周密的软件测试来保证软件质量</li><li>软件质量保证小组(SQA)小组：主要辅助软件工程小组制作高质量的最终产品</li></ul></li></ul></li><li><p>软件质量管理</p><ul><li><p>确定质量方针、目标和职责，并在质量体系中通过诸如：质量策划、质量控制、质量保证和质量改进，使其实施全部管理职能的所有活动。</p></li><li><p>类型：质量检验型管理、全面质量管理和质量认证</p><p>| 质量管理 | 质量保证 |<br>| —————————————————————— | ——————————————————— |<br>| 由组织内部利益相关者发起，特别是组织的管理者 | 由利益相关者发起，特别是组织外部的顾客 |<br>| 使所有利益相关者满意为目的 | 以所有顾客满意为目的 |<br>| 关系到质量结果的取得 | 对达到质量要求的证明 |<br>| 预期的结果是所有工作都很出色 | 预期结果是确信组织的产品能为顾客满意 |</p></li></ul></li></ul><h2 id="7-2-软件复杂性分析"><a href="#7-2-软件复杂性分析" class="headerlink" title="7.2 软件复杂性分析"></a>7.2 软件复杂性分析</h2><ul><li>软件度量具有的特征：<ul><li>简单的和可计算的;</li><li>经验和直觉上有说服力;</li><li>一致的和客观的;</li><li>单位和维度的使用上是一致的;</li><li>编程语言独立性;</li><li>质量反馈的有效机制</li></ul></li></ul><h3 id="7-2-1-基于需求分析的复杂性分析"><a href="#7-2-1-基于需求分析的复杂性分析" class="headerlink" title="7.2.1 基于需求分析的复杂性分析"></a>7.2.1 基于需求分析的复杂性分析</h3><p>功能点方法</p><ul><li><p>Albrecht首先提出来；</p></li><li><p>功能点方法以需求规格说明书中双方确认的软件功能为依据，着重分析待开发系统的功能度（Functionality）。</p></li><li><p>假定：软件的大小与软件的功能度相关，而与软件功能的描述无关，也与功能需求的如何实现无关</p></li><li><p>五类功能点：</p><ul><li>用户输入数；</li><li>用户输出数；</li><li>用户查询数；</li><li>文件数；</li><li>外部接口数</li></ul></li><li><p>功能复杂性分布</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111232341633.png" alt="功能复杂性分布"></p></li><li><p>影响因子及度量</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111232342364.png" alt="影响因子及度量"></p></li><li><p>功能点计算</p><ul><li><p>$功能点FP=为调节功能点UFP<em>(常数C_1+常数C_2</em>复杂度调节值CA)$</p></li><li><p>其中，$UFP=\sum<em>{i=1}^{5}\sum</em>{j=1}^{3}W<em>{ij}C</em>{ij}$，i表示功能点型号，共5类；j表示复杂性的级数，共3级；</p><p>$W_{ij}$表示第i类功能点处于第j级复杂性的度量值</p><p>$C_{ij}$表示第i类功能点处于第j级复杂性的数目。</p><p>也可以简单地将所有同类功能点处理成同级复杂度，就有 $UFP’=\sum<em>{i=1}^{5}W_i’C_i’$， $W_i’$表示第i类功能点复杂性的度量值，$C</em>{i}’$表示第i类功能点处于第j级复杂性的数目。</p></li><li><p>常数C~1~和C~2~根据经验确定，如C~1~=0.65，C~2~=0.01</p></li><li><p>$CA=F<em>1+F_2+···+F</em>{14}$，其中，F~i~是第i类影响因子对功能点的影响调节值，取值范围为0~5，主要是根据经验确定。</p></li></ul></li><li><p>功能点的应用</p><ul><li>每个功能点（FP）的错误数；</li><li>每个功能点（FP）的缺陷数；</li><li>每个月完成的功能点（FP）数；</li><li>每个功能点（FP）的文档页数；</li><li>每个功能点（FP）的成本</li></ul></li><li><p>不足：</p><ul><li>如何划分功能点类（即如确定那些是用户输入，哪些是外部接口等）不同的人有不同的看法；</li><li>F~i~和C~1~、C~2~的确定也是主观的；</li><li>功能点方法最初主要是用于商业信息系统应用软件中，只强调了数据成份，从而对于强调功能及控制的非数据处理软件（如嵌入式软件、过程控制软件等）并不适用。</li></ul></li></ul><h3 id="7-2-2-基于软件设计的复杂性分析"><a href="#7-2-2-基于软件设计的复杂性分析" class="headerlink" title="7.2.2 基于软件设计的复杂性分析"></a>7.2.2 基于软件设计的复杂性分析</h3><ul><li>概要设计复杂性度量主要集中在软件结构的特征上。</li><li>Card和Glass定义了三种软件设计复杂度测度：结构复杂度、数据复杂度和系统复杂度。其定义分别如下：<ul><li>模块i的结构复杂度$S(i)=f^2_{out}(i)$；</li><li>模块i的数据复杂度$D(i)=V(i)/[f_{out}(i)+1]$；</li><li>系统复杂度$C(i)=S(i)+D(i)$；</li><li>其中$f_{out}(i)$表示模块i的扇出，$V(i)$表示模块i的输入/输出变量的个数。</li></ul></li><li>设计结构质量指标（DSQI）方法:<ul><li>从数据和体系结构设计中获得数据：<ul><li>S~1~=软件结构中定义的模块总数</li><li>S~2~=正确功能依赖于输入源数据或产生在其他地方使用的数据的模块数</li><li>S~3~=正确功能依赖于前导处理的模块数</li><li>S~4~=数据库中项目数（包括数据对象和所有定义对象的属性）</li><li>S~5~=特殊数据库项目总数</li><li>S~6~=数据库段数目（不同的记录或单个对象）</li><li>S~7~=有单个入口和出口的模块数目（异常处理不被看作是多重出口）</li></ul></li><li>根据S~1~～S~7~计算如下中间数据:<ul><li>程序结构：$D_1=1或0$ （如果软件结构是用明确的方法设计，如面向数据流设计，则$D_1=1$，其它$D_1=0$）</li><li>模块独立性：$D_2=1-(S2/S1)$</li><li>模块不依赖于前导处理：$D_3=1-(S3/S1)$</li><li>数据库大小：$D_4=1-(S5/S4)$</li><li>数据库分区：$D_5=1-(S6/S4)$</li><li>模块出/入口特性：$D_6=1-(S7/S1)$</li></ul></li><li>根据D~1~～D~6~计算DSQI的值:<ul><li>$DSQI=W_1D_1+W_2D_2+W_3D_3+W_4D_4+W_5D_5+W_6D_6$<br>其中W~i~是每个中间值的重要性的相对值且$W_1+W_2+…+W_6=1$</li><li>如果计算出来的DSQI明显低于平均值，则意味着应进一步改进设计；同样，如果要对一个现存的设计做重要的改动，这些改动对DSQI的影响也可以被计算出来。</li></ul></li></ul></li><li>McCabe环形计数法<ul><li>详细设计复杂性度量主要集中在模块内部结构的复杂性上</li><li>程序环形复杂度V(G)=程序流程图中的“判定数”+1<pre><code>                =程序图中的“环形数”。
                =m-n+2
</code></pre>其中m对应于程序图中的弧数，n对应于程序图中的节点数</li></ul></li></ul><h3 id="7-2-3-基于源程序代码的复杂性分析"><a href="#7-2-3-基于源程序代码的复杂性分析" class="headerlink" title="7.2.3 基于源程序代码的复杂性分析"></a>7.2.3 基于源程序代码的复杂性分析</h3><ul><li>霍尔斯特德（Halstead）根据源代码中<strong>运算符和操作数</strong>的测量值来度量源程序代码的复杂度。</li><li>在Halstead方法中，运算符是指用来处理程序中常量和变量的语法元素等，如算术运算符、逻辑运算符、关系运算符、流程控制语句、函数调用等；操作数则是指源程序代码中的常量和变量等。但对非执行语句，如注释，则不进行考虑。</li><li>Halstead方法的基本测量数据：<ul><li>程序中运算符总数N~1~</li><li>程序中操作数总数N~2~</li><li>程序中运算符种类数n~1~</li><li>程序中操作数种类数n~2~</li></ul></li><li>源程序代码复杂性度量：<ul><li>实际程序长度$N=N_1+N_2$<br>编程语言层次$L=(2/n_1)*(n_2/N_2)$</li><li>程序容量 $V=(N_1+N_2)*log_2(n_1+n_2)$</li><li>预测程序长度$N’= n_1<em>log_2n_1+n_2</em>log_2n_2$ （可在详细设计后进行预测）</li><li>估计程序工作量 $E’=V/L=(n_1<em>N_2</em>(N_1+N_2)<em>log_2(n_1+n_2))/(2</em>n_2)$ 预</li><li>测程序错误数$E”=((N_1+N_2)*log_2(n_1+n_2))/3000$</li></ul></li></ul><h3 id="7-2-4-基于软件维护的复杂性分析"><a href="#7-2-4-基于软件维护的复杂性分析" class="headerlink" title="7.2.4 基于软件维护的复杂性分析"></a>7.2.4 基于软件维护的复杂性分析</h3><ul><li>IEEE建议采用一种软件成熟度指标（SMI），以提供对软件产品的稳定性指示（基于为每一软件产品发布而做的变化）。</li><li>将SMI和维护工作量联系起来，形成一个经验模型，则可用来度量软件维护的复杂性。</li><li>SMI方法：<ul><li>测量数据：<ul><li>当前发布软件中的模块数M~T~；</li><li>当前发布软件中已经改变的模块数F~c~；</li><li>当前发布软件中已经添加的模块数F~a~；</li><li>当前发布软件中已经删除的前一次发布软件中的模块数F~d~。</li></ul></li><li>则软件成熟度指标按下式进行计算：<br>$SMI=[M_T-（F_a+F_c+F_d）]/M_T$</li><li>当SMI接近1的时候，产品便开始稳定。</li></ul></li></ul><h2 id="7-3-IS0软件质量体系"><a href="#7-3-IS0软件质量体系" class="headerlink" title="7.3 IS0软件质量体系"></a>7.3 IS0软件质量体系</h2><ul><li><p>质量体系（Quality System）是一种质量管理制度。</p></li><li><p>建立质量体系是企业保证产品质量能够持续稳定地满足质量标准要求的根本途径。</p></li><li><p>质量体系是质量管理的核心，质量管理则通过质量体系来实现。</p></li><li><p>ISO 9000族国际标准</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111240048133.png" alt="image-20211124004813020"></p></li><li><p>5类标准之间的关系</p><ul><li>“质量术语标准”是讨论问题的前提，统一术语是为了明确概念，建立共同语言。</li><li>三个“质量保证标准“是ISO 9000族标准的核心，是质量认证的基准。</li><li>“质量管理标准”描述了要达到质量保证标准应怎么管理。</li><li>“标准选用与实施指南”是对质量保证标准的解释和导引。</li><li>“支持性技术标准”则从更广泛的意义上给予标准实施的支持。</li></ul></li><li><p>ISO 9000族标准中的ISO 9001质量保证标准是软件机构推行质量认证工作的一个基础标准，我国已将其转化为国家推荐标准：GB/T 19001-1994。</p></li><li><p>ISO 9001标准在20个方面规定了供方在全部生产活动过程中的质量要求，也称为20个质量体系要素。</p></li><li><p>在欧洲和日本，主要的质量标准是ISO 9001。</p></li><li><p>ISO 9000-3是计算机软件机构实施ISO 9001的指南性标准。由于ISO 9000族标准主要针对传统的制造业制订的，不少软件企业的技术人员和管理人员觉得ISO 9001标准中质量体系要素的要求和软件工程项目有距离，ISO 9000-3这个实施指南起到了桥梁作用。</p></li><li><p>指南性主要表现在：（1）从软件的角度对ISO 9001的内容给出了具体的说明和解释；（2）指南性的标准不是认证审核的依据，依据仍是ISO 9001的各质量体系要素的实施情况。</p></li><li><p>企业软件质量体系的建立和实施：</p><ul><li>准备阶段;</li><li>质量体系策划;</li><li>编写质量体系文件;</li><li>培训内部审核员;</li><li>质量体系试运行;</li><li>内部质量体系审核;</li><li>管理评审;</li><li>质量体系认证前的准备；</li><li>质量体系认证；</li><li>质量体系的进一步改进与完善。</li></ul></li></ul><h2 id="7-4-软件配置管理"><a href="#7-4-软件配置管理" class="headerlink" title="7.4 软件配置管理"></a>7.4 软件配置管理</h2><ul><li><p>在软件的生存周期内，变化是不可避免的，而且产生的信息又非常庞大。</p></li><li><p>软件配置管理就是针对这个变化而又庞大的信息集进行有效管理的保护性活动。它可以用来:（1）标识变化；（2）控制变化；（3）保证变化被适当地实现；以及（4）记录变化，并将变化的情况报告给有关人员。</p></li><li><p>软件配置管理项：Software Configuration Items，简称SCI）是软件配置管理的对象，它包括软件生存周期内产生的所有信息项。</p><ul><li><p>配置项：</p><ul><li>与合同、源代码、过程、计划和产品有关的文档及数据；</li><li>目标代码和可执行代码；</li><li>相关产品，包括：软件工具、库内的可复用件、外购软件等。</li></ul></li><li><p>按ISO 9000-3的叙述，软件配置管理是一个管理学科，对配置项的开发和支持生存周期给予技术上和管理上的指导。</p></li><li><p>软件配置管理不同于软件维护，最主要的一点是软件配置管理是当软件项目开始时就启动，并且仅当软件终止运行后才结束的一组跟踪和控制变化的活动。</p></li><li><p>任务：</p><ul><li>制订配置管理计划；</li><li>确定配置标识；</li><li>进行配置控制，实施变更管理；</li><li>配置审计；</li><li>记录并报告配置状态；</li><li>版本控制；</li><li>发行管理和交付</li></ul><p><strong><u>软件配置管理概括地说就是标识变更、控制变更以及发布变更</u></strong></p></li></ul></li></ul><h2 id="7-5-软件过程能力成熟度模型"><a href="#7-5-软件过程能力成熟度模型" class="headerlink" title="7.5 软件过程能力成熟度模型"></a>7.5 软件过程能力成熟度模型</h2><ul><li><p>作用：一方面，可以用来评价软件组织的质量保证能力；另一方面，也为软件组织改进软件过程，提高软件过程能力提供了依据。</p></li><li><p>基本概念：</p><ul><li>软件过程：人们用于开发和维护软件及其有关产品（如项目计划、设计文档、代码、用户手册等，在模型中又称为软件工作产品）的一系列活动，包括软件工程活动和软件管理活动。</li><li>软件过程能力：描述开发组织或项目组通过执行其软件过程能实现预期结果的程度。</li><li>软件过程性能：表示开发组织或项目组遵循其软件过程所得到的实际结果。</li><li>软件过程成熟度：一个特定软件过程被明确和有效地定义、管理、测量和控制的程度。</li><li>软件能力成熟度等级：软件开发组织在走向成熟的途中几个具有明确定义的、表征软件过程能力成熟度的平台。</li><li>关键过程域：互相关联的若干软件实践活动和有关基础设施的集合。</li><li>关键实践：对关键过程域的实施起关键作用的方针、规程、措施、活动以及相关基础设施的建立。</li><li>软件过程能力成熟度模型：对软件组织进化阶段的描述，随着软件组织定义、实施、测量、控制和改进其软件过程，软件组织的能力经过这些阶段逐步前进</li><li><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111240042592.png" alt="软件过程能力成熟度模型结构"></li></ul></li><li><p>软件过程能力成熟度等级</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111240043511.png" alt="软件过程能力成熟度等级"></p></li><li><p>关键过程域：</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111240044247.png" alt="关键过程域"></p></li><li><p>关键实践：</p><ul><li><strong>执行约定</strong>：描述一个组织在保证将过程建立起来并持续起作用方面所必须采取的行动。执行约定一般包括制定组织的方针和规定高级管理者的支持。</li><li><strong>执行能力</strong>：描述为了实施软件过程，项目或组织中必须存在的先决条件。执行能力一般包括资源、组织机构和培训。</li><li><strong>执行的活动</strong>：描述为实现一个关键过程域所必须的角色和规程（即描述必须由何人做何事）。执行的活动一般包括制订计划与规程、执行计划、跟踪执行情况，必要时采取纠正措施。</li><li><strong>测量和分析</strong>：描述对过程进行测量和对测量结果进行分析的需要。测量和分析一般包括为了确定所执行活动的状态及有效性所能采用的测量和分析。</li><li><strong>验证实施</strong>：描述遵照已建立的过程进行活动的措施。验证实施一般包括管理者和软件质量保证部门所作的评审和审计。</li></ul></li><li><p>软件过程能力成熟度模型的应用</p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111240046063.png" alt="软件过程能力成熟度模型的应用"></p></li><li><p>CMM与ISO9001的主要区别：</p><ul><li>CMM明确强调持续的过程改进，而ISO9001则确定可接受的质量体系的最低要求；</li><li>CMM严格适用于软件；而ISO 9001范围很广，涵盖了硬件、软件、加工材料和服务。</li></ul></li></ul><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="逻辑覆盖法例题"><a href="#逻辑覆盖法例题" class="headerlink" title="逻辑覆盖法例题"></a>逻辑覆盖法例题</h2><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111232047925.png" alt="逻辑覆盖法例题"></p><h2 id="基本路径覆盖法例题"><a href="#基本路径覆盖法例题" class="headerlink" title="基本路径覆盖法例题"></a>基本路径覆盖法例题</h2><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111232053361.png" alt="image-20211123205306301"></p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111232053509.png" alt="image-20211123205317445"></p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111232054269.png" alt="image-20211123205406200"></p><h2 id="等价类划分例题"><a href="#等价类划分例题" class="headerlink" title="等价类划分例题"></a>等价类划分例题</h2><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111232141914.png" alt="image-20211123214106848"></p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111232141136.png" alt="image-20211123214115074"></p><h2 id="边界值分析法例子"><a href="#边界值分析法例子" class="headerlink" title="边界值分析法例子"></a>边界值分析法例子</h2><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111232143941.png" alt="image-20211123214312885"></p><h2 id="因果图法的例子"><a href="#因果图法的例子" class="headerlink" title="因果图法的例子"></a>因果图法的例子</h2><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111232148741.png" alt="image-20211123214835674"></p><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111232147940.png" alt="image-20211123214754879"></p><h2 id="功能点计算例子"><a href="#功能点计算例子" class="headerlink" title="功能点计算例子"></a>功能点计算例子</h2><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111240004976.png" alt="image-20211124000418913"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111240004383.png" alt="image-20211124000445299"></p><h2 id="McCabe环形计数法例子"><a href="#McCabe环形计数法例子" class="headerlink" title="McCabe环形计数法例子"></a>McCabe环形计数法例子</h2><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111240023221.png" alt="image-20211124002339154"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111240024469.png" alt="image-20211124002449393"><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111240025454.png" alt="image-20211124002509387"></p><h2 id="Halstead方法例子"><a href="#Halstead方法例子" class="headerlink" title="Halstead方法例子"></a>Halstead方法例子</h2><p><img src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202111240034021.png" alt="image-20211124003410924"></p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="mailto:howyoung525@foxmail.com">howyoung</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://blog.howyoung.work/posts/28593.html">https://blog.howyoung.work/posts/28593.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.howyoung.work" target="_blank">howyoung's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AC%94%E8%AE%B0/">笔记</a></div><div class="post_share"><div class="social-share" data-image="https://gitee.com/sehowyoung/images/raw/master/202108262332281.jpeg" data-sites="wechat,qq,qzone,weibo"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.png" target="_blank"><img class="post-qr-code-img" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/wechat.png" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.png" target="_blank"><img class="post-qr-code-img" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/alipay.png" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/31350.html"><img class="prev-cover" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202108262334905.jpeg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">IDEA最新版破解激活篇</div></div></a></div><div class="next-post pull-right"><a href="/posts/15096.html"><img class="next-cover" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202108262336330.jpeg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">各种学习资料</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i> <span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/33655.html" title="动态规划刷题入门"><img class="cover" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202108262337693.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-26</div><div class="title">动态规划刷题入门</div></div></a></div><div><a href="/posts/58235.html" title="回溯法"><img class="cover" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://gitee.com/sehowyoung/images/raw/master/202108262337693.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-17</div><div class="title">回溯法</div></div></a></div><div><a href="/posts/32604.html" title="贪心算法学习笔记"><img class="cover" src="data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/bg/http.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-13</div><div class="title">贪心算法学习笔记</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">软件工程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%AA%E8%AE%BA"><span class="toc-number">2.</span> <span class="toc-text">绪论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%85%A0-%E8%80%83%E8%AF%95%E5%BD%A2%E5%BC%8F%E5%92%8C%E8%AF%95%E5%8D%B7%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.</span> <span class="toc-text">Ⅰ 考试形式和试卷结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%85%A1-%E8%80%83%E5%AF%9F%E5%86%85%E5%AE%B9"><span class="toc-number">2.2.</span> <span class="toc-text">Ⅱ 考察内容</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">第一章 软件工程基本概念与过程模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%9A%84%E4%BA%A7%E7%94%9F"><span class="toc-number">3.1.</span> <span class="toc-text">1.1 软件工程的产生</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%9A%84%E7%A0%94%E7%A9%B6%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">3.2.</span> <span class="toc-text">1.2 软件工程的研究对象与基本原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95"><span class="toc-number">3.3.</span> <span class="toc-text">1.3 软件开发方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B7%A5%E5%85%B7%E5%92%8C%E7%8E%AF%E5%A2%83"><span class="toc-number">3.4.</span> <span class="toc-text">1.4 软件工程工具和环境</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-1-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B7%A5%E5%85%B7"><span class="toc-number">3.4.1.</span> <span class="toc-text">1.4.1 软件工程工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-2-%E9%9B%86%E6%88%90%E5%9E%8B%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83"><span class="toc-number">3.4.2.</span> <span class="toc-text">1.4.2 集成型软件开发环境</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-%E8%BD%AF%E4%BB%B6%E7%94%9F%E5%AD%98%E6%9C%9F%E8%BF%87%E7%A8%8B"><span class="toc-number">3.5.</span> <span class="toc-text">1.5 软件生存期过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-%E5%B8%B8%E7%94%A8%E8%BD%AF%E7%94%B2%E7%94%9F%E5%AD%98%E6%9C%9F%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.6.</span> <span class="toc-text">1.6 常用软甲生存期模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-7-%E8%BD%AF%E4%BB%B6%E6%96%87%E6%A1%A3"><span class="toc-number">3.7.</span> <span class="toc-text">1.7 软件文档</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-8-%E6%95%8F%E6%8D%B7%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91"><span class="toc-number">3.8.</span> <span class="toc-text">1.8 敏捷软件开发</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%AF%E8%A1%8C%E6%80%A7%E7%A0%94%E7%A9%B6%E4%B8%8E%E9%A1%B9%E7%9B%AE%E8%AE%A1%E5%88%92"><span class="toc-number">4.</span> <span class="toc-text">第二章 可行性研究与项目计划</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90"><span class="toc-number">4.1.</span> <span class="toc-text">2.1 系统分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E6%88%90%E6%9C%AC%E4%BC%B0%E8%AE%A1"><span class="toc-number">4.2.</span> <span class="toc-text">2.2 成本估计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E6%95%88%E7%9B%8A%E5%88%86%E6%9E%90"><span class="toc-number">4.3.</span> <span class="toc-text">2.3 效益分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E9%A3%8E%E9%99%A9%E5%88%86%E6%9E%90"><span class="toc-number">4.4.</span> <span class="toc-text">2.4 风险分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-1-%E9%A3%8E%E9%99%A9%E6%A0%87%E8%AF%86"><span class="toc-number">4.4.1.</span> <span class="toc-text">2.4.1 风险标识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-2-%E9%A3%8E%E9%99%A9%E4%BC%B0%E8%AE%A1"><span class="toc-number">4.4.2.</span> <span class="toc-text">2.4.2 风险估计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-3-%E9%A3%8E%E9%99%A9%E8%AF%84%E4%BB%B7"><span class="toc-number">4.4.3.</span> <span class="toc-text">2.4.3 风险评价</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-4-%E9%A3%8E%E9%99%A9%E7%AE%A1%E7%90%86%E4%B8%8E%E7%9B%91%E6%8E%A7"><span class="toc-number">4.4.4.</span> <span class="toc-text">2.4.4 风险管理与监控</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E8%BF%9B%E5%BA%A6%E5%AE%89%E6%8E%92"><span class="toc-number">4.5.</span> <span class="toc-text">2.5 进度安排</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-%E9%A1%B9%E7%9B%AE%E7%BB%84%E7%BB%87%E4%B8%8E%E8%AE%A1%E5%88%92"><span class="toc-number">4.6.</span> <span class="toc-text">2.6 项目组织与计划</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90"><span class="toc-number">5.</span> <span class="toc-text">第三章 需求分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E7%9A%84%E7%9B%AE%E6%A0%87"><span class="toc-number">5.1.</span> <span class="toc-text">3.1 需求分析的目标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E9%9C%80%E6%B1%82%E6%94%B6%E9%9B%86"><span class="toc-number">5.2.</span> <span class="toc-text">3.2 需求收集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E9%9C%80%E6%B1%82%E8%A7%84%E6%A0%BC%E8%AF%B4%E6%98%8E"><span class="toc-number">5.3.</span> <span class="toc-text">3.3 需求规格说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E6%95%B0%E6%8D%AE%E6%B5%81%E5%BB%BA%E6%A8%A1"><span class="toc-number">5.4.</span> <span class="toc-text">3.4 数据流建模</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-1-%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE"><span class="toc-number">5.4.1.</span> <span class="toc-text">3.4.1 数据流图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-2-%E6%95%B0%E6%8D%AE%E8%AF%8D%E5%85%B8"><span class="toc-number">5.4.2.</span> <span class="toc-text">3.4.2 数据词典</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-3-%E5%8A%A0%E5%B7%A5%E8%AF%B4%E6%98%8E"><span class="toc-number">5.4.3.</span> <span class="toc-text">3.4.3 加工说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-4-%E6%95%B0%E6%8D%AE%E6%B5%81%E5%BB%BA%E6%A8%A1%E6%AD%A5%E9%AA%A4"><span class="toc-number">5.4.4.</span> <span class="toc-text">3.4.4 数据流建模步骤</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E5%AE%9E%E4%BD%93%E4%B8%80%E5%85%B3%E7%B3%BB%E5%BB%BA%E6%A8%A1"><span class="toc-number">5.5.</span> <span class="toc-text">3.5 实体一关系建模</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-%E7%94%A8%E4%BE%8B%E5%BB%BA%E6%A8%A1"><span class="toc-number">5.6.</span> <span class="toc-text">3.6 用例建模</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-1-%E7%94%A8%E4%BE%8B%E5%9B%BE"><span class="toc-number">5.6.1.</span> <span class="toc-text">3.6.1 用例图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-2-%E5%8F%82%E4%B8%8E%E8%80%85%E5%8F%8A%E7%94%A8%E4%BE%8B%E7%9A%84%E6%8F%8F%E8%BF%B0"><span class="toc-number">5.6.2.</span> <span class="toc-text">3.6.2 参与者及用例的描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-3-%E7%94%A8%E4%BE%8B%E5%BB%BA%E6%A8%A1%E6%AD%A5%E9%AA%A4"><span class="toc-number">5.6.3.</span> <span class="toc-text">3.6.3 用例建模步骤</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%BB%BA%E6%A8%A1"><span class="toc-number">5.7.</span> <span class="toc-text">3.7 面向对象建模</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-1-%E7%A1%AE%E5%AE%9A%E5%AF%B9%E8%B1%A1-amp-%E7%B1%BB%EF%BC%88%E5%AF%B9%E8%B1%A1%E5%B1%82%EF%BC%89"><span class="toc-number">5.7.1.</span> <span class="toc-text">3.7.1 确定对象&amp;类（对象层）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-2-%E6%A0%87%E8%AF%86%E7%BB%93%E6%9E%84%EF%BC%88%E7%BB%93%E6%9E%84%E5%B1%82%EF%BC%89"><span class="toc-number">5.7.2.</span> <span class="toc-text">3.7.2 标识结构（结构层）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-3-%E6%A0%87%E8%AF%86%E4%B8%BB%E9%A2%98%EF%BC%88%E4%B8%BB%E9%A2%98%E5%B1%82%EF%BC%89"><span class="toc-number">5.7.3.</span> <span class="toc-text">3.7.3 标识主题（主题层）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-4-%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E5%8F%8A%E5%AE%9E%E5%8A%9B%E5%85%B3%E8%81%94%EF%BC%88%E5%B1%9E%E6%80%A7%E5%B1%82%EF%BC%89"><span class="toc-number">5.7.4.</span> <span class="toc-text">3.7.4 定义属性及实力关联（属性层）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-5-%E5%AE%9A%E4%B9%89%E6%9C%8D%E5%8A%A1%E5%8F%8A%E6%B6%88%E6%81%AF%E8%BF%9E%E6%8E%A5%EF%BC%88%E6%9C%8D%E5%8A%A1%E5%B1%82%EF%BC%89"><span class="toc-number">5.7.5.</span> <span class="toc-text">3.7.5 定义服务及消息连接（服务层）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-8-%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80UML"><span class="toc-number">5.8.</span> <span class="toc-text">3.8 统一建模语言UML</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-8-1-UML%E7%BB%93%E6%9E%84"><span class="toc-number">5.8.1.</span> <span class="toc-text">3.8.1 UML结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-8-2-%E7%89%B9%E7%82%B9"><span class="toc-number">5.8.2.</span> <span class="toc-text">3.8.2 特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-8-3-%E5%BA%94%E7%94%A8"><span class="toc-number">5.8.3.</span> <span class="toc-text">3.8.3 应用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1"><span class="toc-number">6.</span> <span class="toc-text">第四章 软件设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%BB%BB%E5%8A%A1%E5%92%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">6.1.</span> <span class="toc-text">4.1 软件设计的任务和过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99"><span class="toc-number">6.2.</span> <span class="toc-text">4.2 软件设计基本原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-%E6%8A%BD%E8%B1%A1%E4%B8%8E%E6%B1%82%E7%B2%BE"><span class="toc-number">6.2.1.</span> <span class="toc-text">4.2.1 抽象与求精</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-%E6%A8%A1%E5%9D%97%E5%8C%96%E5%92%8C%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F"><span class="toc-number">6.2.2.</span> <span class="toc-text">4.2.2 模块化和信息隐藏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-3-%E6%A8%A1%E5%9D%97%E7%8B%AC%E7%AB%8B%E6%80%A7"><span class="toc-number">6.2.3.</span> <span class="toc-text">4.2.3 模块独立性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E9%9D%A2%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95"><span class="toc-number">6.3.</span> <span class="toc-text">4.3 面向数据流图的设计方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-1-%E5%B1%82%E6%AC%A1%E5%9B%BE%E5%92%8C%E6%94%B9%E8%BF%9B%E7%9A%84IPO%E5%9B%BE"><span class="toc-number">6.3.1.</span> <span class="toc-text">4.3.1 层次图和改进的IPO图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-2-%E8%BD%AF%E4%BB%B6%E7%BB%93%E6%9E%84%E5%9B%BE"><span class="toc-number">6.3.2.</span> <span class="toc-text">4.3.2 软件结构图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-3-%E6%95%B0%E6%8D%AE%E6%B5%81%E5%8F%98%E6%8D%A2%E5%88%86%E6%9E%90%E6%B3%95"><span class="toc-number">6.3.3.</span> <span class="toc-text">4.3.3 数据流变换分析法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-4-%E4%BA%8B%E5%8A%A1%E5%88%86%E6%9E%90%E6%B3%95"><span class="toc-number">6.3.4.</span> <span class="toc-text">4.3.4 事务分析法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-5-%E6%94%B9%E8%BF%9B"><span class="toc-number">6.3.4.1.</span> <span class="toc-text">4.3.5 改进</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">6.4.</span> <span class="toc-text">4.4 面向对象设计原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95"><span class="toc-number">6.5.</span> <span class="toc-text">4.5 面向对象的设计方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-1-%E8%BD%AF%E4%BB%B6%E5%A4%8D%E7%94%A8"><span class="toc-number">6.5.1.</span> <span class="toc-text">4.5.1 软件复用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1"><span class="toc-number">6.5.2.</span> <span class="toc-text">4.5.2 面向对象设计</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.6.</span> <span class="toc-text">4.6 面向对象软件设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-1-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.6.1.</span> <span class="toc-text">4.6.1 创建型模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-2-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.6.2.</span> <span class="toc-text">4.6.2 结构型模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-3-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.6.3.</span> <span class="toc-text">4.6.3 行为型模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-7-%E6%A8%A1%E5%9E%8B%E4%B8%80%E8%A7%86%E5%9B%BE%E4%B8%80%E6%8E%A7%E5%88%B6%E5%99%A8%E6%A1%86%E6%9E%B6"><span class="toc-number">6.7.</span> <span class="toc-text">4.7 模型一视图一控制器框架</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-8-%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">6.8.</span> <span class="toc-text">4.8 软件体系结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-9-%E8%BD%AF%E4%BB%B6%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1"><span class="toc-number">6.9.</span> <span class="toc-text">4.9 软件详细设计</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E9%AA%8C%E8%AF%81%E6%8A%80%E6%9C%AF"><span class="toc-number">7.</span> <span class="toc-text">第五章 软件验证技术</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80"><span class="toc-number">7.1.</span> <span class="toc-text">5.1 软件测试基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E4%BB%A3%E7%A0%81%E5%A4%8D%E5%AE%A1"><span class="toc-number">7.2.</span> <span class="toc-text">5.2 代码复审</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95"><span class="toc-number">7.3.</span> <span class="toc-text">5.3 白盒测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-1-%E9%80%BB%E8%BE%91%E8%A6%86%E7%9B%96%E6%B3%95"><span class="toc-number">7.3.1.</span> <span class="toc-text">5.3.1 逻辑覆盖法:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-2-%E5%9F%BA%E6%9C%AC%E8%B7%AF%E5%BE%84%E8%A6%86%E7%9B%96%E6%B3%95"><span class="toc-number">7.3.2.</span> <span class="toc-text">5.3.2 基本路径覆盖法:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-3-%E5%BE%AA%E7%8E%AF%E8%A6%86%E7%9B%96%E6%B3%95"><span class="toc-number">7.3.3.</span> <span class="toc-text">5.3.3 循环覆盖法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95"><span class="toc-number">7.4.</span> <span class="toc-text">5.4 黑盒测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-number">7.5.</span> <span class="toc-text">5.5 单元测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-6-%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95"><span class="toc-number">7.6.</span> <span class="toc-text">5.6 集成测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-7-%E7%A1%AE%E8%AE%A4%E6%B5%8B%E8%AF%95"><span class="toc-number">7.7.</span> <span class="toc-text">5.7 确认测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-8-%E7%B3%BB%E7%BB%9F%E6%B5%8B%E8%AF%95"><span class="toc-number">7.8.</span> <span class="toc-text">5.8 系统测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-9-%E8%B0%83%E8%AF%95"><span class="toc-number">7.9.</span> <span class="toc-text">5.9 调试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E7%BB%B4%E6%8A%A4%E6%8A%80%E6%9C%AF"><span class="toc-number">8.</span> <span class="toc-text">第六章 软件维护技术</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E8%BD%AF%E4%BB%B6%E7%BB%B4%E6%8A%A4%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">8.1.</span> <span class="toc-text">6.1 软件维护的基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E8%BD%AF%E4%BB%B6%E7%BB%B4%E6%8A%A4%E8%BF%87%E7%A8%8B"><span class="toc-number">8.2.</span> <span class="toc-text">6.2 软件维护过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E8%BD%AF%E4%BB%B6%E5%8F%AF%E7%BB%B4%E6%8A%A4%E6%80%A7"><span class="toc-number">8.3.</span> <span class="toc-text">6.3 软件可维护性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-%E8%BD%AF%E4%BB%B6%E5%86%8D%E5%B7%A5%E7%A8%8B%E6%8A%80%E6%9C%AF"><span class="toc-number">8.4.</span> <span class="toc-text">6.4 软件再工程技术</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81%E4%B8%8E%E5%88%86%E6%9E%90"><span class="toc-number">9.</span> <span class="toc-text">第七章 软件质量保证与分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F"><span class="toc-number">9.1.</span> <span class="toc-text">7.1 软件质量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-%E8%BD%AF%E4%BB%B6%E5%A4%8D%E6%9D%82%E6%80%A7%E5%88%86%E6%9E%90"><span class="toc-number">9.2.</span> <span class="toc-text">7.2 软件复杂性分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-1-%E5%9F%BA%E4%BA%8E%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E7%9A%84%E5%A4%8D%E6%9D%82%E6%80%A7%E5%88%86%E6%9E%90"><span class="toc-number">9.2.1.</span> <span class="toc-text">7.2.1 基于需求分析的复杂性分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-2-%E5%9F%BA%E4%BA%8E%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%A4%8D%E6%9D%82%E6%80%A7%E5%88%86%E6%9E%90"><span class="toc-number">9.2.2.</span> <span class="toc-text">7.2.2 基于软件设计的复杂性分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-3-%E5%9F%BA%E4%BA%8E%E6%BA%90%E7%A8%8B%E5%BA%8F%E4%BB%A3%E7%A0%81%E7%9A%84%E5%A4%8D%E6%9D%82%E6%80%A7%E5%88%86%E6%9E%90"><span class="toc-number">9.2.3.</span> <span class="toc-text">7.2.3 基于源程序代码的复杂性分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-4-%E5%9F%BA%E4%BA%8E%E8%BD%AF%E4%BB%B6%E7%BB%B4%E6%8A%A4%E7%9A%84%E5%A4%8D%E6%9D%82%E6%80%A7%E5%88%86%E6%9E%90"><span class="toc-number">9.2.4.</span> <span class="toc-text">7.2.4 基于软件维护的复杂性分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-IS0%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%BD%93%E7%B3%BB"><span class="toc-number">9.3.</span> <span class="toc-text">7.3 IS0软件质量体系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86"><span class="toc-number">9.4.</span> <span class="toc-text">7.4 软件配置管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-5-%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E8%83%BD%E5%8A%9B%E6%88%90%E7%86%9F%E5%BA%A6%E6%A8%A1%E5%9E%8B"><span class="toc-number">9.5.</span> <span class="toc-text">7.5 软件过程能力成熟度模型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%99%84%E5%BD%95"><span class="toc-number">10.</span> <span class="toc-text">附录</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%A6%86%E7%9B%96%E6%B3%95%E4%BE%8B%E9%A2%98"><span class="toc-number">10.1.</span> <span class="toc-text">逻辑覆盖法例题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%B7%AF%E5%BE%84%E8%A6%86%E7%9B%96%E6%B3%95%E4%BE%8B%E9%A2%98"><span class="toc-number">10.2.</span> <span class="toc-text">基本路径覆盖法例题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AD%89%E4%BB%B7%E7%B1%BB%E5%88%92%E5%88%86%E4%BE%8B%E9%A2%98"><span class="toc-number">10.3.</span> <span class="toc-text">等价类划分例题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%B9%E7%95%8C%E5%80%BC%E5%88%86%E6%9E%90%E6%B3%95%E4%BE%8B%E5%AD%90"><span class="toc-number">10.4.</span> <span class="toc-text">边界值分析法例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%A0%E6%9E%9C%E5%9B%BE%E6%B3%95%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-number">10.5.</span> <span class="toc-text">因果图法的例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E7%82%B9%E8%AE%A1%E7%AE%97%E4%BE%8B%E5%AD%90"><span class="toc-number">10.6.</span> <span class="toc-text">功能点计算例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#McCabe%E7%8E%AF%E5%BD%A2%E8%AE%A1%E6%95%B0%E6%B3%95%E4%BE%8B%E5%AD%90"><span class="toc-number">10.7.</span> <span class="toc-text">McCabe环形计数法例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Halstead%E6%96%B9%E6%B3%95%E4%BE%8B%E5%AD%90"><span class="toc-number">10.8.</span> <span class="toc-text">Halstead方法例子</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By howyoung</div><div class="framework-info"><span>框架</span> <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题</span> <a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">望与诸君共勉！</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div></div><hr><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>function loadWaline () {
  function initWaline () {
    const waline = new Waline(Object.assign({
      el: '#waline-wrap',
      serverURL: 'https://vercel-jlmxu8rqg-sehowyoung.vercel.app',
      avatar: 'monsterid',
      avatarCDN: '//cdn.jsdelivr.net/npm/@waline/client',
      path: location.pathname,
      visitor: true,
      dark: 'html[data-theme="dark"]'
    }, null))
  }

  if (typeof Waline === 'function') initWaline() 
  else getScript('https://cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js').then(initWaline)
}

if ('Waline' === 'Waline' || !true) {
  if (true) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
  else setTimeout(loadWaline, 0)
} else {
  function loadOtherComment () {
    loadWaline()
  }
}</script></div><script id="canvas_nest" defer color="0,0,255" opacity="0.7" zindex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>